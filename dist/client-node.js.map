{"version":3,"sources":["webpack:///client-node.js","webpack:///webpack/bootstrap 3d41e686ee32dfe42526","webpack:///./src/lib/error.js","webpack:///external \"lodash/assign\"","webpack:///external \"event-emitter-extra\"","webpack:///external \"lodash/isObject\"","webpack:///external \"lodash/isString\"","webpack:///./src/client/client-web.js","webpack:///external \"ws\"","webpack:///./src/lib/closestatus.js","webpack:///./src/lib/deferred.js","webpack:///./src/lib/message.js","webpack:///./src/lib/utils.js","webpack:///external \"debug\"","webpack:///external \"lodash/debounce\"","webpack:///external \"lodash/defaultsDeep\"","webpack:///external \"lodash/forEach\"","webpack:///external \"lodash/isBoolean\"","webpack:///external \"lodash/isFunction\"","webpack:///external \"lodash/isInteger\"","webpack:///external \"lodash/isNumber\"","webpack:///external \"lodash/isUndefined\"","webpack:///external \"lodash/values\"","webpack:///./src/client/client-node.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","Object","defineProperty","configurable","enumerable","get","n","__esModule","o","object","property","prototype","hasOwnProperty","p","s","LineError","code","message","payload","this","stack","Error","require","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","writable","setPrototypeOf","__proto__","_createClass","defineProperties","target","props","length","descriptor","key","protoProps","staticProps","Message","EventEmitterExtra","Deferred","forEach","debounce","isObject","isBoolean","isString","isNumber","isInteger","defaultsDeep","debug","CloseStatus","Client","_EventEmitterExtra","url","arguments","undefined","options","_this","getPrototypeOf","trim","ErrorCode","INVALID_OPTIONS","handshake","timeout","responseTimeout","disconnectTimeout","pingInterval","reconnect","reconnectOptions","initialDelay","multiply","maxDelay","randomness","uptime","uptimeOptions","interval","window","JSON","stringify","err","ws_","id","state","State","READY","reconnectState_","disabled","attempt","deferreds_","disconnectTimeout_","uptimeBuffer_","uptimeBufferLength_","Math","round","uptimeInterval_","setInterval","uptimeTick_","bind","autoPing_","ping","then","CONNECTED","catch","DISCONNECTED","WebSocket","bindEvents_","CONNECTING","emit","Event","WEBSOCKET_ERROR","_this2","Promise","resolve","reject","connect","removeListeners","onConnectingError","onConnected","data","onDisconnected","e","removeListener","CONNECTING_ERROR","once","reason","opt_retry","_this3","HANDSHAKING","close","rejectAllDeferreds_","cancel","clearTimeout","setTimeout","ERROR","DISCONNECT_TIMEOUT","onClose_","DISCONNECTING","retry","_this4","disconnect","onopen","onOpen_","onclose","onerror","onError_","onmessage","onMessage_","_this5","Name","HANDSHAKE","send_","resetReconnectState_","HANDSHAKE_ERROR","HANDSHAKE_FAILED","MESSAGE_TIMEOUT","MESSAGE_REJECTED","HANDSHAKE_REJECTED","closeEvent","_this6","unBindEvents_","max","min","random","eventName","parse","INVALID_JSON","PING","onPingMessage_","RESPONSE","onResponseMessage_","ReservedNames","indexOf","onMessageWithResponse_","onMessageWithoutResponse_","sendWithoutResponse_","createResponse","deferred","_this7","MESSAGE_NOT_RESPONDED","dispose","opt_timeout","_this8","setId","onExpire","EXPIRED","_this9","readyState","messageStr","toString","send","_this10","currentSocket","PING_FAILED","PING_ERROR","push","splice","filter","val","_this11","removeAllListeners","clearInterval","DISPOSED","INTERNAL_ERROR","UNKNOWN_ERROR","_ref","_ref$handler","handler","_ref$onExpire","_ref$timeout","resolve_","reject_","timeout_","timeoutDuration_","onExpire_","isFinished_","promise","expire","clearTimeout_","_len","args","Array","_key","apply","_len2","_key2","isUndefined","values","assign","_require","generateDummyId","isResponded_","raw","MISSING_ID","ALREADY_RESPONDED","err_","events","eventNames","event","pow","slice","global"],"mappings":"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","file":"client-node.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmory imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmory exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tObject.defineProperty(exports, name, {\n/******/ \t\t\tconfigurable: false,\n/******/ \t\t\tenumerable: true,\n/******/ \t\t\tget: getter\n/******/ \t\t});\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 21);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\"use strict\";\n'use strict';\n\nfunction LineError(code, message, payload) {\n    this.name = 'LineError';\n    this.message = message;\n    this.code = code;\n    this.payload = payload;\n    this.stack = new Error().stack;\n}\nLineError.prototype = new Error();\n\nmodule.exports = LineError;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/assign\");\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"event-emitter-extra\");\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isObject\");\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isString\");\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Message = __webpack_require__(9);\nvar EventEmitterExtra = __webpack_require__(2);\nvar Deferred = __webpack_require__(8);\nvar assign = __webpack_require__(1);\nvar forEach = __webpack_require__(14);\nvar debounce = __webpack_require__(12);\nvar isObject = __webpack_require__(3);\nvar isBoolean = __webpack_require__(15);\nvar isString = __webpack_require__(4);\nvar isNumber = __webpack_require__(18);\nvar isInteger = __webpack_require__(17);\nvar defaultsDeep = __webpack_require__(13);\nvar debug = __webpack_require__(11)('line:client');\nvar LineError = __webpack_require__(0);\nvar CloseStatus = __webpack_require__(7);\n\n/**\n * Line client class.\n *\n * @class Client\n * @extends {EventEmitterExtra}\n * @param {string=} url Server url, default: `ws://localhost`.\n * @param {Object=} options Options object.\n * @param {Object=} options.handshake Handshake options\n * @param {number=} options.handshake.timeout Handshake timeout duration in milliseconds.\n *      Default: `30000` (30 seconds).\n * @param {any=} options.handshake.payload Handshake payload that will be send to server.\n * @param {number=} options.responseTimeout This is the timeout for getting response from the server\n *      when using `client.send()` method. Default: `10000` (10 seconds). Note that this option is ineffective for\n *      `client.sendWithoutResponse()` method.\n * @param {number=} options.disconnectTimeout In some browsers, `close` frame is not fired immediately.\n *      This timeout is for starting `close` procedure even if close frame is not arrived. Default: `5000` (5 seconds).\n * @param {number=} options.pingInterval Pinging interval. Default: `20000` (20 seconds).\n * @param {boolean=} options.reconnect Whether try to reconnect server after unexpected disconnection,\n *      default `true`.\n * @param {Object=} options.reconnectOptions Reconnection options.\n * @param {number=} options.reconnectOptions.initialDelay In milliseconds. Default: `1000` (1 second).\n * @param {number=} options.reconnectOptions.multiply Default: `1.5`\n * @param {number=} options.reconnectOptions.maxDelay In milliseconds. Default: `30000`\n * @param {number=} options.reconnectOptions.randomness Random delay multiplier. Default: `0.5`\n * @param {boolean=} options.uptime Whether keep & calculate uptime, default `false`.\n *      If this option is not true, `client.getUptime()` returns undefined.\n * @param {Object=} options.uptimeOptions Uptime options.\n * @param {number=} options.uptimeOptions.interval Uptime checking interval. In milliseconds. Default: `5000` (5 seconds).\n * @param {number=} options.uptimeOptions.window Uptime checking window length. In milliseconds. Default: `300000` (5 minutes)\n * @property {string} url Server url\n * @property {string} id Unique connection id assigned by the server. It will be accessible after handshake.\n * @property {Client.State} state Connection state\n * @example\n * // Add line-client to your html document\n * <script src=\"./node_modules/line-socket/dist/client-web-globals.js\"></script>\n *\n * // For web browsers (consuming as a commonjs module)\n * const LineClient = require('line-socket/client-web');\n *\n * // For node.js\n * const LineClient = require('line-socket/client-node');\n *\n * // Usage\n * const client = new LineClient('ws://localhost:8080');\n * client.connect();\n */\n\nvar Client = function (_EventEmitterExtra) {\n    _inherits(Client, _EventEmitterExtra);\n\n    function Client() {\n        var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'ws://localhost';\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, Client);\n\n        var _this = _possibleConstructorReturn(this, (Client.__proto__ || Object.getPrototypeOf(Client)).call(this));\n\n        if (!isString(url) || url.trim().length == 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, 'Url parameter must be string and cannot be empty');\n\n        if (!isObject(options)) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, 'Options parameter must be an object');\n\n        _this.url = url.trim();\n        _this.options = defaultsDeep(options, {\n            handshake: {\n                timeout: 30000,\n                payload: undefined\n            },\n            responseTimeout: 10000,\n            disconnectTimeout: 5000,\n            pingInterval: 20000,\n            reconnect: true,\n            reconnectOptions: {\n                initialDelay: 1000,\n                multiply: 1.5,\n                maxDelay: 30000,\n                randomness: 0.5\n            },\n            uptime: false,\n            uptimeOptions: {\n                interval: 5000,\n                window: 300000\n            }\n        });\n\n        if (!isObject(_this.options.handshake)) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.handshake\" must be an object');\n\n        if (!isInteger(_this.options.handshake.timeout) || _this.options.handshake.timeout < 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.handshake.timeout\" must be a positive integer or zero');\n\n        try {\n            JSON.stringify(_this.options.handshake.payload);\n        } catch (err) {\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.handshake.payload\" must be json friendly, probably circular dependency?');\n        }\n\n        if (!isInteger(_this.options.responseTimeout) || _this.options.responseTimeout < 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.responseTimeout\" must be a positive integer or zero');\n\n        if (!isInteger(_this.options.disconnectTimeout) || _this.options.disconnectTimeout < 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.disconnectTimeout\" must be a positive integer or zero');\n\n        if (!isInteger(_this.options.pingInterval) || _this.options.pingInterval < 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.pingInterval\" must be a positive integer or zero');\n\n        if (!isBoolean(_this.options.reconnect)) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.reconnect\" must be a boolean');\n\n        if (!isObject(_this.options.reconnectOptions)) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.reconnectOptions\" must be an object');\n\n        if (!isInteger(_this.options.reconnectOptions.initialDelay) || _this.options.reconnectOptions.initialDelay <= 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.reconnectOptions.initialDelay\" must be a positive integer');\n\n        if (!isNumber(_this.options.reconnectOptions.multiply) || _this.options.reconnectOptions.multiply < 1) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.reconnectOptions.multiply\" must be a number >= 1');\n\n        if (!isInteger(_this.options.reconnectOptions.maxDelay) || _this.options.reconnectOptions.maxDelay <= 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.reconnectOptions.maxDelay\" must be a positive integer');\n\n        if (_this.options.reconnectOptions.maxDelay < _this.options.reconnectOptions.initialDelay) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.reconnectOptions.maxDelay\" must be a greater than initial delay');\n\n        if (!isNumber(_this.options.reconnectOptions.randomness) || _this.options.reconnectOptions.randomness < 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.reconnectOptions.randomness\" must be a positive number or zero');\n\n        if (!isBoolean(_this.options.uptime)) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.uptime\" must be a boolean');\n\n        if (!isObject(_this.options.uptimeOptions)) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.uptimeOptions\" must be an object');\n\n        if (!isInteger(_this.options.uptimeOptions.interval) || _this.options.uptimeOptions.interval <= 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.uptimeOptions.interval\" must be a positive integer');\n\n        if (!isInteger(_this.options.uptimeOptions.window) || _this.options.uptimeOptions.window <= 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.uptimeOptions.window\" must be a positive integer');\n\n        if (_this.options.uptimeOptions.window < _this.options.uptimeOptions.interval) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.uptimeOptions.window\" must be a greater than interval');\n\n        _this.ws_ = null;\n        _this.id = null;\n        _this.state = Client.State.READY;\n\n        _this.reconnectState_ = { disabled: false, attempt: 0, timeout: null };\n        _this.deferreds_ = {};\n        _this.disconnectTimeout_ = null;\n        _this.uptimeBuffer_ = [];\n        _this.uptimeBufferLength_ = Math.round(_this.options.uptimeOptions.window / _this.options.uptimeOptions.interval);\n        _this.uptimeInterval_ = options.uptime ? setInterval(_this.uptimeTick_.bind(_this), _this.options.uptimeOptions.interval) : null;\n        _this.autoPing_ = debounce(function () {});\n\n        if (_this.options.pingInterval > 0) {\n            _this.autoPing_ = debounce(function () {\n                _this.ping().then(function () {\n                    // Ping successfull. If we still connected, debounce next one!\n                    if (_this.options.pingInterval > 0 && _this.state == Client.State.CONNECTED) {\n                        _this.autoPing_(); // Recursive\n                    }\n                }).catch(function () {/* ping() method handles disconnection the logic itself */});\n            }, _this.options.pingInterval);\n        }\n        return _this;\n    }\n\n    /**\n     * Starts the connection procedure.\n     *\n     * If server url is invalid or there is a security error,\n     * this method will throw `Client.ErrorCode.WEBSOCKET_ERROR`.\n     *\n     * When procedure is started, `Client.Event.CONNECTING` event will be emitted.\n     *\n     * If an error occured during connection or handshake, the client will emit `Client.Event.CONNECTING_ERROR`.\n     *\n     * If connection is failed for some reason and `options.reconnect` is `true`. The client will\n     * retry to connect.\n     *\n     * @returns {boolean}\n     * @example\n     * client.connect();\n     *\n     * client.on(Client.Event.CONNECTED, () => {\n     *   console.log('Client connected.');\n     * });\n     *\n     * client.on(Client.Event.CONNECTING_ERROR, (err) => {\n     *   console.log('Could not connect!', err);\n     * });\n     */\n\n\n    _createClass(Client, [{\n        key: 'connect',\n        value: function connect() {\n            switch (this.state) {\n                case Client.State.DISCONNECTED:\n                case Client.State.READY:\n                    debug('Connecting to \"' + this.url + '\" ...');\n\n                    try {\n                        this.reconnectState_.disabled = false;\n                        this.ws_ = new WebSocket(this.url);\n                        this.bindEvents_();\n                        this.state = Client.State.CONNECTING;\n                        this.emit(Client.Event.CONNECTING);\n                        return true;\n                    } catch (err) {\n                        throw new LineError(Client.ErrorCode.WEBSOCKET_ERROR, 'Native websocket error. Invalid url or security error', err);\n                    }\n\n                default:\n                    debug('Ignoring connect() call, client is in \"' + this.state + '\" state');\n                    return false;\n            }\n        }\n\n        /**\n         * TODO: This is an experimental method currently, it's just used in tests.\n         * DO NOT use in production.\n         *\n         * @returns {Promise}\n         * @ignore\n         */\n\n    }, {\n        key: 'connectAsync',\n        value: function connectAsync() {\n            var _this2 = this;\n\n            return new Promise(function (resolve, reject) {\n                _this2.connect(); // Can throw WEBSOCKET_ERROR or ignore silently\n\n                var removeListeners = function removeListeners() {};\n\n                var onConnectingError = function onConnectingError(err) {\n                    removeListeners();\n                    reject(err);\n                };\n\n                var onConnected = function onConnected(data) {\n                    removeListeners();\n                    resolve(data);\n                };\n\n                var onDisconnected = function onDisconnected(e) {\n                    removeListeners();\n                    reject(new LineError(Client.ErrorCode.DISCONNECTED, 'Client disconnected', e));\n                };\n\n                removeListeners = function removeListeners() {\n                    _this2.removeListener(Client.Event.CONNECTING_ERROR, onConnectingError);\n                    _this2.removeListener(Client.Event.CONNECTED, onConnected);\n                    _this2.removeListener(Client.Event.DISCONNECTED, onDisconnected);\n                };\n\n                _this2.once(Client.Event.CONNECTING_ERROR, onConnectingError);\n                _this2.once(Client.Event.CONNECTED, onConnected);\n                _this2.once(Client.Event.DISCONNECTED, onDisconnected);\n            });\n        }\n\n        /**\n         * Gracefully closes the connection. This method can throw `Client.ErrorCode.WEBSOCKET_ERROR` if\n         * provided parameters are invalid. If websocket is not closed after `options.disconnectTimeout` ms,\n         * the client will start the disconnection procedure forcefully.\n         *\n         * @param {number=} code A numeric value indicating the status code explaining why the connection is being closed.\n         *      Must be between 1000-4999. Default is 1000.\n         * @param {any=} reason A human-readable string explaining why the connection is closing. This string must\n         *      be no longer than 123 bytes of UTF-8 text (not characters).\n         * @param {boolean=} opt_retry Whether retry to connect after disconnection.\n         * @returns {boolean}\n         * @example\n         * client.disconnect();\n         *\n         * client.on(Client.Event.DISCONNECTED, (e) => {\n         *   console.log('Disconnected', e.code, e.reason);\n         * });\n         */\n\n    }, {\n        key: 'disconnect',\n        value: function disconnect(code, reason, opt_retry) {\n            var _this3 = this;\n\n            switch (this.state) {\n                case Client.State.CONNECTING:\n                case Client.State.HANDSHAKING:\n                case Client.State.CONNECTED:\n                    debug('Disconnecting... (State: ' + this.state + ')');\n\n                    try {\n                        this.ws_.close(code || 1000, reason); // Can throw INVALID_ACCESS_ERR, SYNTAX_ERR\n                        debug('Websocket is closed');\n                        this.reconnectState_.disabled = !opt_retry;\n                        this.rejectAllDeferreds_(new LineError(Client.ErrorCode.DISCONNECTED, 'Disconnect procedure started'));\n                        this.autoPing_.cancel();\n\n                        // Wait \"close\" event for some time, then manually start onClose procedure\n                        if (this.disconnectTimeout_) clearTimeout(this.disconnectTimeout_);\n                        if (this.options.disconnectTimeout) {\n                            this.disconnectTimeout_ = setTimeout(function () {\n                                debug('Disconnect timeout exceeded, force disconnecting...');\n\n                                _this3.emit(Client.Event.ERROR, new LineError(Client.ErrorCode.DISCONNECT_TIMEOUT, 'Disconnect timeout exceeded, force disconnecting...'));\n\n                                _this3.onClose_(CloseStatus.DISCONNECT_TIMEOUT);\n\n                                clearTimeout(_this3.disconnectTimeout_);\n                            }, this.options.disconnectTimeout);\n                        }\n\n                        this.state = Client.State.DISCONNECTING;\n                        this.emit(Client.Event.DISCONNECTING);\n\n                        return true;\n                    } catch (err) {\n                        throw new LineError(Client.ErrorCode.WEBSOCKET_ERROR, 'Could not disconnect. Invalid code or reason, check payload.', err);\n                    }\n\n                default:\n                    debug('Ignoring disconnect() call, client is in \"' + this.state + '\" state.');\n                    return false;\n            }\n        }\n\n        /**\n         * TODO: This is an experimental method currently, it's just used in tests.\n         * DO NOT use in production.\n         *\n         * @returns {Promise}\n         * @ignore\n         */\n\n    }, {\n        key: 'disconnectAsync',\n        value: function disconnectAsync(code, reason, retry) {\n            var _this4 = this;\n\n            return new Promise(function (resolve, reject) {\n                _this4.disconnect(code, reason, retry); // Can throw WEBSOCKET_ERROR or ignore silently\n\n                var onDisconnected = function onDisconnected(e) {\n                    // this.removeListener(Client.Event.DISCONNECTED, onDisconnected);\n                    resolve(e);\n                };\n\n                _this4.once(Client.Event.DISCONNECTED, onDisconnected);\n            });\n        }\n\n        /**\n         * Binds websocket events\n         *\n         * @ignore\n         */\n\n    }, {\n        key: 'bindEvents_',\n        value: function bindEvents_() {\n            debug('Binding native event handlers.');\n            this.ws_.onopen = this.onOpen_.bind(this);\n            this.ws_.onclose = this.onClose_.bind(this);\n            this.ws_.onerror = this.onError_.bind(this);\n            this.ws_.onmessage = this.onMessage_.bind(this);\n        }\n\n        /**\n         * Unbinds websocket events\n         *\n         * @ignore\n         */\n\n    }, {\n        key: 'unBindEvents_',\n        value: function unBindEvents_() {\n            if (!this.ws_) return;\n            debug('Unbinding native event handlers.');\n            this.ws_.onopen = function () {};\n            this.ws_.onclose = function () {};\n            this.ws_.onerror = function () {};\n            this.ws_.onmessage = function () {};\n        }\n\n        /**\n         * Native \"open\" event handler. At this time we will start the handshakin process.\n         *\n         * @ignore\n         */\n\n    }, {\n        key: 'onOpen_',\n        value: function onOpen_() {\n            var _this5 = this;\n\n            debug('Native \"open\" event received, starting handshake process');\n\n            this.state = Client.State.HANDSHAKING;\n            var message = new Message({\n                name: Message.Name.HANDSHAKE,\n                payload: this.options.handshake.payload // We're sure that this is json friendly\n            });\n\n            this.send_(message, this.options.handshake.timeout).then(function (data) {\n                // Message is sent and we got the response!\n                if (!isObject(data)) {\n                    debug('Unexpected handshake response!?');\n\n                    _this5.emit(Client.Event.CONNECTING_ERROR, new LineError(Client.ErrorCode.HANDSHAKE_ERROR, 'Handshake response is not object. Aborting handshake...', data));\n\n                    _this5.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Handshake failed, unexpected handshake response.', true);\n                    return;\n                }\n\n                debug('Handshake successful.');\n                _this5.resetReconnectState_();\n                _this5.id = data.id;\n                _this5.state = Client.State.CONNECTED;\n                _this5.autoPing_(); // Start auto-ping\n\n                debug('Emitting \"connected\" event...');\n                _this5.emit(Client.Event.CONNECTED, data.payload);\n            }).catch(function (err) {\n                if (err instanceof LineError) {\n                    switch (err.code) {\n                        case Client.ErrorCode.DISCONNECTED:\n                            debug('Handshake failed, connection lost (disconnected)');\n                            _this5.emit(Client.Event.CONNECTING_ERROR, new LineError(Client.ErrorCode.HANDSHAKE_ERROR, 'Connection lost during handshake.'));\n                            return;\n\n                        case Client.ErrorCode.MESSAGE_TIMEOUT:\n                            // TODO: Try again maybe?\n                            debug('Handshake failed, message timeout');\n                            _this5.emit(Client.Event.CONNECTING_ERROR, new LineError(Client.ErrorCode.HANDSHAKE_ERROR, 'Handshake failed, request timeout.'));\n                            return _this5.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Handshake failed, request timeout.', true);\n\n                        case Client.ErrorCode.MESSAGE_REJECTED:\n                            debug('Handshake REJECTED!');\n                            _this5.emit(Client.Event.CONNECTING_ERROR, new LineError(Client.ErrorCode.HANDSHAKE_REJECTED, 'Handshake rejected, check payload for further details.', err && err.payload));\n                            return _this5.disconnect(CloseStatus.HANDSHAKE_REJECTED.code, 'Handshake rejected', true);\n\n                        case Client.ErrorCode.WEBSOCKET_ERROR:\n                            debug('Handshake failed, native websocket error');\n                            _this5.emit(Client.Event.CONNECTING_ERROR, new LineError(Client.ErrorCode.HANDSHAKE_ERROR, 'Handshake failed. Websocket protocol error, check payload.', err && err.payload));\n                            return _this5.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Handshake failed, native websocket error', true);\n\n                        default:\n                            debug('Handshake failed, unknown line error', err);\n                            return _this5.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Unknown line error', true);\n                    }\n                }\n\n                // Unknown error\n                debug('Handshake failed, unknown error', err);\n                return _this5.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Unknown error', true);\n            });\n        }\n\n        /**\n         * Native \"close\" event handler.\n         *\n         * @param {Event} closeEvent Native close event.\n         * @param {number} closeEvent.code Close status code sent by server.\n         * @param {string=} closeEvent.reason Human readable close reason.\n         * @ignore\n         */\n\n    }, {\n        key: 'onClose_',\n        value: function onClose_(closeEvent) {\n            var _this6 = this;\n\n            debug('Native \"close\" event received in \"' + this.state + '\" state (code: ' + closeEvent.code + ', reason: ' + closeEvent.reason + ')');\n\n            if (this.disconnectTimeout_) clearTimeout(this.disconnectTimeout_);\n            this.rejectAllDeferreds_(new LineError(Client.ErrorCode.DISCONNECTED, 'Client is disconnected'));\n            this.unBindEvents_();\n            this.autoPing_.cancel();\n\n            this.id = null;\n            this.ws_ = null;\n\n            debug('Emitting \"disconnected\" event...');\n            this.state = Client.State.DISCONNECTED;\n            this.emit(Client.Event.DISCONNECTED, closeEvent);\n\n            if (this.options.reconnect && !this.reconnectState_.disabled) {\n                var timeout = this.options.reconnectOptions.initialDelay * Math.max(this.options.reconnectOptions.multiply * this.reconnectState_.attempt, 1);\n                timeout = Math.min(timeout, this.options.reconnectOptions.maxDelay);\n                timeout += Math.round(Math.random() * this.options.reconnectOptions.randomness * timeout);\n\n                debug('Will try to reconnect in ' + timeout + ' ms');\n\n                this.reconnectState_.timeout && clearTimeout(this.reconnectState_.timeout);\n                this.reconnectState_.timeout = setTimeout(function () {\n                    _this6.reconnectState_.attempt++;\n                    _this6.connect();\n                }, timeout);\n            }\n        }\n\n        /**\n         * Native \"error\" handler. A \"close\" event will ALWAYS follow this event.\n         * See: https://www.w3.org/TR/websockets/#closeWebSocket\n         * So, if client state is connecting/handshaking, emit `CONNECTING_ERROR`.\n         *\n         * @param {Error} err Native error object.\n         * @ignore\n         */\n\n    }, {\n        key: 'onError_',\n        value: function onError_(err) {\n            debug('Native \"error\" event received in \"' + this.state + '\" state.');\n            var eventName = Client.Event.ERROR;\n\n            if (this.state == Client.State.CONNECTING || this.state == Client.State.HANDSHAKING) {\n                eventName = Client.Event.CONNECTING_ERROR;\n            }\n\n            this.emit(eventName, new LineError(Client.ErrorCode.WEBSOCKET_ERROR, 'Native websocket error occured, check payload.', err));\n        }\n\n        /**\n         * Native \"message\" handler.\n         *\n         * @param {Event} e Native message event.\n         * @param {string} e.data Raw message data.\n         * @ignore\n         */\n\n    }, {\n        key: 'onMessage_',\n        value: function onMessage_(e) {\n            debug('Native \"message\" event received in \"' + this.state + '\" state.');\n            var message = void 0;\n\n            // A message is recieved, debounce our auto-ping handler\n            if (this.state == Client.State.CONNECTED) {\n                this.autoPing_();\n            }\n\n            /**\n             * Try to parse incoming message\n             */\n            try {\n                message = Message.parse(e.data);\n            } catch (err) {\n                debug('Could not parse message', e.data);\n                this.emit(Client.Event.ERROR, new LineError(Client.ErrorCode.INVALID_JSON, 'Could not parse incoming message, invalid json. Check payload for incoming data.', e.data));\n                return;\n            }\n\n            /**\n             * Route the incoming message\n             */\n            if (message.name == Message.Name.PING) {\n                // Ping message arrived\n                this.onPingMessage_(message);\n            } else if (message.name == Message.Name.RESPONSE) {\n                // Response message arrive\n                this.onResponseMessage_(message);\n            } else if (Message.ReservedNames.indexOf(message.name) == -1) {\n                // If message name is not reserved\n                if (!message.id) {\n                    // A message arrived without response\n                    this.onMessageWithoutResponse_(message);\n                } else {\n                    // A message arrived awaiting its response\n                    this.onMessageWithResponse_(message);\n                }\n            } else {\n                debug('Could not route the message', message);\n            }\n        }\n\n        /**\n         * On \"ping\" message handler. Respond with \"pong\".\n         *\n         * @param {Message} message\n         * @ignore\n         */\n\n    }, {\n        key: 'onPingMessage_',\n        value: function onPingMessage_(message) {\n            debug('Ping received, responding \"pong\"...');\n\n            this.sendWithoutResponse_(message.createResponse(null, 'pong')).catch(function (err) {\n                return debug('Ping response failed to send back, ignoring for now...', err);\n            });\n        }\n\n        /**\n         * A response is arrived, find the related deferred and finalize it.\n         *\n         * @param {Message} message\n         * @ignore\n         */\n\n    }, {\n        key: 'onResponseMessage_',\n        value: function onResponseMessage_(message) {\n            var deferred = this.deferreds_[message.id];\n\n            if (!deferred) return debug('Unknown message response, ignoring... (name=\"' + message.name + '\" id=\"' + message.id + '\")');\n\n            debug('Message response arrived: name=\"' + message.name + '\" id=\"' + message.id + '\"');\n\n            if (message.err) {\n                // Server rejects the message\n                deferred.reject(new LineError(Client.ErrorCode.MESSAGE_REJECTED, 'Message is rejected by server, check payload.', message.err));\n            } else {\n                // Server resolves the message\n                deferred.resolve(message.payload);\n            }\n\n            delete this.deferreds_[message.id];\n        }\n\n        /**\n         * A message is arrived without awaiting a response.\n         *\n         * @param {Message} message\n         * @ignore\n         */\n\n    }, {\n        key: 'onMessageWithoutResponse_',\n        value: function onMessageWithoutResponse_(message) {\n            debug('Message without response: name=\"' + message.name + '\"');\n            this.emit(message.name, message);\n        }\n\n        /**\n         * A message is arrived and server is waiting for a response.\n         *\n         * @param {Message} message\n         * @ignore\n         */\n\n    }, {\n        key: 'onMessageWithResponse_',\n        value: function onMessageWithResponse_(message) {\n            var _this7 = this;\n\n            debug('Message with response: name=\"' + message.name + '\" id=\"' + message.id + '\"');\n\n            message.once('resolved', function (payload) {\n                debug('Client resolving: name=\"' + message.name + '\" id=\"' + message.id + '\"');\n\n                // Try to send our response back to server, if not emit an error\n                _this7.sendWithoutResponse_(message.createResponse(null, payload)).catch(function (err) {\n                    _this7.emit(Client.Event.ERROR, new LineError(Client.ErrorCode.MESSAGE_NOT_RESPONDED, 'Message (name=\"' + message.name + '\" id=\"' + message.id + '\") could not responded (resolve)', err));\n                }).then(function () {\n                    return message.dispose();\n                });\n            });\n\n            message.once('rejected', function (err) {\n                debug('Client rejecting: name=\"' + message.name + '\" id=\"' + message.id + '\"');\n\n                // Try to send our response back to server, if not emit an error\n                _this7.sendWithoutResponse_(message.createResponse(err)).catch(function (err) {\n                    _this7.emit(Client.Event.ERROR, new LineError(Client.ErrorCode.MESSAGE_NOT_RESPONDED, 'Message (name=\"' + message.name + '\" id=\"' + message.id + '\") could not responded (reject)', err));\n                }).then(function () {\n                    return message.dispose();\n                });\n            });\n\n            this.emit(message.name, message);\n        }\n\n        /**\n         * Sends a message to server with awaiting its response. This method returns a promise\n         * which resolves the payload parameter will be passed into `message.resolve(...)` in server-side.\n         *\n         * If server rejects the message with `message.reject(...)`, this promise will be rejected with\n         * `Client.ErrorCode.MESSAGE_REJECTED`. You can access the original error object with `err.payload`.\n         *\n         * Rejections:\n         * - `Client.ErrorCode.INVALID_JSON`: Could not stringify the message payload. Probably circular json.\n         * - `Client.ErrorCode.MESSAGE_REJECTED`: Message is explicitly rejected by the server.\n         * - `Client.ErrorCode.MESSAGE_TIMEOUT`: Message response did not arrived, timeout exceeded.\n         * - `Client.ErrorCode.DISCONNECTED`: Client is not connected or connection is closing\n         * - `Client.ErrorCode.WEBSOCKET_ERROR`: Native websocket error (INVALID_STATE_ERR or SYNTAX_ERR)\n         *\n         * @param {string} name Message name.\n         * @param {any=} payload Optional message payload.\n         * @param {number=} timeout Timeout duration for waiting the response. If this parameter\n         *      is not provided, `options.responseTimeout` will be used.\n         * @returns {Promise}\n         * @example\n         * client\n         *   .send('hello', {some: 'payload'})\n         *   .then((data) => {\n         *     console.log('Sent and got the response', data);\n         *   })\n         *   .catch((err) => {\n         *     if (err.code == Client.ErrorCode.MESSAGE_REJECTED) {\n         *       console.log('Message rejected by server', err.payload);\n         *     } else if (err.code == Client.ErrorCode.MESSAGE_TIMEOUT) {\n         *       console.log('Server did not responded, timeout exceeded');\n         *     } else {\n         *       console.log('Could not send message', err);\n         *     }\n         *   });\n         */\n\n    }, {\n        key: 'send',\n        value: function send(name, payload, opt_timeout) {\n            // This method is for external usage!\n            if (this.state != Client.State.CONNECTED) {\n                return Promise.reject(new LineError(Client.ErrorCode.DISCONNECTED, 'Could not send message, client is not connected.'));\n            }\n\n            try {\n                var message = new Message({ name: name, payload: payload });\n                return this.send_(message, opt_timeout);\n            } catch (err) {\n                // `err` can only be Message.ErrorCode.INVALID_JSON\n                return Promise.reject(new LineError(Client.ErrorCode.INVALID_JSON, 'Could not send message, \"payload\" stringify error. Probably circular json issue.'));\n            }\n        }\n\n        /**\n         * Sends a message to server without waiting its response. This method returns a promise\n         * that resolves with nothing if the message is successfully sent.\n         *\n         * Rejections:\n         * - `Client.ErrorCode.INVALID_JSON`: Could not stringify the message payload. Probably circular json.\n         * - `Client.ErrorCode.DISCONNECTED`: Client is not connected or connection is closing\n         * - `Client.ErrorCode.WEBSOCKET_ERROR`: Native websocket error (INVALID_STATE_ERR or SYNTAX_ERR)\n         *\n         * @param {string} name\n         * @param {any=} payload\n         * @returns {Promise}\n         * @example\n         * client\n         *   .sendWithoutResponse('hello', {some: data})\n         *   .then(() => {\n         *     console.log('Message is sent');\n         *   })\n         *   .catch((err) => {\n         *     console.log('Could not send message');\n         *   });\n         */\n\n    }, {\n        key: 'sendWithoutResponse',\n        value: function sendWithoutResponse(name, payload) {\n            // This method is for external usage!\n            if (this.state != Client.State.CONNECTED) {\n                return Promise.reject(new LineError(Client.ErrorCode.DISCONNECTED, 'Could not send message, client is not connected.'));\n            }\n\n            try {\n                var message = new Message({ name: name, payload: payload }); // Can throw Message.ErrorCode.INVALID_JSON\n                return this.sendWithoutResponse_(message);\n            } catch (err) {\n                // `err` can only be Message.ErrorCode.INVALID_JSON\n                return Promise.reject(new LineError(Client.ErrorCode.INVALID_JSON, 'Could not send message, \"payload\" stringify error. Probably circular json issue.'));\n            }\n        }\n\n        /**\n         * Base method for sending a message with timeout. Please favor this method internally\n         * instead of using `send` method.\n         *\n         * Rejections:\n         * - `Client.ErrorCode.MESSAGE_REJECTED`: Message is explicitly rejected by the server.\n         * - `Client.ErrorCode.MESSAGE_TIMEOUT`: Message response did not arrived, timeout exceeded.\n         * - `Client.ErrorCode.DISCONNECTED`: Client is not connected or connection is closing\n         * - `Client.ErrorCode.WEBSOCKET_ERROR`: Native websocket error (INVALID_STATE_ERR or SYNTAX_ERR)\n         *\n         * @param {Message} message\n         * @param {number=} opt_timeout\n         * @returns {Promise}\n         * @ignore\n         */\n\n    }, {\n        key: 'send_',\n        value: function send_(message, opt_timeout) {\n            var _this8 = this;\n\n            var timeout = isInteger(opt_timeout) && opt_timeout >= 0 ? opt_timeout : this.options.responseTimeout;\n            message.setId();\n\n            var deferred = this.deferreds_[message.id] = new Deferred({\n                onExpire: function onExpire() {\n                    delete _this8.deferreds_[message.id];\n                },\n                timeout: timeout\n            });\n\n            return this.sendWithoutResponse_(message).then(function () {\n                return deferred;\n            }).catch(function (err) {\n                deferred.dispose();\n\n                // Convert expired -> timeout error\n                if (err instanceof LineError && err.code == Deferred.ErrorCode.EXPIRED) {\n                    throw new LineError(Client.ErrorCode.MESSAGE_TIMEOUT, 'Message timeout! Its response did not recived after ' + timeout + ' ms');\n                }\n\n                throw err;\n            });\n        }\n\n        /**\n         * Base method for sending a message without response. Please favor this method internally\n         * instead of using `sendWithoutResponse` method.\n         *\n         * Rejections:\n         * - `Client.ErrorCode.DISCONNECTED`: Client is not connected or connection is closing\n         * - `Client.ErrorCode.WEBSOCKET_ERROR`: Native websocket error (INVALID_STATE_ERR or SYNTAX_ERR)\n         *\n         * @param {Message} message\n         * @returns {Promise}\n         * @ignore\n         */\n\n    }, {\n        key: 'sendWithoutResponse_',\n        value: function sendWithoutResponse_(message) {\n            var _this9 = this;\n\n            if (!this.ws_ || this.ws_.readyState != 1) {\n                return Promise.reject(new LineError(Client.ErrorCode.DISCONNECTED, 'Could not send message, there is no open connection.'));\n            }\n\n            return new Promise(function (resolve, reject) {\n                var messageStr = message.toString();\n\n                try {\n                    debug('Sending message: ' + messageStr);\n                    _this9.ws_.send(messageStr); // Can throw INVALID_STATE_ERR, SYNTAX_ERR\n                    resolve();\n                } catch (err) {\n                    reject(new LineError(Client.ErrorCode.WEBSOCKET_ERROR, 'Could not send message. Either socket is not connected or syntax error, check payload.', err));\n                }\n            });\n        }\n\n        /**\n         * Sends a ping message to server, if it's failed, the connection\n         * will be closed and will retry to connect again. Server and client ping each\n         * other automatically with an interval.\n         *\n         * @returns {Promise}\n         */\n\n    }, {\n        key: 'ping',\n        value: function ping() {\n            var _this10 = this;\n\n            var currentSocket = this.ws_;\n\n            debug('Pinging...');\n            return this.send_(new Message({ name: Message.Name.PING })).catch(function (err) {\n                // If socket is changed, dismiss\n                if (_this10.ws_ != currentSocket) {\n                    debug('Auto-ping failed, but socket is also changed, dismissing...');\n                    return;\n                }\n\n                // No matter what error is, start disconnection process\n                debug('Auto-ping failed, manually disconnecting...');\n                _this10.disconnect(CloseStatus.PING_FAILED.code, 'Auto ping failed', true);\n                throw new LineError(Client.ErrorCode.PING_ERROR, 'Ping failed, disconnecting...', err);\n            });\n        }\n\n        /**\n         * On uptime tick event handler. Check current state and push a marker to buffer.\n         *\n         * @ignore\n         */\n\n    }, {\n        key: 'uptimeTick_',\n        value: function uptimeTick_() {\n            debug('Uptime Tick');\n            this.uptimeBuffer_.push(this.state == Client.State.CONNECTED);\n\n            if (this.uptimeBuffer_.length > this.uptimeBufferLength_) {\n                this.uptimeBuffer_.splice(0, this.uptimeBufferLength_ - this.uptimeBuffer_.length);\n            }\n        }\n\n        /**\n         * Calculates (connection) uptime for last `options.uptime.window` (default 5 minutes)\n         * with `options.uptime.interval` (default 5 seconds) interval. Returns a number between\n         * 0 and 1. If `options.uptime` is false, this method returns nothing.\n         *\n         * @returns {number?}\n         */\n\n    }, {\n        key: 'getUptime',\n        value: function getUptime() {\n            if (!this.options.uptime) return;\n            if (this.uptimeBuffer_.length == 0) return 0;\n            return this.uptimeBuffer_.filter(function (val) {\n                return val;\n            }).length / this.uptimeBuffer_.length;\n        }\n\n        /**\n         * Disposes the client.\n         *\n         * @returns {Promise}\n         */\n\n    }, {\n        key: 'dispose',\n        value: function dispose() {\n            var _this11 = this;\n\n            return new Promise(function (resolve) {\n                debug('Disposing...');\n\n                switch (_this11.state) {\n                    case Client.State.CONNECTING:\n                    case Client.State.HANDSHAKING:\n                    case Client.State.CONNECTED:\n                        _this11.once(Client.Event.DISCONNECTED, function () {\n                            _this11.removeAllListeners();\n                            _this11.uptimeBuffer_ = [];\n                            if (_this11.uptimeInterval_) clearInterval(_this11.uptimeInterval_);\n                            debug('Disposed!');\n                            resolve();\n                        });\n\n                        _this11.disconnect(CloseStatus.DISPOSED.code, CloseStatus.DISPOSED.reason);\n                        break;\n\n                    case Client.State.READY:\n                    case Client.State.DISCONNECTING:\n                    case Client.State.DISCONNECTED:\n                        _this11.resetReconnectState_();\n                        _this11.removeAllListeners();\n                        _this11.uptimeBuffer_ = [];\n                        if (_this11.uptimeInterval_) clearInterval(_this11.uptimeInterval_);\n                        debug('Disposed!');\n                        resolve();\n                        break;\n                }\n            });\n        }\n\n        /**\n         * Reject all the awaiting deferred with given error.\n         *\n         * @param {Error} err An error object to reject all awaiting deferreds.\n         * @ignore\n         */\n\n    }, {\n        key: 'rejectAllDeferreds_',\n        value: function rejectAllDeferreds_(err) {\n            forEach(this.deferreds_, function (deferred) {\n                return deferred.reject(err);\n            });\n            this.deferreds_ = {};\n        }\n\n        /**\n         * Resets the reconnection state.\n         *\n         * @ignore\n         */\n\n    }, {\n        key: 'resetReconnectState_',\n        value: function resetReconnectState_() {\n            debug('Resetting reconnection state...');\n            if (this.reconnectState_.timeout) clearTimeout(this.reconnectState_.timeout);\n            this.reconnectState_ = { disabled: false, attempt: 0, timeout: null };\n        }\n    }]);\n\n    return Client;\n}(EventEmitterExtra);\n\n// Expose internal classes\n\n\nClient.Message = Message;\nClient.Error = LineError;\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nClient.ErrorCode = {\n    /**\n     * When constructing `new Client()`, this error could be thrown.\n     */\n    INVALID_OPTIONS: 'cInvalidOptions',\n    /**\n     * Indicates an error while json parsing/stringify.\n     */\n    INVALID_JSON: 'cInvalidJSON',\n    /**\n     * This error can be emitted in `Client.Events.CONNECTING_ERROR` event.\n     * It indicates an operational error during the handshake. If `options.reconnect` is true,\n     * the client will try to reconnect again.\n     */\n    HANDSHAKE_ERROR: 'cHandshakeError',\n    /**\n     * This error can be emitted in `Client.Events.CONNECTING_ERROR` event.\n     * It indicates that server is explicitly rejected the handshake, which probably means\n     * client's handshake payload is not accepted by server.\n     */\n    HANDSHAKE_REJECTED: 'cHandshakeRejected',\n    /**\n     * This error can be seen in rejection of `client.send()` method. This means the\n     * message is reached to server but the timeout is exceeded.\n     */\n    MESSAGE_TIMEOUT: 'cMessageTimeout',\n    /**\n     * This error can be seen in rejection of `client.send()` method, which again indicates that\n     * server is explicitly rejected the message.\n     */\n    MESSAGE_REJECTED: 'cMessageRejected',\n    /**\n     * When the response of a message failed to send to server, this error\n     * will be emitted in `Client.Event.ERROR` event.\n     */\n    MESSAGE_NOT_RESPONDED: 'cMessageNotResponded',\n    /**\n     * This error is for native websocket errors. Native error is wrapped by `LineError`\n     * and can be accessible under `err.payload`.\n     */\n    WEBSOCKET_ERROR: 'cWebsocketError',\n    /**\n     * When disconnect timeout is exceed, this error will be emited in\n     * `Client.Events.ERROR` event. After this event, the disconnect\n     * procedure will be started forcefully.\n     */\n    DISCONNECT_TIMEOUT: 'cDisconnectError',\n    /**\n     * This error can be seen in rejection of `client.ping()` method. After this error,\n     * client will be disconnected.\n     */\n    PING_ERROR: 'cPingError',\n    /**\n     * This error indicates the action is prohibited because client is not\n     * in connected state or connection is closing.\n     */\n    DISCONNECTED: 'cDisconnected'\n};\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nClient.State = {\n    /**\n     * `ready`\n     */\n    READY: 'ready',\n    /**\n     * `connecting`\n     */\n    CONNECTING: 'connecting',\n    /**\n     * `handshaking`\n     */\n    HANDSHAKING: 'handshaking',\n    /**\n     * `connected`\n     */\n    CONNECTED: 'connected',\n    /**\n     * `disconnecting`\n     */\n    DISCONNECTING: 'disconnecting',\n    /**\n     * `disconnected`\n     */\n    DISCONNECTED: 'disconnected'\n};\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nClient.Event = {\n    /**\n     * `_connecting`\n     */\n    CONNECTING: '_connecting',\n    /**\n     * `_connecting_error`\n     */\n    CONNECTING_ERROR: '_connecting_error',\n    /**\n     * `_connected`\n     */\n    CONNECTED: '_connected',\n    /**\n     * `_disconnecting`\n     */\n    DISCONNECTING: '_disconnecting',\n    /**\n     * `_disconnected`\n     */\n    DISCONNECTED: '_disconnected',\n    /**\n     * `_error`\n     */\n    ERROR: '_error'\n};\n\nmodule.exports = Client;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"ws\");\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\"use strict\";\n'use strict';\n\nmodule.exports = {\n    INTERNAL_ERROR: { code: 4200, reason: 'Internal error' },\n    PING_FAILED: { code: 4201, reason: 'Ping failed' },\n    HANDSHAKE_FAILED: { code: 4202, reason: 'Handshake failed' },\n    HANDSHAKE_REJECTED: { code: 4203, reason: 'Handshake rejected' },\n    DISCONNECT_TIMEOUT: { code: 4204, reason: 'Disconnect timeout' },\n    DISPOSED: { code: 4205, reason: 'Client disposed' },\n    UNKNOWN_ERROR: { code: 4299, reason: 'Unknown error' }\n};\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar LineError = __webpack_require__(0);\n\nvar Deferred = function () {\n    function Deferred() {\n        var _this = this;\n\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n            _ref$handler = _ref.handler,\n            handler = _ref$handler === undefined ? function () {} : _ref$handler,\n            _ref$onExpire = _ref.onExpire,\n            onExpire = _ref$onExpire === undefined ? function () {} : _ref$onExpire,\n            _ref$timeout = _ref.timeout,\n            timeout = _ref$timeout === undefined ? 0 : _ref$timeout;\n\n        _classCallCheck(this, Deferred);\n\n        this.resolve_ = null;\n        this.reject_ = null;\n\n        this.timeout_ = null;\n        this.timeoutDuration_ = timeout;\n        this.onExpire_ = onExpire;\n        this.isFinished_ = false;\n\n        this.promise = new Promise(function (resolve, reject) {\n            _this.resolve_ = resolve;\n            _this.reject_ = reject;\n\n            try {\n                handler(_this);\n            } catch (err) {\n                _this.reject(err);\n            }\n        });\n\n        if (timeout > 0) {\n            this.timeout_ = setTimeout(this.expire.bind(this), timeout);\n        }\n    }\n\n    _createClass(Deferred, [{\n        key: 'resolve',\n        value: function resolve(data) {\n            if (this.isFinished_) return;\n\n            this.isFinished_ = true;\n            this.clearTimeout_();\n            this.resolve_(data);\n        }\n    }, {\n        key: 'reject',\n        value: function reject(err) {\n            if (this.isFinished_) return;\n\n            this.isFinished_ = true;\n            this.clearTimeout_();\n            this.reject_(err);\n        }\n    }, {\n        key: 'expire',\n        value: function expire() {\n            this.isFinished_ = true;\n            this.clearTimeout_();\n            this.onExpire_();\n            this.reject_(new LineError(Deferred.ErrorCode.EXPIRED, 'Timeout ' + this.timeoutDuration_ + ' ms exceed'));\n        }\n    }, {\n        key: 'dispose',\n        value: function dispose() {\n            this.isFinished_ = true;\n            this.clearTimeout_();\n        }\n    }, {\n        key: 'then',\n        value: function then() {\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n            }\n\n            return this.promise.then.apply(this.promise, args);\n        }\n    }, {\n        key: 'catch',\n        value: function _catch() {\n            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                args[_key2] = arguments[_key2];\n            }\n\n            return this.promise.catch.apply(this.promise, args);\n        }\n    }, {\n        key: 'clearTimeout_',\n        value: function clearTimeout_() {\n            if (this.timeout_) {\n                clearTimeout(this.timeout_);\n                this.timeout_ = null;\n            }\n        }\n    }]);\n\n    return Deferred;\n}();\n\nDeferred.ErrorCode = {\n    EXPIRED: 'dExpired'\n};\n\nmodule.exports = Deferred;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar isUndefined = __webpack_require__(19);\nvar isString = __webpack_require__(4);\nvar isObject = __webpack_require__(3);\nvar isFunction = __webpack_require__(16);\nvar values = __webpack_require__(20);\nvar assign = __webpack_require__(1);\n\nvar _require = __webpack_require__(10),\n    generateDummyId = _require.generateDummyId;\n\nvar EventEmitterExtra = __webpack_require__(2);\nvar LineError = __webpack_require__(0);\n\n/**\n * Message class.\n *\n * @private\n * @class Message\n * @extends {EventEmitterExtra}\n */\n\nvar Message = function (_EventEmitterExtra) {\n    _inherits(Message, _EventEmitterExtra);\n\n    _createClass(Message, null, [{\n        key: 'parse',\n        value: function parse(raw) {\n            try {\n                var data = JSON.parse(raw);\n\n                // If error is error-like object, construct real error\n                if (isObject(data.e) && isString(data.e.name) && isString(data.e.message)) {\n                    data.e = assign(new Error(), data.e);\n                }\n\n                return new Message({\n                    name: data.n,\n                    payload: data.p,\n                    err: data.e,\n                    id: data.i\n                });\n            } catch (err) {\n                throw new LineError(Message.ErrorCode.INVALID_JSON, 'Could not parse incoming message.');\n            }\n        }\n    }]);\n\n    function Message(_ref) {\n        var name = _ref.name,\n            payload = _ref.payload,\n            id = _ref.id,\n            err = _ref.err;\n\n        _classCallCheck(this, Message);\n\n        var _this = _possibleConstructorReturn(this, (Message.__proto__ || Object.getPrototypeOf(Message)).call(this));\n\n        try {\n            JSON.stringify(payload);\n            JSON.stringify(err);\n        } catch (err) {\n            throw new LineError(Message.ErrorCode.INVALID_JSON, 'Message payload or error must be json-friendly. Maybe circular json?');\n        }\n\n        _this.name = name;\n        _this.payload = payload;\n        _this.id = id;\n        _this.err = err;\n\n        _this.isResponded_ = false;\n        return _this;\n    }\n\n    _createClass(Message, [{\n        key: 'setId',\n        value: function setId() {\n            var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : generateDummyId();\n\n            this.id = id;\n            return id;\n        }\n    }, {\n        key: 'createResponse',\n        value: function createResponse(err, payload) {\n            return new Message({ name: '_r', payload: payload, err: err, id: this.id });\n        }\n\n        /**\n         * Resolves the message with sending a response back. If the source\n         * does not expecting a response, you don't need to call these methods.\n         *\n         * This method can throw:\n         * - `Message.ErrorCode.MISSING_ID`: Message source is not expecting a response.\n         * - `Message.ErrorCode.ALREADY_RESPONDED`: This message is already responded.\n         * - `Message.ErrorCode.INVALID_JSON`: Could not stringify payload. Probably circular json.\n         *\n         * @param {any=} payload\n         */\n\n    }, {\n        key: 'resolve',\n        value: function resolve(payload) {\n            if (isUndefined(this.id)) {\n                throw new LineError(Message.ErrorCode.MISSING_ID, 'This message could not be resolved (no id)');\n            }\n\n            if (this.isResponded_) {\n                throw new LineError(Message.ErrorCode.ALREADY_RESPONDED, 'This message has already responded');\n            }\n\n            try {\n                JSON.stringify(payload);\n            } catch (err_) {\n                throw new LineError(Message.ErrorCode.INVALID_JSON, 'Message must be resolved with json-friendly payload. Maybe circular json?');\n            }\n\n            this.isResponded_ = true;\n            this.emit('resolved', payload);\n        }\n\n        /**\n         * Rejects the message, with sending error response back to the source.\n         *\n         * This method can throw:\n         * - `Message.ErrorCode.MISSING_ID`: Message source is not expecting a response.\n         * - `Message.ErrorCode.ALREADY_RESPONDED`: This message is already responded.\n         * - `Message.ErrorCode.INVALID_JSON`: Could not stringify payload. Probably circular json.\n         *\n         * @param {any=} err\n         */\n\n    }, {\n        key: 'reject',\n        value: function reject(err) {\n            if (isUndefined(this.id)) {\n                throw new LineError(Message.ErrorCode.MISSING_ID, 'This message could not be rejected (no id)');\n            }\n\n            if (this.isResponded_) {\n                throw new LineError(Message.ErrorCode.ALREADY_RESPONDED, 'This message has already responded');\n            }\n\n            try {\n                JSON.stringify(err);\n            } catch (err_) {\n                throw new LineError(Message.ErrorCode.INVALID_JSON, 'Message must be resolved with json-friendly payload. Maybe circular json?');\n            }\n\n            this.isResponded_ = true;\n            this.emit('rejected', err);\n        }\n    }, {\n        key: 'toString',\n        value: function toString() {\n            var data = { n: this.name };\n\n            if (!isUndefined(this.payload)) data.p = this.payload;\n\n            if (!isUndefined(this.id)) data.i = this.id;\n\n            if (!isUndefined(this.err)) {\n                data.e = this.err instanceof Error ? assign({\n                    name: this.err.name,\n                    message: this.err.message\n                }, this.err) : this.err;\n            }\n\n            // We're sure the data is json-friendly\n            return JSON.stringify(data);\n        }\n    }, {\n        key: 'dispose',\n        value: function dispose() {\n            var _this2 = this;\n\n            var events = this.eventNames();\n            events.forEach(function (event) {\n                return _this2.removeAllListeners(event);\n            });\n        }\n    }]);\n\n    return Message;\n}(EventEmitterExtra);\n\n/**\n * These message names are reserved for internal usage.\n * We recommend to not use any message name starts with `_` (underscore).\n *\n * @static\n * @readonly\n * @enum {string}\n */\n\n\nMessage.Name = {\n    /**\n     * `_r`\n     */\n    RESPONSE: '_r',\n    /**\n     * `_h`\n     */\n    HANDSHAKE: '_h',\n    /**\n     * `_p`\n     */\n    PING: '_p'\n};\n\nMessage.ReservedNames = values(Message.Name);\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nMessage.ErrorCode = {\n    /**\n     * `mInvalidJson`\n     */\n    INVALID_JSON: 'mInvalidJson',\n    /**\n     * `mMissingId`\n     */\n    MISSING_ID: 'mMissingId',\n    /**\n     * `mAlreadyResponded`\n     */\n    ALREADY_RESPONDED: 'mAlreadyResponded'\n};\n\nmodule.exports = Message;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\n\nvar assign = __webpack_require__(1);\n\n// http://stackoverflow.com/a/6248722\nfunction generateDummyId() {\n    var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;\n\n    return (\"0000\" + (Math.random() * Math.pow(36, length) << 0).toString(36)).slice(-length);\n}\n\nmodule.exports = { generateDummyId: generateDummyId };\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"debug\");\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/debounce\");\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/defaultsDeep\");\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/forEach\");\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isBoolean\");\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isFunction\");\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isInteger\");\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isNumber\");\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isUndefined\");\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/values\");\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nglobal.WebSocket = __webpack_require__(6); // Polyfill for extending browser code\nmodule.exports = __webpack_require__(5);\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// client-node.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmory imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmory exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tObject.defineProperty(exports, name, {\n \t\t\tconfigurable: false,\n \t\t\tenumerable: true,\n \t\t\tget: getter\n \t\t});\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 21);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 3d41e686ee32dfe42526","function LineError(code, message, payload) {\n    this.name = 'LineError';\n    this.message = message;\n    this.code = code;\n    this.payload = payload;\n    this.stack = (new Error()).stack;\n}\nLineError.prototype = new Error;\n\n\nmodule.exports = LineError;\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/error.js","module.exports = require(\"lodash/assign\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/assign\"\n// module id = 1\n// module chunks = 0","module.exports = require(\"event-emitter-extra\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"event-emitter-extra\"\n// module id = 2\n// module chunks = 0","module.exports = require(\"lodash/isObject\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isObject\"\n// module id = 3\n// module chunks = 0","module.exports = require(\"lodash/isString\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isString\"\n// module id = 4\n// module chunks = 0","const Message = require('../lib/message');\nconst EventEmitterExtra = require('event-emitter-extra');\nconst Deferred = require('../lib/deferred');\nconst assign = require('lodash/assign');\nconst forEach = require('lodash/forEach');\nconst debounce = require('lodash/debounce');\nconst isObject = require('lodash/isObject');\nconst isBoolean = require('lodash/isBoolean');\nconst isString = require('lodash/isString');\nconst isNumber = require('lodash/isNumber');\nconst isInteger = require('lodash/isInteger');\nconst defaultsDeep = require('lodash/defaultsDeep');\nconst debug = require('debug')('line:client');\nconst LineError = require('../lib/error');\nconst CloseStatus = require('../lib/closestatus');\n\n\n\n/**\n * Line client class.\n *\n * @class Client\n * @extends {EventEmitterExtra}\n * @param {string=} url Server url, default: `ws://localhost`.\n * @param {Object=} options Options object.\n * @param {Object=} options.handshake Handshake options\n * @param {number=} options.handshake.timeout Handshake timeout duration in milliseconds.\n *      Default: `30000` (30 seconds).\n * @param {any=} options.handshake.payload Handshake payload that will be send to server.\n * @param {number=} options.responseTimeout This is the timeout for getting response from the server\n *      when using `client.send()` method. Default: `10000` (10 seconds). Note that this option is ineffective for\n *      `client.sendWithoutResponse()` method.\n * @param {number=} options.disconnectTimeout In some browsers, `close` frame is not fired immediately.\n *      This timeout is for starting `close` procedure even if close frame is not arrived. Default: `5000` (5 seconds).\n * @param {number=} options.pingInterval Pinging interval. Default: `20000` (20 seconds).\n * @param {boolean=} options.reconnect Whether try to reconnect server after unexpected disconnection,\n *      default `true`.\n * @param {Object=} options.reconnectOptions Reconnection options.\n * @param {number=} options.reconnectOptions.initialDelay In milliseconds. Default: `1000` (1 second).\n * @param {number=} options.reconnectOptions.multiply Default: `1.5`\n * @param {number=} options.reconnectOptions.maxDelay In milliseconds. Default: `30000`\n * @param {number=} options.reconnectOptions.randomness Random delay multiplier. Default: `0.5`\n * @param {boolean=} options.uptime Whether keep & calculate uptime, default `false`.\n *      If this option is not true, `client.getUptime()` returns undefined.\n * @param {Object=} options.uptimeOptions Uptime options.\n * @param {number=} options.uptimeOptions.interval Uptime checking interval. In milliseconds. Default: `5000` (5 seconds).\n * @param {number=} options.uptimeOptions.window Uptime checking window length. In milliseconds. Default: `300000` (5 minutes)\n * @property {string} url Server url\n * @property {string} id Unique connection id assigned by the server. It will be accessible after handshake.\n * @property {Client.State} state Connection state\n * @example\n * // Add line-client to your html document\n * <script src=\"./node_modules/line-socket/dist/client-web-globals.js\"></script>\n *\n * // For web browsers (consuming as a commonjs module)\n * const LineClient = require('line-socket/client-web');\n *\n * // For node.js\n * const LineClient = require('line-socket/client-node');\n *\n * // Usage\n * const client = new LineClient('ws://localhost:8080');\n * client.connect();\n */\nclass Client extends EventEmitterExtra {\n    constructor(url = 'ws://localhost', options = {}) {\n        super();\n\n        if (!isString(url) || url.trim().length == 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, 'Url parameter must be string and cannot be empty');\n\n        if (!isObject(options))\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, 'Options parameter must be an object');\n\n        this.url = url.trim();\n        this.options = defaultsDeep(options, {\n            handshake: {\n                timeout: 30000,\n                payload: undefined\n            },\n            responseTimeout: 10000,\n            disconnectTimeout: 5000,\n            pingInterval: 20000,\n            reconnect: true,\n            reconnectOptions: {\n                initialDelay: 1000,\n                multiply: 1.5,\n                maxDelay: 30000,\n                randomness: 0.5\n            },\n            uptime: false,\n            uptimeOptions: {\n                interval: 5000,\n                window: 300000\n            }\n        });\n\n\n        if (!isObject(this.options.handshake))\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.handshake\" must be an object`);\n\n        if (!isInteger(this.options.handshake.timeout) || this.options.handshake.timeout < 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.handshake.timeout\" must be a positive integer or zero`);\n\n        try {\n            JSON.stringify(this.options.handshake.payload);\n        } catch (err) {\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.handshake.payload\" must be json friendly, probably circular dependency?`);\n        }\n\n        if (!isInteger(this.options.responseTimeout) || this.options.responseTimeout < 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.responseTimeout\" must be a positive integer or zero`);\n\n        if (!isInteger(this.options.disconnectTimeout) || this.options.disconnectTimeout < 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.disconnectTimeout\" must be a positive integer or zero`);\n\n        if (!isInteger(this.options.pingInterval) || this.options.pingInterval < 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.pingInterval\" must be a positive integer or zero`);\n\n        if (!isBoolean(this.options.reconnect))\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.reconnect\" must be a boolean`);\n\n        if (!isObject(this.options.reconnectOptions))\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.reconnectOptions\" must be an object`);\n\n        if (!isInteger(this.options.reconnectOptions.initialDelay) || this.options.reconnectOptions.initialDelay <= 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.reconnectOptions.initialDelay\" must be a positive integer`);\n\n        if (!isNumber(this.options.reconnectOptions.multiply) || this.options.reconnectOptions.multiply < 1)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.reconnectOptions.multiply\" must be a number >= 1`);\n\n        if (!isInteger(this.options.reconnectOptions.maxDelay) || this.options.reconnectOptions.maxDelay <= 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.reconnectOptions.maxDelay\" must be a positive integer`);\n\n        if (this.options.reconnectOptions.maxDelay < this.options.reconnectOptions.initialDelay)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.reconnectOptions.maxDelay\" must be a greater than initial delay`);\n\n        if (!isNumber(this.options.reconnectOptions.randomness) || this.options.reconnectOptions.randomness < 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.reconnectOptions.randomness\" must be a positive number or zero`);\n\n        if (!isBoolean(this.options.uptime))\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.uptime\" must be a boolean`);\n\n        if (!isObject(this.options.uptimeOptions))\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.uptimeOptions\" must be an object`);\n\n        if (!isInteger(this.options.uptimeOptions.interval) || this.options.uptimeOptions.interval <= 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.uptimeOptions.interval\" must be a positive integer`);\n\n        if (!isInteger(this.options.uptimeOptions.window) || this.options.uptimeOptions.window <= 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.uptimeOptions.window\" must be a positive integer`);\n\n        if (this.options.uptimeOptions.window < this.options.uptimeOptions.interval)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.uptimeOptions.window\" must be a greater than interval`);\n\n        this.ws_ = null;\n        this.id = null;\n        this.state = Client.State.READY;\n\n        this.reconnectState_ = {disabled: false, attempt: 0, timeout: null};\n        this.deferreds_ = {};\n        this.disconnectTimeout_ = null;\n        this.uptimeBuffer_ = [];\n        this.uptimeBufferLength_ = Math.round(this.options.uptimeOptions.window / this.options.uptimeOptions.interval);\n        this.uptimeInterval_ = options.uptime ? setInterval(this.uptimeTick_.bind(this), this.options.uptimeOptions.interval) : null;\n        this.autoPing_ = debounce(() => {});\n\n        if (this.options.pingInterval > 0) {\n            this.autoPing_ = debounce(() => {\n                this\n                    .ping()\n                    .then(() => {\n                        // Ping successfull. If we still connected, debounce next one!\n                        if (this.options.pingInterval > 0 && this.state == Client.State.CONNECTED) {\n                            this.autoPing_(); // Recursive\n                        }\n                    })\n                    .catch(() => { /* ping() method handles disconnection the logic itself */ });\n            }, this.options.pingInterval);\n        }\n    }\n\n\n    /**\n     * Starts the connection procedure.\n     *\n     * If server url is invalid or there is a security error,\n     * this method will throw `Client.ErrorCode.WEBSOCKET_ERROR`.\n     *\n     * When procedure is started, `Client.Event.CONNECTING` event will be emitted.\n     *\n     * If an error occured during connection or handshake, the client will emit `Client.Event.CONNECTING_ERROR`.\n     *\n     * If connection is failed for some reason and `options.reconnect` is `true`. The client will\n     * retry to connect.\n     *\n     * @returns {boolean}\n     * @example\n     * client.connect();\n     *\n     * client.on(Client.Event.CONNECTED, () => {\n     *   console.log('Client connected.');\n     * });\n     *\n     * client.on(Client.Event.CONNECTING_ERROR, (err) => {\n     *   console.log('Could not connect!', err);\n     * });\n     */\n    connect() {\n        switch (this.state) {\n            case Client.State.DISCONNECTED:\n            case Client.State.READY:\n                debug(`Connecting to \"${this.url}\" ...`);\n\n                try {\n                    this.reconnectState_.disabled = false;\n                    this.ws_ = new WebSocket(this.url);\n                    this.bindEvents_();\n                    this.state = Client.State.CONNECTING;\n                    this.emit(Client.Event.CONNECTING);\n                    return true;\n                } catch (err) {\n                    throw new LineError(\n                        Client.ErrorCode.WEBSOCKET_ERROR,\n                        `Native websocket error. Invalid url or security error`,\n                        err\n                    );\n                }\n\n            default:\n                debug(`Ignoring connect() call, client is in \"${this.state}\" state`);\n                return false;\n        }\n    }\n\n\n    /**\n     * TODO: This is an experimental method currently, it's just used in tests.\n     * DO NOT use in production.\n     *\n     * @returns {Promise}\n     * @ignore\n     */\n    connectAsync() {\n        return new Promise((resolve, reject) => {\n            this.connect(); // Can throw WEBSOCKET_ERROR or ignore silently\n\n            let removeListeners = () => {};\n\n            const onConnectingError = (err) => {\n                removeListeners();\n                reject(err);\n            };\n\n            const onConnected = (data) => {\n                removeListeners();\n                resolve(data);\n            };\n\n            const onDisconnected = (e) => {\n                removeListeners();\n                reject(new LineError(Client.ErrorCode.DISCONNECTED, `Client disconnected`, e));\n            };\n\n            removeListeners = () => {\n                this.removeListener(Client.Event.CONNECTING_ERROR, onConnectingError);\n                this.removeListener(Client.Event.CONNECTED, onConnected);\n                this.removeListener(Client.Event.DISCONNECTED, onDisconnected);\n            }\n\n            this.once(Client.Event.CONNECTING_ERROR, onConnectingError);\n            this.once(Client.Event.CONNECTED, onConnected);\n            this.once(Client.Event.DISCONNECTED, onDisconnected);\n        });\n    }\n\n\n    /**\n     * Gracefully closes the connection. This method can throw `Client.ErrorCode.WEBSOCKET_ERROR` if\n     * provided parameters are invalid. If websocket is not closed after `options.disconnectTimeout` ms,\n     * the client will start the disconnection procedure forcefully.\n     *\n     * @param {number=} code A numeric value indicating the status code explaining why the connection is being closed.\n     *      Must be between 1000-4999. Default is 1000.\n     * @param {any=} reason A human-readable string explaining why the connection is closing. This string must\n     *      be no longer than 123 bytes of UTF-8 text (not characters).\n     * @param {boolean=} opt_retry Whether retry to connect after disconnection.\n     * @returns {boolean}\n     * @example\n     * client.disconnect();\n     *\n     * client.on(Client.Event.DISCONNECTED, (e) => {\n     *   console.log('Disconnected', e.code, e.reason);\n     * });\n     */\n    disconnect(code, reason, opt_retry) {\n        switch (this.state) {\n            case Client.State.CONNECTING:\n            case Client.State.HANDSHAKING:\n            case Client.State.CONNECTED:\n                debug(`Disconnecting... (State: ${this.state})`);\n\n                try {\n                    this.ws_.close(code || 1000, reason); // Can throw INVALID_ACCESS_ERR, SYNTAX_ERR\n                    debug(`Websocket is closed`);\n                    this.reconnectState_.disabled = !opt_retry;\n                    this.rejectAllDeferreds_(new LineError(Client.ErrorCode.DISCONNECTED, 'Disconnect procedure started'));\n                    this.autoPing_.cancel();\n\n                    // Wait \"close\" event for some time, then manually start onClose procedure\n                    if (this.disconnectTimeout_) clearTimeout(this.disconnectTimeout_);\n                    if (this.options.disconnectTimeout) {\n                        this.disconnectTimeout_ = setTimeout(() => {\n                            debug(`Disconnect timeout exceeded, force disconnecting...`);\n\n                            this.emit(Client.Event.ERROR, new LineError(\n                                Client.ErrorCode.DISCONNECT_TIMEOUT,\n                                'Disconnect timeout exceeded, force disconnecting...'\n                            ));\n\n                            this.onClose_(CloseStatus.DISCONNECT_TIMEOUT);\n\n                            clearTimeout(this.disconnectTimeout_);\n                        }, this.options.disconnectTimeout);\n                    }\n\n                    this.state = Client.State.DISCONNECTING;\n                    this.emit(Client.Event.DISCONNECTING);\n\n                    return true;\n                } catch (err) {\n                    throw new LineError(\n                        Client.ErrorCode.WEBSOCKET_ERROR,\n                        'Could not disconnect. Invalid code or reason, check payload.',\n                        err\n                    );\n                }\n\n            default:\n                debug(`Ignoring disconnect() call, client is in \"${this.state}\" state.`);\n                return false;\n        }\n    }\n\n\n    /**\n     * TODO: This is an experimental method currently, it's just used in tests.\n     * DO NOT use in production.\n     *\n     * @returns {Promise}\n     * @ignore\n     */\n    disconnectAsync(code, reason, retry) {\n        return new Promise((resolve, reject) => {\n            this.disconnect(code, reason, retry); // Can throw WEBSOCKET_ERROR or ignore silently\n\n            const onDisconnected = (e) => {\n                // this.removeListener(Client.Event.DISCONNECTED, onDisconnected);\n                resolve(e);\n            };\n\n            this.once(Client.Event.DISCONNECTED, onDisconnected);\n        });\n    }\n\n\n    /**\n     * Binds websocket events\n     *\n     * @ignore\n     */\n    bindEvents_() {\n        debug('Binding native event handlers.');\n        this.ws_.onopen = this.onOpen_.bind(this);\n        this.ws_.onclose = this.onClose_.bind(this);\n        this.ws_.onerror = this.onError_.bind(this);\n        this.ws_.onmessage = this.onMessage_.bind(this);\n    }\n\n\n    /**\n     * Unbinds websocket events\n     *\n     * @ignore\n     */\n    unBindEvents_() {\n        if (!this.ws_) return;\n        debug('Unbinding native event handlers.');\n        this.ws_.onopen = function() {};\n        this.ws_.onclose = function() {};\n        this.ws_.onerror = function() {};\n        this.ws_.onmessage = function() {};\n    }\n\n\n    /**\n     * Native \"open\" event handler. At this time we will start the handshakin process.\n     *\n     * @ignore\n     */\n    onOpen_() {\n        debug('Native \"open\" event received, starting handshake process');\n\n        this.state = Client.State.HANDSHAKING;\n        const message = new Message({\n            name: Message.Name.HANDSHAKE,\n            payload: this.options.handshake.payload // We're sure that this is json friendly\n        });\n\n        this\n            .send_(message, this.options.handshake.timeout)\n            .then(data => {\n                // Message is sent and we got the response!\n                if (!isObject(data)) {\n                    debug('Unexpected handshake response!?');\n\n                    this.emit(Client.Event.CONNECTING_ERROR, new LineError(\n                        Client.ErrorCode.HANDSHAKE_ERROR,\n                        'Handshake response is not object. Aborting handshake...',\n                        data\n                    ));\n\n                    this.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Handshake failed, unexpected handshake response.', true);\n                    return;\n                }\n\n                debug('Handshake successful.');\n                this.resetReconnectState_();\n                this.id = data.id;\n                this.state = Client.State.CONNECTED;\n                this.autoPing_(); // Start auto-ping\n\n                debug('Emitting \"connected\" event...');\n                this.emit(Client.Event.CONNECTED, data.payload);\n            })\n            .catch(err => {\n                if (err instanceof LineError) {\n                    switch (err.code) {\n                        case Client.ErrorCode.DISCONNECTED:\n                            debug('Handshake failed, connection lost (disconnected)');\n                            this.emit(Client.Event.CONNECTING_ERROR, new LineError(\n                                Client.ErrorCode.HANDSHAKE_ERROR,\n                                `Connection lost during handshake.`\n                            ));\n                            return;\n\n                        case Client.ErrorCode.MESSAGE_TIMEOUT:\n                            // TODO: Try again maybe?\n                            debug('Handshake failed, message timeout');\n                            this.emit(Client.Event.CONNECTING_ERROR, new LineError(\n                                Client.ErrorCode.HANDSHAKE_ERROR,\n                                'Handshake failed, request timeout.'\n                            ));\n                            return this.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Handshake failed, request timeout.', true);\n\n                        case Client.ErrorCode.MESSAGE_REJECTED:\n                            debug('Handshake REJECTED!');\n                            this.emit(Client.Event.CONNECTING_ERROR, new LineError(\n                                Client.ErrorCode.HANDSHAKE_REJECTED,\n                                'Handshake rejected, check payload for further details.',\n                                err && err.payload\n                            ));\n                            return this.disconnect(CloseStatus.HANDSHAKE_REJECTED.code, 'Handshake rejected', true);\n\n                        case Client.ErrorCode.WEBSOCKET_ERROR:\n                            debug('Handshake failed, native websocket error');\n                            this.emit(Client.Event.CONNECTING_ERROR, new LineError(\n                                Client.ErrorCode.HANDSHAKE_ERROR,\n                                `Handshake failed. Websocket protocol error, check payload.`,\n                                err && err.payload\n                            ));\n                            return this.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Handshake failed, native websocket error', true);\n\n                        default:\n                            debug('Handshake failed, unknown line error', err);\n                            return this.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Unknown line error', true);\n                    }\n                }\n\n                // Unknown error\n                debug('Handshake failed, unknown error', err);\n                return this.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Unknown error', true);\n            });\n    }\n\n\n    /**\n     * Native \"close\" event handler.\n     *\n     * @param {Event} closeEvent Native close event.\n     * @param {number} closeEvent.code Close status code sent by server.\n     * @param {string=} closeEvent.reason Human readable close reason.\n     * @ignore\n     */\n    onClose_(closeEvent) {\n        debug(`Native \"close\" event received in \"${this.state}\" state (code: ${closeEvent.code}, reason: ${closeEvent.reason})`);\n\n        if (this.disconnectTimeout_) clearTimeout(this.disconnectTimeout_);\n        this.rejectAllDeferreds_(new LineError(Client.ErrorCode.DISCONNECTED, 'Client is disconnected'));\n        this.unBindEvents_();\n        this.autoPing_.cancel();\n\n        this.id = null;\n        this.ws_ = null;\n\n        debug('Emitting \"disconnected\" event...');\n        this.state = Client.State.DISCONNECTED;\n        this.emit(Client.Event.DISCONNECTED, closeEvent);\n\n        if (this.options.reconnect && !this.reconnectState_.disabled) {\n            let timeout = this.options.reconnectOptions.initialDelay *\n                Math.max(this.options.reconnectOptions.multiply * this.reconnectState_.attempt, 1);\n            timeout = Math.min(timeout, this.options.reconnectOptions.maxDelay);\n            timeout += Math.round(Math.random() * this.options.reconnectOptions.randomness * timeout);\n\n            debug(`Will try to reconnect in ${timeout} ms`);\n\n            this.reconnectState_.timeout && clearTimeout(this.reconnectState_.timeout);\n            this.reconnectState_.timeout = setTimeout(() => {\n                this.reconnectState_.attempt++;\n                this.connect();\n            }, timeout);\n        }\n    }\n\n\n    /**\n     * Native \"error\" handler. A \"close\" event will ALWAYS follow this event.\n     * See: https://www.w3.org/TR/websockets/#closeWebSocket\n     * So, if client state is connecting/handshaking, emit `CONNECTING_ERROR`.\n     *\n     * @param {Error} err Native error object.\n     * @ignore\n     */\n    onError_(err) {\n        debug(`Native \"error\" event received in \"${this.state}\" state.`);\n        let eventName = Client.Event.ERROR;\n\n        if (this.state == Client.State.CONNECTING || this.state == Client.State.HANDSHAKING) {\n            eventName = Client.Event.CONNECTING_ERROR;\n        }\n\n        this.emit(eventName, new LineError(\n            Client.ErrorCode.WEBSOCKET_ERROR,\n            `Native websocket error occured, check payload.`,\n            err\n        ));\n    }\n\n\n    /**\n     * Native \"message\" handler.\n     *\n     * @param {Event} e Native message event.\n     * @param {string} e.data Raw message data.\n     * @ignore\n     */\n    onMessage_(e) {\n        debug(`Native \"message\" event received in \"${this.state}\" state.`);\n        let message;\n\n        // A message is recieved, debounce our auto-ping handler\n        if (this.state == Client.State.CONNECTED) {\n            this.autoPing_();\n        }\n\n        /**\n         * Try to parse incoming message\n         */\n        try {\n            message = Message.parse(e.data);\n        } catch (err) {\n            debug('Could not parse message', e.data);\n            this.emit(Client.Event.ERROR, new LineError(\n                Client.ErrorCode.INVALID_JSON,\n                'Could not parse incoming message, invalid json. Check payload for incoming data.',\n                e.data\n            ));\n            return;\n        }\n\n        /**\n         * Route the incoming message\n         */\n        if (message.name == Message.Name.PING) { // Ping message arrived\n            this.onPingMessage_(message);\n        } else if (message.name == Message.Name.RESPONSE) { // Response message arrive\n            this.onResponseMessage_(message);\n        } else if (Message.ReservedNames.indexOf(message.name) == -1) { // If message name is not reserved\n            if (!message.id) { // A message arrived without response\n                this.onMessageWithoutResponse_(message);\n            } else { // A message arrived awaiting its response\n                this.onMessageWithResponse_(message);\n            }\n        } else {\n            debug(`Could not route the message`, message);\n        }\n    }\n\n\n    /**\n     * On \"ping\" message handler. Respond with \"pong\".\n     *\n     * @param {Message} message\n     * @ignore\n     */\n    onPingMessage_(message) {\n        debug('Ping received, responding \"pong\"...');\n\n        this\n            .sendWithoutResponse_(message.createResponse(null, 'pong'))\n            .catch(err => debug('Ping response failed to send back, ignoring for now...', err));\n    }\n\n\n    /**\n     * A response is arrived, find the related deferred and finalize it.\n     *\n     * @param {Message} message\n     * @ignore\n     */\n    onResponseMessage_(message) {\n        const deferred = this.deferreds_[message.id];\n\n        if (!deferred)\n            return debug(`Unknown message response, ignoring... (name=\"${message.name}\" id=\"${message.id}\")`);\n\n        debug(`Message response arrived: name=\"${message.name}\" id=\"${message.id}\"`);\n\n        if (message.err) {\n            // Server rejects the message\n            deferred.reject(new LineError(\n                Client.ErrorCode.MESSAGE_REJECTED,\n                'Message is rejected by server, check payload.',\n                message.err\n            ));\n        } else {\n            // Server resolves the message\n            deferred.resolve(message.payload);\n        }\n\n        delete this.deferreds_[message.id];\n    }\n\n\n    /**\n     * A message is arrived without awaiting a response.\n     *\n     * @param {Message} message\n     * @ignore\n     */\n    onMessageWithoutResponse_(message) {\n        debug(`Message without response: name=\"${message.name}\"`);\n        this.emit(message.name, message);\n    }\n\n\n    /**\n     * A message is arrived and server is waiting for a response.\n     *\n     * @param {Message} message\n     * @ignore\n     */\n    onMessageWithResponse_(message) {\n        debug(`Message with response: name=\"${message.name}\" id=\"${message.id}\"`);\n\n        message.once('resolved', (payload) => {\n            debug(`Client resolving: name=\"${message.name}\" id=\"${message.id}\"`);\n\n            // Try to send our response back to server, if not emit an error\n            this\n                .sendWithoutResponse_(message.createResponse(null, payload))\n                .catch((err) => {\n                    this.emit(Client.Event.ERROR, new LineError(\n                        Client.ErrorCode.MESSAGE_NOT_RESPONDED,\n                        `Message (name=\"${message.name}\" id=\"${message.id}\") could not responded (resolve)`,\n                        err\n                    ));\n                })\n                .then(() => message.dispose());\n        });\n\n        message.once('rejected', (err) => {\n            debug(`Client rejecting: name=\"${message.name}\" id=\"${message.id}\"`);\n\n            // Try to send our response back to server, if not emit an error\n            this\n                .sendWithoutResponse_(message.createResponse(err))\n                .catch((err) => {\n                    this.emit(Client.Event.ERROR, new LineError(\n                        Client.ErrorCode.MESSAGE_NOT_RESPONDED,\n                        `Message (name=\"${message.name}\" id=\"${message.id}\") could not responded (reject)`,\n                        err\n                    ));\n                })\n                .then(() => message.dispose());\n        });\n\n        this.emit(message.name, message);\n    }\n\n\n    /**\n     * Sends a message to server with awaiting its response. This method returns a promise\n     * which resolves the payload parameter will be passed into `message.resolve(...)` in server-side.\n     *\n     * If server rejects the message with `message.reject(...)`, this promise will be rejected with\n     * `Client.ErrorCode.MESSAGE_REJECTED`. You can access the original error object with `err.payload`.\n     *\n     * Rejections:\n     * - `Client.ErrorCode.INVALID_JSON`: Could not stringify the message payload. Probably circular json.\n     * - `Client.ErrorCode.MESSAGE_REJECTED`: Message is explicitly rejected by the server.\n     * - `Client.ErrorCode.MESSAGE_TIMEOUT`: Message response did not arrived, timeout exceeded.\n     * - `Client.ErrorCode.DISCONNECTED`: Client is not connected or connection is closing\n     * - `Client.ErrorCode.WEBSOCKET_ERROR`: Native websocket error (INVALID_STATE_ERR or SYNTAX_ERR)\n     *\n     * @param {string} name Message name.\n     * @param {any=} payload Optional message payload.\n     * @param {number=} timeout Timeout duration for waiting the response. If this parameter\n     *      is not provided, `options.responseTimeout` will be used.\n     * @returns {Promise}\n     * @example\n     * client\n     *   .send('hello', {some: 'payload'})\n     *   .then((data) => {\n     *     console.log('Sent and got the response', data);\n     *   })\n     *   .catch((err) => {\n     *     if (err.code == Client.ErrorCode.MESSAGE_REJECTED) {\n     *       console.log('Message rejected by server', err.payload);\n     *     } else if (err.code == Client.ErrorCode.MESSAGE_TIMEOUT) {\n     *       console.log('Server did not responded, timeout exceeded');\n     *     } else {\n     *       console.log('Could not send message', err);\n     *     }\n     *   });\n     */\n    send(name, payload, opt_timeout) { // This method is for external usage!\n        if (this.state != Client.State.CONNECTED) {\n            return Promise.reject(new LineError(\n                Client.ErrorCode.DISCONNECTED,\n                `Could not send message, client is not connected.`\n            ));\n        }\n\n        try {\n            const message = new Message({name, payload});\n            return this.send_(message, opt_timeout);\n        } catch (err) {\n            // `err` can only be Message.ErrorCode.INVALID_JSON\n            return Promise.reject(new LineError(\n                Client.ErrorCode.INVALID_JSON,\n                `Could not send message, \"payload\" stringify error. Probably circular json issue.`\n            ));\n        }\n    }\n\n\n    /**\n     * Sends a message to server without waiting its response. This method returns a promise\n     * that resolves with nothing if the message is successfully sent.\n     *\n     * Rejections:\n     * - `Client.ErrorCode.INVALID_JSON`: Could not stringify the message payload. Probably circular json.\n     * - `Client.ErrorCode.DISCONNECTED`: Client is not connected or connection is closing\n     * - `Client.ErrorCode.WEBSOCKET_ERROR`: Native websocket error (INVALID_STATE_ERR or SYNTAX_ERR)\n     *\n     * @param {string} name\n     * @param {any=} payload\n     * @returns {Promise}\n     * @example\n     * client\n     *   .sendWithoutResponse('hello', {some: data})\n     *   .then(() => {\n     *     console.log('Message is sent');\n     *   })\n     *   .catch((err) => {\n     *     console.log('Could not send message');\n     *   });\n     */\n    sendWithoutResponse(name, payload) { // This method is for external usage!\n        if (this.state != Client.State.CONNECTED) {\n            return Promise.reject(new LineError(\n                Client.ErrorCode.DISCONNECTED,\n                `Could not send message, client is not connected.`\n            ));\n        }\n\n        try {\n            const message = new Message({name, payload}); // Can throw Message.ErrorCode.INVALID_JSON\n            return this.sendWithoutResponse_(message);\n        } catch (err) {\n            // `err` can only be Message.ErrorCode.INVALID_JSON\n            return Promise.reject(new LineError(\n                Client.ErrorCode.INVALID_JSON,\n                `Could not send message, \"payload\" stringify error. Probably circular json issue.`\n            ));\n        }\n    }\n\n\n    /**\n     * Base method for sending a message with timeout. Please favor this method internally\n     * instead of using `send` method.\n     *\n     * Rejections:\n     * - `Client.ErrorCode.MESSAGE_REJECTED`: Message is explicitly rejected by the server.\n     * - `Client.ErrorCode.MESSAGE_TIMEOUT`: Message response did not arrived, timeout exceeded.\n     * - `Client.ErrorCode.DISCONNECTED`: Client is not connected or connection is closing\n     * - `Client.ErrorCode.WEBSOCKET_ERROR`: Native websocket error (INVALID_STATE_ERR or SYNTAX_ERR)\n     *\n     * @param {Message} message\n     * @param {number=} opt_timeout\n     * @returns {Promise}\n     * @ignore\n     */\n    send_(message, opt_timeout) {\n        const timeout = isInteger(opt_timeout) && opt_timeout >= 0 ? opt_timeout : this.options.responseTimeout;\n        message.setId();\n\n        const deferred = this.deferreds_[message.id] = new Deferred({\n            onExpire: () => {\n                delete this.deferreds_[message.id];\n            },\n            timeout: timeout\n        });\n\n        return this\n            .sendWithoutResponse_(message)\n            .then(() => deferred)\n            .catch((err) => {\n                deferred.dispose();\n\n                // Convert expired -> timeout error\n                if (err instanceof LineError && err.code == Deferred.ErrorCode.EXPIRED) {\n                    throw new LineError(\n                        Client.ErrorCode.MESSAGE_TIMEOUT,\n                        `Message timeout! Its response did not recived after ${timeout} ms`\n                    );\n                }\n\n                throw err;\n            });\n    }\n\n\n    /**\n     * Base method for sending a message without response. Please favor this method internally\n     * instead of using `sendWithoutResponse` method.\n     *\n     * Rejections:\n     * - `Client.ErrorCode.DISCONNECTED`: Client is not connected or connection is closing\n     * - `Client.ErrorCode.WEBSOCKET_ERROR`: Native websocket error (INVALID_STATE_ERR or SYNTAX_ERR)\n     *\n     * @param {Message} message\n     * @returns {Promise}\n     * @ignore\n     */\n    sendWithoutResponse_(message) {\n        if (!this.ws_ || this.ws_.readyState != 1) {\n            return Promise.reject(new LineError(\n                Client.ErrorCode.DISCONNECTED,\n                `Could not send message, there is no open connection.`\n            ));\n        }\n\n        return new Promise((resolve, reject) => {\n            const messageStr = message.toString();\n\n            try {\n                debug(`Sending message: ${messageStr}`);\n                this.ws_.send(messageStr); // Can throw INVALID_STATE_ERR, SYNTAX_ERR\n                resolve();\n            } catch (err) {\n                reject(new LineError(\n                    Client.ErrorCode.WEBSOCKET_ERROR,\n                    'Could not send message. Either socket is not connected or syntax error, check payload.',\n                    err\n                ));\n            }\n        });\n    }\n\n\n    /**\n     * Sends a ping message to server, if it's failed, the connection\n     * will be closed and will retry to connect again. Server and client ping each\n     * other automatically with an interval.\n     *\n     * @returns {Promise}\n     */\n    ping() {\n        const currentSocket = this.ws_;\n\n        debug('Pinging...');\n        return this\n            .send_(new Message({name: Message.Name.PING}))\n            .catch(err => {\n                // If socket is changed, dismiss\n                if (this.ws_ != currentSocket) {\n                    debug('Auto-ping failed, but socket is also changed, dismissing...');\n                    return;\n                }\n\n                // No matter what error is, start disconnection process\n                debug('Auto-ping failed, manually disconnecting...');\n                this.disconnect(CloseStatus.PING_FAILED.code, 'Auto ping failed', true);\n                throw new LineError(Client.ErrorCode.PING_ERROR, `Ping failed, disconnecting...`, err);\n            });\n    }\n\n\n    /**\n     * On uptime tick event handler. Check current state and push a marker to buffer.\n     *\n     * @ignore\n     */\n    uptimeTick_() {\n        debug('Uptime Tick');\n        this.uptimeBuffer_.push(this.state == Client.State.CONNECTED);\n\n        if (this.uptimeBuffer_.length > this.uptimeBufferLength_) {\n            this.uptimeBuffer_.splice(0, this.uptimeBufferLength_ - this.uptimeBuffer_.length);\n        }\n    }\n\n\n    /**\n     * Calculates (connection) uptime for last `options.uptime.window` (default 5 minutes)\n     * with `options.uptime.interval` (default 5 seconds) interval. Returns a number between\n     * 0 and 1. If `options.uptime` is false, this method returns nothing.\n     *\n     * @returns {number?}\n     */\n    getUptime() {\n        if (!this.options.uptime) return;\n        if (this.uptimeBuffer_.length == 0) return 0;\n        return this.uptimeBuffer_.filter(val => val).length / this.uptimeBuffer_.length;\n    }\n\n\n    /**\n     * Disposes the client.\n     *\n     * @returns {Promise}\n     */\n    dispose() {\n        return new Promise((resolve) => {\n            debug('Disposing...');\n\n            switch (this.state) {\n                case Client.State.CONNECTING:\n                case Client.State.HANDSHAKING:\n                case Client.State.CONNECTED:\n                    this.once(Client.Event.DISCONNECTED, () => {\n                        this.removeAllListeners();\n                        this.uptimeBuffer_ = [];\n                        if (this.uptimeInterval_) clearInterval(this.uptimeInterval_);\n                        debug('Disposed!');\n                        resolve();\n                    });\n\n                    this.disconnect(CloseStatus.DISPOSED.code, CloseStatus.DISPOSED.reason);\n                    break;\n\n                case Client.State.READY:\n                case Client.State.DISCONNECTING:\n                case Client.State.DISCONNECTED:\n                    this.resetReconnectState_();\n                    this.removeAllListeners();\n                    this.uptimeBuffer_ = [];\n                    if (this.uptimeInterval_) clearInterval(this.uptimeInterval_);\n                    debug('Disposed!');\n                    resolve();\n                    break;\n            }\n        });\n    }\n\n\n    /**\n     * Reject all the awaiting deferred with given error.\n     *\n     * @param {Error} err An error object to reject all awaiting deferreds.\n     * @ignore\n     */\n    rejectAllDeferreds_(err) {\n        forEach(this.deferreds_, deferred => deferred.reject(err));\n        this.deferreds_ = {};\n    }\n\n\n    /**\n     * Resets the reconnection state.\n     *\n     * @ignore\n     */\n    resetReconnectState_() {\n        debug('Resetting reconnection state...');\n        if (this.reconnectState_.timeout) clearTimeout(this.reconnectState_.timeout);\n        this.reconnectState_ = {disabled: false, attempt: 0, timeout: null};\n    }\n}\n\n\n// Expose internal classes\nClient.Message = Message;\nClient.Error = LineError;\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nClient.ErrorCode = {\n    /**\n     * When constructing `new Client()`, this error could be thrown.\n     */\n    INVALID_OPTIONS: 'cInvalidOptions',\n    /**\n     * Indicates an error while json parsing/stringify.\n     */\n    INVALID_JSON: 'cInvalidJSON',\n    /**\n     * This error can be emitted in `Client.Events.CONNECTING_ERROR` event.\n     * It indicates an operational error during the handshake. If `options.reconnect` is true,\n     * the client will try to reconnect again.\n     */\n    HANDSHAKE_ERROR: 'cHandshakeError',\n    /**\n     * This error can be emitted in `Client.Events.CONNECTING_ERROR` event.\n     * It indicates that server is explicitly rejected the handshake, which probably means\n     * client's handshake payload is not accepted by server.\n     */\n    HANDSHAKE_REJECTED: 'cHandshakeRejected',\n    /**\n     * This error can be seen in rejection of `client.send()` method. This means the\n     * message is reached to server but the timeout is exceeded.\n     */\n    MESSAGE_TIMEOUT: 'cMessageTimeout',\n    /**\n     * This error can be seen in rejection of `client.send()` method, which again indicates that\n     * server is explicitly rejected the message.\n     */\n    MESSAGE_REJECTED: 'cMessageRejected',\n    /**\n     * When the response of a message failed to send to server, this error\n     * will be emitted in `Client.Event.ERROR` event.\n     */\n    MESSAGE_NOT_RESPONDED: 'cMessageNotResponded',\n    /**\n     * This error is for native websocket errors. Native error is wrapped by `LineError`\n     * and can be accessible under `err.payload`.\n     */\n    WEBSOCKET_ERROR: 'cWebsocketError',\n    /**\n     * When disconnect timeout is exceed, this error will be emited in\n     * `Client.Events.ERROR` event. After this event, the disconnect\n     * procedure will be started forcefully.\n     */\n    DISCONNECT_TIMEOUT: 'cDisconnectError',\n    /**\n     * This error can be seen in rejection of `client.ping()` method. After this error,\n     * client will be disconnected.\n     */\n    PING_ERROR: 'cPingError',\n    /**\n     * This error indicates the action is prohibited because client is not\n     * in connected state or connection is closing.\n     */\n    DISCONNECTED: 'cDisconnected'\n};\n\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nClient.State = {\n    /**\n     * `ready`\n     */\n    READY: 'ready',\n    /**\n     * `connecting`\n     */\n    CONNECTING: 'connecting',\n    /**\n     * `handshaking`\n     */\n    HANDSHAKING: 'handshaking',\n    /**\n     * `connected`\n     */\n    CONNECTED: 'connected',\n    /**\n     * `disconnecting`\n     */\n    DISCONNECTING: 'disconnecting',\n    /**\n     * `disconnected`\n     */\n    DISCONNECTED: 'disconnected'\n};\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nClient.Event = {\n    /**\n     * `_connecting`\n     */\n    CONNECTING: '_connecting',\n    /**\n     * `_connecting_error`\n     */\n    CONNECTING_ERROR: '_connecting_error',\n    /**\n     * `_connected`\n     */\n    CONNECTED: '_connected',\n    /**\n     * `_disconnecting`\n     */\n    DISCONNECTING: '_disconnecting',\n    /**\n     * `_disconnected`\n     */\n    DISCONNECTED: '_disconnected',\n    /**\n     * `_error`\n     */\n    ERROR: '_error'\n};\n\n\nmodule.exports = Client;\n\n\n\n// WEBPACK FOOTER //\n// ./src/client/client-web.js","module.exports = require(\"ws\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"ws\"\n// module id = 6\n// module chunks = 0","module.exports = {\n    INTERNAL_ERROR: {code: 4200, reason: 'Internal error'},\n    PING_FAILED: {code: 4201, reason: 'Ping failed'},\n    HANDSHAKE_FAILED: {code: 4202, reason: 'Handshake failed'},\n    HANDSHAKE_REJECTED: {code: 4203, reason: 'Handshake rejected'},\n    DISCONNECT_TIMEOUT: {code: 4204, reason: 'Disconnect timeout'},\n    DISPOSED: {code: 4205, reason: 'Client disposed'},\n    UNKNOWN_ERROR: {code: 4299, reason: 'Unknown error'},\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/closestatus.js","const LineError = require('./error');\n\n\nclass Deferred {\n    constructor({\n        handler = () => {},\n        onExpire = () => {},\n        timeout = 0\n    } = {}) {\n        this.resolve_ = null;\n        this.reject_ = null;\n\n        this.timeout_ = null;\n        this.timeoutDuration_ = timeout;\n        this.onExpire_ = onExpire;\n        this.isFinished_ = false;\n\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve_ = resolve;\n            this.reject_ = reject;\n\n            try {\n                handler(this);\n            } catch (err) {\n                this.reject(err);\n            }\n        });\n\n        if (timeout > 0) {\n            this.timeout_ = setTimeout(this.expire.bind(this), timeout);\n        }\n    }\n\n\n    resolve(data) {\n        if (this.isFinished_) return;\n\n        this.isFinished_ = true;\n        this.clearTimeout_();\n        this.resolve_(data);\n    }\n\n\n    reject(err) {\n        if (this.isFinished_) return;\n\n        this.isFinished_ = true;\n        this.clearTimeout_();\n        this.reject_(err);\n    }\n\n\n    expire() {\n        this.isFinished_ = true;\n        this.clearTimeout_();\n        this.onExpire_();\n        this.reject_(new LineError(Deferred.ErrorCode.EXPIRED, `Timeout ${this.timeoutDuration_} ms exceed`));\n    }\n\n\n    dispose() {\n        this.isFinished_ = true;\n        this.clearTimeout_();\n    }\n\n\n    then(...args) {\n        return this.promise.then.apply(this.promise, args);\n    }\n\n\n    catch(...args) {\n        return this.promise.catch.apply(this.promise, args);\n    }\n\n\n    clearTimeout_() {\n        if (this.timeout_) {\n            clearTimeout(this.timeout_);\n            this.timeout_ = null;\n        }\n    }\n}\n\n\nDeferred.ErrorCode = {\n    EXPIRED: 'dExpired'\n};\n\n\nmodule.exports = Deferred;\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/deferred.js","const isUndefined = require('lodash/isUndefined');\nconst isString = require('lodash/isString');\nconst isObject = require('lodash/isObject');\nconst isFunction = require('lodash/isFunction');\nconst values = require('lodash/values');\nconst assign = require('lodash/assign');\nconst {generateDummyId} = require('./utils');\nconst EventEmitterExtra = require('event-emitter-extra');\nconst LineError = require('./error');\n\n\n/**\n * Message class.\n *\n * @private\n * @class Message\n * @extends {EventEmitterExtra}\n */\nclass Message extends EventEmitterExtra {\n    static parse(raw) {\n        try {\n            const data = JSON.parse(raw);\n\n            // If error is error-like object, construct real error\n            if (isObject(data.e) && isString(data.e.name) && isString(data.e.message)) {\n                data.e = assign(new Error(), data.e);\n            }\n\n            return new Message({\n                name: data.n,\n                payload: data.p,\n                err: data.e,\n                id: data.i\n            });\n        } catch(err) {\n            throw new LineError(Message.ErrorCode.INVALID_JSON, `Could not parse incoming message.`);\n        }\n    }\n\n\n    constructor({name, payload, id, err}) {\n        super();\n\n        try {\n            JSON.stringify(payload);\n            JSON.stringify(err);\n        } catch (err) {\n            throw new LineError(\n                Message.ErrorCode.INVALID_JSON,\n                `Message payload or error must be json-friendly. Maybe circular json?`\n            );\n        }\n\n        this.name = name;\n        this.payload = payload;\n        this.id = id;\n        this.err = err;\n\n        this.isResponded_ = false;\n    }\n\n\n    setId(id = generateDummyId()) {\n        this.id = id;\n        return id;\n    }\n\n\n    createResponse(err, payload) {\n        return new Message({name: '_r', payload, err, id: this.id});\n    }\n\n\n    /**\n     * Resolves the message with sending a response back. If the source\n     * does not expecting a response, you don't need to call these methods.\n     *\n     * This method can throw:\n     * - `Message.ErrorCode.MISSING_ID`: Message source is not expecting a response.\n     * - `Message.ErrorCode.ALREADY_RESPONDED`: This message is already responded.\n     * - `Message.ErrorCode.INVALID_JSON`: Could not stringify payload. Probably circular json.\n     *\n     * @param {any=} payload\n     */\n    resolve(payload) {\n        if (isUndefined(this.id)) {\n            throw new LineError(Message.ErrorCode.MISSING_ID, `This message could not be resolved (no id)`);\n        }\n\n        if (this.isResponded_) {\n            throw new LineError(Message.ErrorCode.ALREADY_RESPONDED, `This message has already responded`);\n        }\n\n        try {\n            JSON.stringify(payload);\n        } catch (err_) {\n            throw new LineError(\n                Message.ErrorCode.INVALID_JSON,\n                `Message must be resolved with json-friendly payload. Maybe circular json?`\n            );\n        }\n\n        this.isResponded_ = true;\n        this.emit('resolved', payload);\n    }\n\n\n    /**\n     * Rejects the message, with sending error response back to the source.\n     *\n     * This method can throw:\n     * - `Message.ErrorCode.MISSING_ID`: Message source is not expecting a response.\n     * - `Message.ErrorCode.ALREADY_RESPONDED`: This message is already responded.\n     * - `Message.ErrorCode.INVALID_JSON`: Could not stringify payload. Probably circular json.\n     *\n     * @param {any=} err\n     */\n    reject(err) {\n        if (isUndefined(this.id)) {\n            throw new LineError(Message.ErrorCode.MISSING_ID, `This message could not be rejected (no id)`);\n        }\n\n        if (this.isResponded_) {\n            throw new LineError(Message.ErrorCode.ALREADY_RESPONDED, `This message has already responded`);\n        }\n\n\n        try {\n            JSON.stringify(err);\n        } catch (err_) {\n            throw new LineError(\n                Message.ErrorCode.INVALID_JSON,\n                `Message must be resolved with json-friendly payload. Maybe circular json?`\n            );\n        }\n\n        this.isResponded_ = true;\n        this.emit('rejected', err);\n    }\n\n\n    toString() {\n        const data = {n: this.name};\n\n        if (!isUndefined(this.payload))\n            data.p = this.payload;\n\n        if (!isUndefined(this.id))\n            data.i = this.id;\n\n        if (!isUndefined(this.err)) {\n            data.e = this.err instanceof Error ? assign({\n                name: this.err.name,\n                message: this.err.message\n            }, this.err) : this.err;\n        }\n\n        // We're sure the data is json-friendly\n        return JSON.stringify(data);\n    }\n\n\n    dispose() {\n        const events = this.eventNames();\n        events.forEach(event => this.removeAllListeners(event));\n    }\n}\n\n\n/**\n * These message names are reserved for internal usage.\n * We recommend to not use any message name starts with `_` (underscore).\n *\n * @static\n * @readonly\n * @enum {string}\n */\nMessage.Name = {\n    /**\n     * `_r`\n     */\n    RESPONSE: '_r',\n    /**\n     * `_h`\n     */\n    HANDSHAKE: '_h',\n    /**\n     * `_p`\n     */\n    PING: '_p'\n};\n\n\nMessage.ReservedNames = values(Message.Name);\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nMessage.ErrorCode = {\n    /**\n     * `mInvalidJson`\n     */\n    INVALID_JSON: 'mInvalidJson',\n    /**\n     * `mMissingId`\n     */\n    MISSING_ID: 'mMissingId',\n    /**\n     * `mAlreadyResponded`\n     */\n    ALREADY_RESPONDED: 'mAlreadyResponded',\n};\n\n\nmodule.exports = Message;\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/message.js","const assign = require('lodash/assign');\n\n\n// http://stackoverflow.com/a/6248722\nfunction generateDummyId(length = 4) {\n    return (\"0000\" + (Math.random()*Math.pow(36,length) << 0).toString(36)).slice(-length);\n}\n\n\nmodule.exports = {generateDummyId};\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/utils.js","module.exports = require(\"debug\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"debug\"\n// module id = 11\n// module chunks = 0","module.exports = require(\"lodash/debounce\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/debounce\"\n// module id = 12\n// module chunks = 0","module.exports = require(\"lodash/defaultsDeep\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/defaultsDeep\"\n// module id = 13\n// module chunks = 0","module.exports = require(\"lodash/forEach\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/forEach\"\n// module id = 14\n// module chunks = 0","module.exports = require(\"lodash/isBoolean\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isBoolean\"\n// module id = 15\n// module chunks = 0","module.exports = require(\"lodash/isFunction\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isFunction\"\n// module id = 16\n// module chunks = 0","module.exports = require(\"lodash/isInteger\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isInteger\"\n// module id = 17\n// module chunks = 0","module.exports = require(\"lodash/isNumber\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isNumber\"\n// module id = 18\n// module chunks = 0","module.exports = require(\"lodash/isUndefined\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isUndefined\"\n// module id = 19\n// module chunks = 0","module.exports = require(\"lodash/values\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/values\"\n// module id = 20\n// module chunks = 0","global.WebSocket = require('ws'); // Polyfill for extending browser code\nmodule.exports = require('./client-web');\n\n\n\n// WEBPACK FOOTER //\n// ./src/client/client-node.js"],"sourceRoot":""}