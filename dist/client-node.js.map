{"version":3,"sources":["webpack:///client-node.js","webpack:///webpack/bootstrap a6554857a3d3b8bc3421","webpack:///./src/lib/error.js","webpack:///external \"lodash/assign\"","webpack:///./src/lib/deferred.js","webpack:///external \"event-emitter-extra\"","webpack:///external \"lodash/isObject\"","webpack:///external \"lodash/isString\"","webpack:///./src/client/client-web.js","webpack:///external \"ws\"","webpack:///./src/lib/closestatus.js","webpack:///./src/lib/message.js","webpack:///./src/lib/utils.js","webpack:///external \"debug\"","webpack:///external \"lodash/debounce\"","webpack:///external \"lodash/defaultsDeep\"","webpack:///external \"lodash/forEach\"","webpack:///external \"lodash/isBoolean\"","webpack:///external \"lodash/isFunction\"","webpack:///external \"lodash/isInteger\"","webpack:///external \"lodash/isNumber\"","webpack:///external \"lodash/isUndefined\"","webpack:///external \"lodash/values\"","webpack:///./src/client/client-node.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","Object","defineProperty","configurable","enumerable","get","n","__esModule","o","object","property","prototype","hasOwnProperty","p","s","LineError","code","message","payload","this","stack","Error","require","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","Deferred","_this","_ref","arguments","undefined","_ref$handler","handler","_ref$onExpire","onExpire","_ref$timeout","timeout","resolve_","reject_","timeout_","timeoutDuration_","onExpire_","isFinished_","promise","Promise","resolve","reject","err","setTimeout","expire","bind","data","clearTimeout_","ErrorCode","EXPIRED","_len","args","Array","_key","then","apply","_len2","_key2","catch","clearTimeout","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","Message","EventEmitterExtra","forEach","debounce","isObject","isBoolean","isString","isNumber","isInteger","defaultsDeep","debug","CloseStatus","Client","_EventEmitterExtra","url","options","getPrototypeOf","trim","INVALID_OPTIONS","urlFollowed","handshake","responseTimeout","disconnectTimeout","pingInterval","reconnect","reconnectOptions","initialDelay","multiply","maxDelay","randomness","uptime","uptimeOptions","interval","window","followRedirections","JSON","stringify","ws_","id","state","State","READY","reconnectState_","disabled","attempt","deferreds_","disconnectTimeout_","uptimeBuffer_","uptimeBufferLength_","Math","round","uptimeInterval_","setInterval","uptimeTick_","autoPing_","ping","CONNECTED","DISCONNECTED","WebSocket","bindEvents_","CONNECTING","emit","Event","WEBSOCKET_ERROR","_this2","connect","removeListeners","onConnectingError","onConnected","onDisconnected","e","removeListener","CONNECTING_ERROR","once","reason","opt_retry","_this3","HANDSHAKING","close","rejectAllDeferreds_","cancel","ERROR","DISCONNECT_TIMEOUT","onClose_","DISCONNECTING","retry","_this4","disconnect","onopen","onOpen_","onclose","onerror","onError_","onmessage","onMessage_","_this5","Name","HANDSHAKE","send_","resetReconnectState_","HANDSHAKE_ERROR","HANDSHAKE_FAILED","MESSAGE_TIMEOUT","MESSAGE_REJECTED","HANDSHAKE_REJECTED","closeEvent","_this6","unBindEvents_","max","min","random","_this7","eventName","httpUrl","ws2http","fetchResponseUrl","httpUrlFollowed","wsUrl","http2ws","parse","INVALID_JSON","PING","onPingMessage_","RESPONSE","onResponseMessage_","ReservedNames","indexOf","onMessageWithResponse_","onMessageWithoutResponse_","sendWithoutResponse_","createResponse","deferred","_this8","MESSAGE_NOT_RESPONDED","dispose","opt_timeout","_this9","setId","_this10","readyState","messageStr","toString","send","_this11","currentSocket","PING_FAILED","PING_ERROR","push","splice","filter","val","_this12","removeAllListeners","clearInterval","DISPOSED","rv","mapping","ws://","wss://","replace","substr","http://","https://","req","XMLHttpRequest","addEventListener","responseURL","open","INTERNAL_ERROR","UNKNOWN_ERROR","isUndefined","values","assign","_require","generateDummyId","isResponded_","raw","MISSING_ID","ALREADY_RESPONDED","err_","events","eventNames","event","pow","slice","global"],"mappings":"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","file":"client-node.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmory imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmory exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tObject.defineProperty(exports, name, {\n/******/ \t\t\tconfigurable: false,\n/******/ \t\t\tenumerable: true,\n/******/ \t\t\tget: getter\n/******/ \t\t});\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 21);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\"use strict\";\n'use strict';\n\nfunction LineError(code, message, payload) {\n    this.name = 'LineError';\n    this.message = message;\n    this.code = code;\n    this.payload = payload;\n    this.stack = new Error().stack;\n}\nLineError.prototype = new Error();\n\nmodule.exports = LineError;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/assign\");\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar LineError = __webpack_require__(0);\n\nvar Deferred = function () {\n    function Deferred() {\n        var _this = this;\n\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n            _ref$handler = _ref.handler,\n            handler = _ref$handler === undefined ? function () {} : _ref$handler,\n            _ref$onExpire = _ref.onExpire,\n            onExpire = _ref$onExpire === undefined ? function () {} : _ref$onExpire,\n            _ref$timeout = _ref.timeout,\n            timeout = _ref$timeout === undefined ? 0 : _ref$timeout;\n\n        _classCallCheck(this, Deferred);\n\n        this.resolve_ = null;\n        this.reject_ = null;\n\n        this.timeout_ = null;\n        this.timeoutDuration_ = timeout;\n        this.onExpire_ = onExpire;\n        this.isFinished_ = false;\n\n        this.promise = new Promise(function (resolve, reject) {\n            _this.resolve_ = resolve;\n            _this.reject_ = reject;\n\n            try {\n                handler(_this);\n            } catch (err) {\n                _this.reject(err);\n            }\n        });\n\n        if (timeout > 0) {\n            this.timeout_ = setTimeout(this.expire.bind(this), timeout);\n        }\n    }\n\n    _createClass(Deferred, [{\n        key: 'resolve',\n        value: function resolve(data) {\n            if (this.isFinished_) return;\n\n            this.isFinished_ = true;\n            this.clearTimeout_();\n            this.resolve_(data);\n        }\n    }, {\n        key: 'reject',\n        value: function reject(err) {\n            if (this.isFinished_) return;\n\n            this.isFinished_ = true;\n            this.clearTimeout_();\n            this.reject_(err);\n        }\n    }, {\n        key: 'expire',\n        value: function expire() {\n            this.isFinished_ = true;\n            this.clearTimeout_();\n            this.onExpire_();\n            this.reject_(new LineError(Deferred.ErrorCode.EXPIRED, 'Timeout ' + this.timeoutDuration_ + ' ms exceed'));\n        }\n    }, {\n        key: 'dispose',\n        value: function dispose() {\n            this.isFinished_ = true;\n            this.clearTimeout_();\n        }\n    }, {\n        key: 'then',\n        value: function then() {\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n            }\n\n            return this.promise.then.apply(this.promise, args);\n        }\n    }, {\n        key: 'catch',\n        value: function _catch() {\n            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                args[_key2] = arguments[_key2];\n            }\n\n            return this.promise.catch.apply(this.promise, args);\n        }\n    }, {\n        key: 'clearTimeout_',\n        value: function clearTimeout_() {\n            if (this.timeout_) {\n                clearTimeout(this.timeout_);\n                this.timeout_ = null;\n            }\n        }\n    }]);\n\n    return Deferred;\n}();\n\nDeferred.ErrorCode = {\n    EXPIRED: 'dExpired'\n};\n\nmodule.exports = Deferred;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"event-emitter-extra\");\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isObject\");\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isString\");\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Message = __webpack_require__(9);\nvar EventEmitterExtra = __webpack_require__(3);\nvar Deferred = __webpack_require__(2);\nvar assign = __webpack_require__(1);\nvar forEach = __webpack_require__(14);\nvar debounce = __webpack_require__(12);\nvar isObject = __webpack_require__(4);\nvar isBoolean = __webpack_require__(15);\nvar isString = __webpack_require__(5);\nvar isNumber = __webpack_require__(18);\nvar isInteger = __webpack_require__(17);\nvar defaultsDeep = __webpack_require__(13);\nvar debug = __webpack_require__(11)('line:client');\nvar LineError = __webpack_require__(0);\nvar CloseStatus = __webpack_require__(8);\n\n/**\n * Line client class.\n *\n * @class Client\n * @extends {EventEmitterExtra}\n * @param {string=} url Server url, default: `ws://localhost`.\n * @param {Object=} options Options object.\n * @param {Object=} options.handshake Handshake options\n * @param {number=} options.handshake.timeout Handshake timeout duration in milliseconds.\n *      Default: `30000` (30 seconds).\n * @param {any=} options.handshake.payload Handshake payload that will be send to server.\n * @param {number=} options.responseTimeout This is the timeout for getting response from the server\n *      when using `client.send()` method. Default: `10000` (10 seconds). Note that this option is ineffective for\n *      `client.sendWithoutResponse()` method.\n * @param {number=} options.disconnectTimeout In some browsers, `close` frame is not fired immediately.\n *      This timeout is for starting `close` procedure even if close frame is not arrived. Default: `5000` (5 seconds).\n * @param {number=} options.pingInterval Pinging interval. Default: `20000` (20 seconds).\n * @param {boolean=} options.reconnect Whether try to reconnect server after unexpected disconnection,\n *      default `true`.\n * @param {Object=} options.reconnectOptions Reconnection options.\n * @param {number=} options.reconnectOptions.initialDelay In milliseconds. Default: `1000` (1 second).\n * @param {number=} options.reconnectOptions.multiply Default: `1.5`\n * @param {number=} options.reconnectOptions.maxDelay In milliseconds. Default: `30000`\n * @param {number=} options.reconnectOptions.randomness Random delay multiplier. Default: `0.5`\n * @param {boolean=} options.uptime Whether keep & calculate uptime, default `false`.\n *      If this option is not true, `client.getUptime()` returns undefined.\n * @param {Object=} options.uptimeOptions Uptime options.\n * @param {number=} options.uptimeOptions.interval Uptime checking interval. In milliseconds. Default: `5000` (5 seconds).\n * @param {number=} options.uptimeOptions.window Uptime checking window length. In milliseconds. Default: `300000` (5 minutes)\n * @param {boolean=} options.followRedirections Attempt to follow 30X redirections. If this options is set, after\n *      a native websocket connection error, line will try to make a http request to server url. If it is success,\n *      final response url will be used as server after couple of connection attempts. Default: `false`\n * @property {string} url Server url\n * @property {string} id Unique connection id assigned by the server. It will be accessible after handshake.\n * @property {Client.State} state Connection state\n * @example\n * // Add line-client to your html document\n * <script src=\"./node_modules/line-socket/dist/client-web-globals.js\"></script>\n *\n * // For web browsers (consuming as a commonjs module)\n * const LineClient = require('line-socket/client-web');\n *\n * // For node.js\n * const LineClient = require('line-socket/client-node');\n *\n * // Usage\n * const client = new LineClient('ws://localhost:8080');\n * client.connect();\n */\n\nvar Client = function (_EventEmitterExtra) {\n    _inherits(Client, _EventEmitterExtra);\n\n    function Client() {\n        var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'ws://localhost';\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, Client);\n\n        var _this = _possibleConstructorReturn(this, (Client.__proto__ || Object.getPrototypeOf(Client)).call(this));\n\n        if (!isString(url) || url.trim().length == 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, 'Url parameter must be string and cannot be empty');\n\n        if (!isObject(options)) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, 'Options parameter must be an object');\n\n        _this.url = url.trim();\n        _this.urlFollowed = null;\n        _this.options = defaultsDeep(options, {\n            handshake: {\n                timeout: 30000,\n                payload: undefined\n            },\n            responseTimeout: 10000,\n            disconnectTimeout: 5000,\n            pingInterval: 20000,\n            reconnect: true,\n            reconnectOptions: {\n                initialDelay: 1000,\n                multiply: 1.5,\n                maxDelay: 30000,\n                randomness: 0.5\n            },\n            uptime: false,\n            uptimeOptions: {\n                interval: 5000,\n                window: 300000\n            },\n            followRedirections: false\n        });\n\n        if (!isObject(_this.options.handshake)) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.handshake\" must be an object');\n\n        if (!isInteger(_this.options.handshake.timeout) || _this.options.handshake.timeout < 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.handshake.timeout\" must be a positive integer or zero');\n\n        try {\n            JSON.stringify(_this.options.handshake.payload);\n        } catch (err) {\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.handshake.payload\" must be json friendly, probably circular dependency?');\n        }\n\n        if (!isInteger(_this.options.responseTimeout) || _this.options.responseTimeout < 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.responseTimeout\" must be a positive integer or zero');\n\n        if (!isInteger(_this.options.disconnectTimeout) || _this.options.disconnectTimeout < 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.disconnectTimeout\" must be a positive integer or zero');\n\n        if (!isInteger(_this.options.pingInterval) || _this.options.pingInterval < 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.pingInterval\" must be a positive integer or zero');\n\n        if (!isBoolean(_this.options.reconnect)) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.reconnect\" must be a boolean');\n\n        if (!isObject(_this.options.reconnectOptions)) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.reconnectOptions\" must be an object');\n\n        if (!isInteger(_this.options.reconnectOptions.initialDelay) || _this.options.reconnectOptions.initialDelay <= 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.reconnectOptions.initialDelay\" must be a positive integer');\n\n        if (!isNumber(_this.options.reconnectOptions.multiply) || _this.options.reconnectOptions.multiply < 1) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.reconnectOptions.multiply\" must be a number >= 1');\n\n        if (!isInteger(_this.options.reconnectOptions.maxDelay) || _this.options.reconnectOptions.maxDelay <= 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.reconnectOptions.maxDelay\" must be a positive integer');\n\n        if (_this.options.reconnectOptions.maxDelay < _this.options.reconnectOptions.initialDelay) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.reconnectOptions.maxDelay\" must be a greater than initial delay');\n\n        if (!isNumber(_this.options.reconnectOptions.randomness) || _this.options.reconnectOptions.randomness < 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.reconnectOptions.randomness\" must be a positive number or zero');\n\n        if (!isBoolean(_this.options.uptime)) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.uptime\" must be a boolean');\n\n        if (!isObject(_this.options.uptimeOptions)) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.uptimeOptions\" must be an object');\n\n        if (!isInteger(_this.options.uptimeOptions.interval) || _this.options.uptimeOptions.interval <= 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.uptimeOptions.interval\" must be a positive integer');\n\n        if (!isInteger(_this.options.uptimeOptions.window) || _this.options.uptimeOptions.window <= 0) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.uptimeOptions.window\" must be a positive integer');\n\n        if (_this.options.uptimeOptions.window < _this.options.uptimeOptions.interval) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.uptimeOptions.window\" must be a greater than interval');\n\n        if (!isBoolean(_this.options.followRedirections)) throw new LineError(Client.ErrorCode.INVALID_OPTIONS, '\"options.followRedirections\" must be a boolean');\n\n        _this.ws_ = null;\n        _this.id = null;\n        _this.state = Client.State.READY;\n\n        _this.reconnectState_ = { disabled: false, attempt: 0, timeout: null };\n        _this.deferreds_ = {};\n        _this.disconnectTimeout_ = null;\n        _this.uptimeBuffer_ = [];\n        _this.uptimeBufferLength_ = Math.round(_this.options.uptimeOptions.window / _this.options.uptimeOptions.interval);\n        _this.uptimeInterval_ = options.uptime ? setInterval(_this.uptimeTick_.bind(_this), _this.options.uptimeOptions.interval) : null;\n        _this.autoPing_ = debounce(function () {});\n\n        if (_this.options.pingInterval > 0) {\n            _this.autoPing_ = debounce(function () {\n                _this.ping().then(function () {\n                    // Ping successfull. If we still connected, debounce next one!\n                    if (_this.options.pingInterval > 0 && _this.state == Client.State.CONNECTED) {\n                        _this.autoPing_(); // Recursive\n                    }\n                }).catch(function () {/* ping() method handles disconnection the logic itself */});\n            }, _this.options.pingInterval);\n        }\n        return _this;\n    }\n\n    /**\n     * Starts the connection procedure.\n     *\n     * If server url is invalid or there is a security error,\n     * this method will throw `Client.ErrorCode.WEBSOCKET_ERROR`.\n     *\n     * When procedure is started, `Client.Event.CONNECTING` event will be emitted.\n     *\n     * If an error occured during connection or handshake, the client will emit `Client.Event.CONNECTING_ERROR`.\n     *\n     * If connection is failed for some reason and `options.reconnect` is `true`. The client will\n     * retry to connect.\n     *\n     * @returns {boolean}\n     * @example\n     * client.connect();\n     *\n     * client.on(Client.Event.CONNECTED, () => {\n     *   console.log('Client connected.');\n     * });\n     *\n     * client.on(Client.Event.CONNECTING_ERROR, (err) => {\n     *   console.log('Could not connect!', err);\n     * });\n     */\n\n\n    _createClass(Client, [{\n        key: 'connect',\n        value: function connect() {\n            switch (this.state) {\n                case Client.State.DISCONNECTED:\n                case Client.State.READY:\n                    var url = this.url;\n\n                    if (this.options.followRedirections && this.urlFollowed) {\n                        url = this.urlFollowed;\n                        debug('Following redirection \"' + this.url + '\" -> \"' + this.urlFollowed + '\"');\n                    }\n\n                    debug('Connecting to \"' + url + '\" ...');\n\n                    try {\n                        this.reconnectState_.disabled = false;\n                        this.ws_ = new WebSocket(url);\n                        this.bindEvents_();\n                        this.state = Client.State.CONNECTING;\n                        this.emit(Client.Event.CONNECTING);\n                        return true;\n                    } catch (err) {\n                        throw new LineError(Client.ErrorCode.WEBSOCKET_ERROR, 'Native websocket error. Invalid url or security error', err);\n                    }\n\n                default:\n                    debug('Ignoring connect() call, client is in \"' + this.state + '\" state');\n                    return false;\n            }\n        }\n\n        /**\n         * TODO: This is an experimental method currently, it's just used in tests.\n         * DO NOT use in production.\n         *\n         * @returns {Promise}\n         * @ignore\n         */\n\n    }, {\n        key: 'connectAsync',\n        value: function connectAsync() {\n            var _this2 = this;\n\n            return new Promise(function (resolve, reject) {\n                _this2.connect(); // Can throw WEBSOCKET_ERROR or ignore silently\n\n                var removeListeners = function removeListeners() {};\n\n                var onConnectingError = function onConnectingError(err) {\n                    removeListeners();\n                    reject(err);\n                };\n\n                var onConnected = function onConnected(data) {\n                    removeListeners();\n                    resolve(data);\n                };\n\n                var onDisconnected = function onDisconnected(e) {\n                    removeListeners();\n                    reject(new LineError(Client.ErrorCode.DISCONNECTED, 'Client disconnected', e));\n                };\n\n                removeListeners = function removeListeners() {\n                    _this2.removeListener(Client.Event.CONNECTING_ERROR, onConnectingError);\n                    _this2.removeListener(Client.Event.CONNECTED, onConnected);\n                    _this2.removeListener(Client.Event.DISCONNECTED, onDisconnected);\n                };\n\n                _this2.once(Client.Event.CONNECTING_ERROR, onConnectingError);\n                _this2.once(Client.Event.CONNECTED, onConnected);\n                _this2.once(Client.Event.DISCONNECTED, onDisconnected);\n            });\n        }\n\n        /**\n         * Gracefully closes the connection. This method can throw `Client.ErrorCode.WEBSOCKET_ERROR` if\n         * provided parameters are invalid. If websocket is not closed after `options.disconnectTimeout` ms,\n         * the client will start the disconnection procedure forcefully.\n         *\n         * @param {number=} code A numeric value indicating the status code explaining why the connection is being closed.\n         *      Must be between 1000-4999. Default is 1000.\n         * @param {any=} reason A human-readable string explaining why the connection is closing. This string must\n         *      be no longer than 123 bytes of UTF-8 text (not characters).\n         * @param {boolean=} opt_retry Whether retry to connect after disconnection.\n         * @returns {boolean}\n         * @example\n         * client.disconnect();\n         *\n         * client.on(Client.Event.DISCONNECTED, (e) => {\n         *   console.log('Disconnected', e.code, e.reason);\n         * });\n         */\n\n    }, {\n        key: 'disconnect',\n        value: function disconnect(code, reason, opt_retry) {\n            var _this3 = this;\n\n            switch (this.state) {\n                case Client.State.CONNECTING:\n                case Client.State.HANDSHAKING:\n                case Client.State.CONNECTED:\n                    debug('Disconnecting... (State: ' + this.state + ')');\n\n                    try {\n                        this.ws_.close(code || 1000, reason); // Can throw INVALID_ACCESS_ERR, SYNTAX_ERR\n                        debug('Websocket is closed');\n                        this.reconnectState_.disabled = !opt_retry;\n                        this.rejectAllDeferreds_(new LineError(Client.ErrorCode.DISCONNECTED, 'Disconnect procedure started'));\n                        this.autoPing_.cancel();\n\n                        // Wait \"close\" event for some time, then manually start onClose procedure\n                        if (this.disconnectTimeout_) clearTimeout(this.disconnectTimeout_);\n                        if (this.options.disconnectTimeout) {\n                            this.disconnectTimeout_ = setTimeout(function () {\n                                debug('Disconnect timeout exceeded, force disconnecting...');\n\n                                _this3.emit(Client.Event.ERROR, new LineError(Client.ErrorCode.DISCONNECT_TIMEOUT, 'Disconnect timeout exceeded, force disconnecting...'));\n\n                                _this3.onClose_(CloseStatus.DISCONNECT_TIMEOUT);\n\n                                clearTimeout(_this3.disconnectTimeout_);\n                            }, this.options.disconnectTimeout);\n                        }\n\n                        this.state = Client.State.DISCONNECTING;\n                        this.emit(Client.Event.DISCONNECTING);\n\n                        return true;\n                    } catch (err) {\n                        throw new LineError(Client.ErrorCode.WEBSOCKET_ERROR, 'Could not disconnect. Invalid code or reason, check payload.', err);\n                    }\n\n                default:\n                    debug('Ignoring disconnect() call, client is in \"' + this.state + '\" state.');\n                    return false;\n            }\n        }\n\n        /**\n         * TODO: This is an experimental method currently, it's just used in tests.\n         * DO NOT use in production.\n         *\n         * @returns {Promise}\n         * @ignore\n         */\n\n    }, {\n        key: 'disconnectAsync',\n        value: function disconnectAsync(code, reason, retry) {\n            var _this4 = this;\n\n            return new Promise(function (resolve, reject) {\n                _this4.disconnect(code, reason, retry); // Can throw WEBSOCKET_ERROR or ignore silently\n\n                var onDisconnected = function onDisconnected(e) {\n                    // this.removeListener(Client.Event.DISCONNECTED, onDisconnected);\n                    resolve(e);\n                };\n\n                _this4.once(Client.Event.DISCONNECTED, onDisconnected);\n            });\n        }\n\n        /**\n         * Binds websocket events\n         *\n         * @ignore\n         */\n\n    }, {\n        key: 'bindEvents_',\n        value: function bindEvents_() {\n            debug('Binding native event handlers.');\n            this.ws_.onopen = this.onOpen_.bind(this);\n            this.ws_.onclose = this.onClose_.bind(this);\n            this.ws_.onerror = this.onError_.bind(this);\n            this.ws_.onmessage = this.onMessage_.bind(this);\n        }\n\n        /**\n         * Unbinds websocket events\n         *\n         * @ignore\n         */\n\n    }, {\n        key: 'unBindEvents_',\n        value: function unBindEvents_() {\n            if (!this.ws_) return;\n            debug('Unbinding native event handlers.');\n            this.ws_.onopen = function () {};\n            this.ws_.onclose = function () {};\n            this.ws_.onerror = function () {};\n            this.ws_.onmessage = function () {};\n        }\n\n        /**\n         * Native \"open\" event handler. At this time we will start the handshakin process.\n         *\n         * @ignore\n         */\n\n    }, {\n        key: 'onOpen_',\n        value: function onOpen_() {\n            var _this5 = this;\n\n            debug('Native \"open\" event received, starting handshake process');\n\n            this.state = Client.State.HANDSHAKING;\n            var message = new Message({\n                name: Message.Name.HANDSHAKE,\n                payload: this.options.handshake.payload // We're sure that this is json friendly\n            });\n\n            this.send_(message, this.options.handshake.timeout).then(function (data) {\n                // Message is sent and we got the response!\n                if (!isObject(data)) {\n                    debug('Unexpected handshake response!?');\n\n                    _this5.emit(Client.Event.CONNECTING_ERROR, new LineError(Client.ErrorCode.HANDSHAKE_ERROR, 'Handshake response is not object. Aborting handshake...', data));\n\n                    _this5.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Handshake failed, unexpected handshake response.', true);\n                    return;\n                }\n\n                debug('Handshake successful.');\n                _this5.resetReconnectState_();\n                _this5.id = data.id;\n                _this5.state = Client.State.CONNECTED;\n                _this5.autoPing_(); // Start auto-ping\n\n                debug('Emitting \"connected\" event...');\n                _this5.emit(Client.Event.CONNECTED, data.payload);\n            }).catch(function (err) {\n                if (err instanceof LineError) {\n                    switch (err.code) {\n                        case Client.ErrorCode.DISCONNECTED:\n                            debug('Handshake failed, connection lost (disconnected)');\n                            _this5.emit(Client.Event.CONNECTING_ERROR, new LineError(Client.ErrorCode.HANDSHAKE_ERROR, 'Connection lost during handshake.'));\n                            return;\n\n                        case Client.ErrorCode.MESSAGE_TIMEOUT:\n                            // TODO: Try again maybe?\n                            debug('Handshake failed, message timeout');\n                            _this5.emit(Client.Event.CONNECTING_ERROR, new LineError(Client.ErrorCode.HANDSHAKE_ERROR, 'Handshake failed, request timeout.'));\n                            return _this5.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Handshake failed, request timeout.', true);\n\n                        case Client.ErrorCode.MESSAGE_REJECTED:\n                            debug('Handshake REJECTED!');\n                            _this5.emit(Client.Event.CONNECTING_ERROR, new LineError(Client.ErrorCode.HANDSHAKE_REJECTED, 'Handshake rejected, check payload for further details.', err && err.payload));\n                            return _this5.disconnect(CloseStatus.HANDSHAKE_REJECTED.code, 'Handshake rejected', true);\n\n                        case Client.ErrorCode.WEBSOCKET_ERROR:\n                            debug('Handshake failed, native websocket error');\n                            _this5.emit(Client.Event.CONNECTING_ERROR, new LineError(Client.ErrorCode.HANDSHAKE_ERROR, 'Handshake failed. Websocket protocol error, check payload.', err && err.payload));\n                            return _this5.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Handshake failed, native websocket error', true);\n\n                        default:\n                            debug('Handshake failed, unknown line error', err);\n                            return _this5.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Unknown line error', true);\n                    }\n                }\n\n                // Unknown error\n                debug('Handshake failed, unknown error', err);\n                return _this5.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Unknown error', true);\n            });\n        }\n\n        /**\n         * Native \"close\" event handler.\n         *\n         * @param {Event} closeEvent Native close event.\n         * @param {number} closeEvent.code Close status code sent by server.\n         * @param {string=} closeEvent.reason Human readable close reason.\n         * @ignore\n         */\n\n    }, {\n        key: 'onClose_',\n        value: function onClose_(closeEvent) {\n            var _this6 = this;\n\n            debug('Native \"close\" event received in \"' + this.state + '\" state (code: ' + closeEvent.code + ', reason: ' + closeEvent.reason + ')');\n\n            if (this.disconnectTimeout_) clearTimeout(this.disconnectTimeout_);\n            this.rejectAllDeferreds_(new LineError(Client.ErrorCode.DISCONNECTED, 'Client is disconnected'));\n            this.unBindEvents_();\n            this.autoPing_.cancel();\n\n            this.id = null;\n            this.ws_ = null;\n\n            debug('Emitting \"disconnected\" event...');\n            this.state = Client.State.DISCONNECTED;\n            this.emit(Client.Event.DISCONNECTED, closeEvent);\n\n            if (this.options.reconnect && !this.reconnectState_.disabled) {\n                var timeout = this.options.reconnectOptions.initialDelay * Math.max(this.options.reconnectOptions.multiply * this.reconnectState_.attempt, 1);\n                timeout = Math.min(timeout, this.options.reconnectOptions.maxDelay);\n                timeout += Math.round(Math.random() * this.options.reconnectOptions.randomness * timeout);\n\n                debug('Will try to reconnect in ' + timeout + ' ms');\n\n                this.reconnectState_.timeout && clearTimeout(this.reconnectState_.timeout);\n                this.reconnectState_.timeout = setTimeout(function () {\n                    _this6.reconnectState_.attempt++;\n                    _this6.connect();\n                }, timeout);\n            }\n        }\n\n        /**\n         * Native \"error\" handler. A \"close\" event will ALWAYS follow this event.\n         * See: https://www.w3.org/TR/websockets/#closeWebSocket\n         * So, if client state is connecting/handshaking, emit `CONNECTING_ERROR`.\n         *\n         * @param {Error} err Native error object.\n         * @ignore\n         */\n\n    }, {\n        key: 'onError_',\n        value: function onError_(err) {\n            var _this7 = this;\n\n            debug('Native \"error\" event received in \"' + this.state + '\" state.');\n            var eventName = Client.Event.ERROR;\n\n            if (this.state == Client.State.CONNECTING || this.state == Client.State.HANDSHAKING) {\n                eventName = Client.Event.CONNECTING_ERROR;\n            }\n\n            this.emit(eventName, new LineError(Client.ErrorCode.WEBSOCKET_ERROR, 'Native websocket error occured, check payload.', err));\n\n            // For 30X redirects, we get this error: \"Unexpected response code: 30X\"\n            // Attempt to make a http request to server url (this request will follow redirections).\n            // If it is successful, use the final response url as websocket url\n            if (this.options.followRedirections) {\n                debug('Attempting to follow redirections...');\n                var httpUrl = Client.ws2http(this.url);\n\n                if (httpUrl) {\n                    debug('Making a request to \"' + httpUrl + '\" for following');\n                    Client.fetchResponseUrl(httpUrl).then(function (httpUrlFollowed) {\n                        var wsUrl = Client.http2ws(httpUrlFollowed);\n                        if (!wsUrl) return debug('Could not convert http url \"' + httpUrlFollowed + '\" to ws');\n                        if (_this7.urlFollowed == wsUrl) return;\n                        debug('Updating followed url to \"' + wsUrl + '\"');\n                        _this7.urlFollowed = wsUrl;\n                    }).catch(function (err) {\n                        return debug('Could not follow redirection, ignoring...', err);\n                    });\n                } else {\n                    debug('Could not convert ws url to http');\n                }\n            }\n        }\n\n        /**\n         * Native \"message\" handler.\n         *\n         * @param {Event} e Native message event.\n         * @param {string} e.data Raw message data.\n         * @ignore\n         */\n\n    }, {\n        key: 'onMessage_',\n        value: function onMessage_(e) {\n            debug('Native \"message\" event received in \"' + this.state + '\" state.');\n            var message = void 0;\n\n            // A message is recieved, debounce our auto-ping handler\n            if (this.state == Client.State.CONNECTED) {\n                this.autoPing_();\n            }\n\n            /**\n             * Try to parse incoming message\n             */\n            try {\n                message = Message.parse(e.data);\n            } catch (err) {\n                debug('Could not parse message', e.data);\n                this.emit(Client.Event.ERROR, new LineError(Client.ErrorCode.INVALID_JSON, 'Could not parse incoming message, invalid json. Check payload for incoming data.', e.data));\n                return;\n            }\n\n            /**\n             * Route the incoming message\n             */\n            if (message.name == Message.Name.PING) {\n                // Ping message arrived\n                this.onPingMessage_(message);\n            } else if (message.name == Message.Name.RESPONSE) {\n                // Response message arrive\n                this.onResponseMessage_(message);\n            } else if (Message.ReservedNames.indexOf(message.name) == -1) {\n                // If message name is not reserved\n                if (!message.id) {\n                    // A message arrived without response\n                    this.onMessageWithoutResponse_(message);\n                } else {\n                    // A message arrived awaiting its response\n                    this.onMessageWithResponse_(message);\n                }\n            } else {\n                debug('Could not route the message', message);\n            }\n        }\n\n        /**\n         * On \"ping\" message handler. Respond with \"pong\".\n         *\n         * @param {Message} message\n         * @ignore\n         */\n\n    }, {\n        key: 'onPingMessage_',\n        value: function onPingMessage_(message) {\n            debug('Ping received, responding \"pong\"...');\n\n            this.sendWithoutResponse_(message.createResponse(null, 'pong')).catch(function (err) {\n                return debug('Ping response failed to send back, ignoring for now...', err);\n            });\n        }\n\n        /**\n         * A response is arrived, find the related deferred and finalize it.\n         *\n         * @param {Message} message\n         * @ignore\n         */\n\n    }, {\n        key: 'onResponseMessage_',\n        value: function onResponseMessage_(message) {\n            var deferred = this.deferreds_[message.id];\n\n            if (!deferred) return debug('Unknown message response, ignoring... (name=\"' + message.name + '\" id=\"' + message.id + '\")');\n\n            debug('Message response arrived: name=\"' + message.name + '\" id=\"' + message.id + '\"');\n\n            if (message.err) {\n                // Server rejects the message\n                deferred.reject(new LineError(Client.ErrorCode.MESSAGE_REJECTED, 'Message is rejected by server, check payload.', message.err));\n            } else {\n                // Server resolves the message\n                deferred.resolve(message.payload);\n            }\n\n            delete this.deferreds_[message.id];\n        }\n\n        /**\n         * A message is arrived without awaiting a response.\n         *\n         * @param {Message} message\n         * @ignore\n         */\n\n    }, {\n        key: 'onMessageWithoutResponse_',\n        value: function onMessageWithoutResponse_(message) {\n            debug('Message without response: name=\"' + message.name + '\"');\n            this.emit(message.name, message);\n        }\n\n        /**\n         * A message is arrived and server is waiting for a response.\n         *\n         * @param {Message} message\n         * @ignore\n         */\n\n    }, {\n        key: 'onMessageWithResponse_',\n        value: function onMessageWithResponse_(message) {\n            var _this8 = this;\n\n            debug('Message with response: name=\"' + message.name + '\" id=\"' + message.id + '\"');\n\n            message.once('resolved', function (payload) {\n                debug('Client resolving: name=\"' + message.name + '\" id=\"' + message.id + '\"');\n\n                // Try to send our response back to server, if not emit an error\n                _this8.sendWithoutResponse_(message.createResponse(null, payload)).catch(function (err) {\n                    _this8.emit(Client.Event.ERROR, new LineError(Client.ErrorCode.MESSAGE_NOT_RESPONDED, 'Message (name=\"' + message.name + '\" id=\"' + message.id + '\") could not responded (resolve)', err));\n                }).then(function () {\n                    return message.dispose();\n                });\n            });\n\n            message.once('rejected', function (err) {\n                debug('Client rejecting: name=\"' + message.name + '\" id=\"' + message.id + '\"');\n\n                // Try to send our response back to server, if not emit an error\n                _this8.sendWithoutResponse_(message.createResponse(err)).catch(function (err) {\n                    _this8.emit(Client.Event.ERROR, new LineError(Client.ErrorCode.MESSAGE_NOT_RESPONDED, 'Message (name=\"' + message.name + '\" id=\"' + message.id + '\") could not responded (reject)', err));\n                }).then(function () {\n                    return message.dispose();\n                });\n            });\n\n            this.emit(message.name, message);\n        }\n\n        /**\n         * Sends a message to server with awaiting its response. This method returns a promise\n         * which resolves the payload parameter will be passed into `message.resolve(...)` in server-side.\n         *\n         * If server rejects the message with `message.reject(...)`, this promise will be rejected with\n         * `Client.ErrorCode.MESSAGE_REJECTED`. You can access the original error object with `err.payload`.\n         *\n         * Rejections:\n         * - `Client.ErrorCode.INVALID_JSON`: Could not stringify the message payload. Probably circular json.\n         * - `Client.ErrorCode.MESSAGE_REJECTED`: Message is explicitly rejected by the server.\n         * - `Client.ErrorCode.MESSAGE_TIMEOUT`: Message response did not arrived, timeout exceeded.\n         * - `Client.ErrorCode.DISCONNECTED`: Client is not connected or connection is closing\n         * - `Client.ErrorCode.WEBSOCKET_ERROR`: Native websocket error (INVALID_STATE_ERR or SYNTAX_ERR)\n         *\n         * @param {string} name Message name.\n         * @param {any=} payload Optional message payload.\n         * @param {number=} timeout Timeout duration for waiting the response. If this parameter\n         *      is not provided, `options.responseTimeout` will be used.\n         * @returns {Promise}\n         * @example\n         * client\n         *   .send('hello', {some: 'payload'})\n         *   .then((data) => {\n         *     console.log('Sent and got the response', data);\n         *   })\n         *   .catch((err) => {\n         *     if (err.code == Client.ErrorCode.MESSAGE_REJECTED) {\n         *       console.log('Message rejected by server', err.payload);\n         *     } else if (err.code == Client.ErrorCode.MESSAGE_TIMEOUT) {\n         *       console.log('Server did not responded, timeout exceeded');\n         *     } else {\n         *       console.log('Could not send message', err);\n         *     }\n         *   });\n         */\n\n    }, {\n        key: 'send',\n        value: function send(name, payload, opt_timeout) {\n            // This method is for external usage!\n            if (this.state != Client.State.CONNECTED) {\n                return Promise.reject(new LineError(Client.ErrorCode.DISCONNECTED, 'Could not send message, client is not connected.'));\n            }\n\n            try {\n                var message = new Message({ name: name, payload: payload });\n                return this.send_(message, opt_timeout);\n            } catch (err) {\n                // `err` can only be Message.ErrorCode.INVALID_JSON\n                return Promise.reject(new LineError(Client.ErrorCode.INVALID_JSON, 'Could not send message, \"payload\" stringify error. Probably circular json issue.'));\n            }\n        }\n\n        /**\n         * Sends a message to server without waiting its response. This method returns a promise\n         * that resolves with nothing if the message is successfully sent.\n         *\n         * Rejections:\n         * - `Client.ErrorCode.INVALID_JSON`: Could not stringify the message payload. Probably circular json.\n         * - `Client.ErrorCode.DISCONNECTED`: Client is not connected or connection is closing\n         * - `Client.ErrorCode.WEBSOCKET_ERROR`: Native websocket error (INVALID_STATE_ERR or SYNTAX_ERR)\n         *\n         * @param {string} name\n         * @param {any=} payload\n         * @returns {Promise}\n         * @example\n         * client\n         *   .sendWithoutResponse('hello', {some: data})\n         *   .then(() => {\n         *     console.log('Message is sent');\n         *   })\n         *   .catch((err) => {\n         *     console.log('Could not send message');\n         *   });\n         */\n\n    }, {\n        key: 'sendWithoutResponse',\n        value: function sendWithoutResponse(name, payload) {\n            // This method is for external usage!\n            if (this.state != Client.State.CONNECTED) {\n                return Promise.reject(new LineError(Client.ErrorCode.DISCONNECTED, 'Could not send message, client is not connected.'));\n            }\n\n            try {\n                var message = new Message({ name: name, payload: payload }); // Can throw Message.ErrorCode.INVALID_JSON\n                return this.sendWithoutResponse_(message);\n            } catch (err) {\n                // `err` can only be Message.ErrorCode.INVALID_JSON\n                return Promise.reject(new LineError(Client.ErrorCode.INVALID_JSON, 'Could not send message, \"payload\" stringify error. Probably circular json issue.'));\n            }\n        }\n\n        /**\n         * Base method for sending a message with timeout. Please favor this method internally\n         * instead of using `send` method.\n         *\n         * Rejections:\n         * - `Client.ErrorCode.MESSAGE_REJECTED`: Message is explicitly rejected by the server.\n         * - `Client.ErrorCode.MESSAGE_TIMEOUT`: Message response did not arrived, timeout exceeded.\n         * - `Client.ErrorCode.DISCONNECTED`: Client is not connected or connection is closing\n         * - `Client.ErrorCode.WEBSOCKET_ERROR`: Native websocket error (INVALID_STATE_ERR or SYNTAX_ERR)\n         *\n         * @param {Message} message\n         * @param {number=} opt_timeout\n         * @returns {Promise}\n         * @ignore\n         */\n\n    }, {\n        key: 'send_',\n        value: function send_(message, opt_timeout) {\n            var _this9 = this;\n\n            var timeout = isInteger(opt_timeout) && opt_timeout >= 0 ? opt_timeout : this.options.responseTimeout;\n            message.setId();\n\n            var deferred = this.deferreds_[message.id] = new Deferred({\n                onExpire: function onExpire() {\n                    delete _this9.deferreds_[message.id];\n                },\n                timeout: timeout\n            });\n\n            return this.sendWithoutResponse_(message).then(function () {\n                return deferred;\n            }).catch(function (err) {\n                deferred.dispose();\n\n                // Convert expired -> timeout error\n                if (err instanceof LineError && err.code == Deferred.ErrorCode.EXPIRED) {\n                    throw new LineError(Client.ErrorCode.MESSAGE_TIMEOUT, 'Message timeout! Its response did not recived after ' + timeout + ' ms');\n                }\n\n                throw err;\n            });\n        }\n\n        /**\n         * Base method for sending a message without response. Please favor this method internally\n         * instead of using `sendWithoutResponse` method.\n         *\n         * Rejections:\n         * - `Client.ErrorCode.DISCONNECTED`: Client is not connected or connection is closing\n         * - `Client.ErrorCode.WEBSOCKET_ERROR`: Native websocket error (INVALID_STATE_ERR or SYNTAX_ERR)\n         *\n         * @param {Message} message\n         * @returns {Promise}\n         * @ignore\n         */\n\n    }, {\n        key: 'sendWithoutResponse_',\n        value: function sendWithoutResponse_(message) {\n            var _this10 = this;\n\n            if (!this.ws_ || this.ws_.readyState != 1) {\n                return Promise.reject(new LineError(Client.ErrorCode.DISCONNECTED, 'Could not send message, there is no open connection.'));\n            }\n\n            return new Promise(function (resolve, reject) {\n                var messageStr = message.toString();\n\n                try {\n                    debug('Sending message: ' + messageStr);\n                    _this10.ws_.send(messageStr); // Can throw INVALID_STATE_ERR, SYNTAX_ERR\n                    resolve();\n                } catch (err) {\n                    reject(new LineError(Client.ErrorCode.WEBSOCKET_ERROR, 'Could not send message. Either socket is not connected or syntax error, check payload.', err));\n                }\n            });\n        }\n\n        /**\n         * Sends a ping message to server, if it's failed, the connection\n         * will be closed and will retry to connect again. Server and client ping each\n         * other automatically with an interval.\n         *\n         * @returns {Promise}\n         */\n\n    }, {\n        key: 'ping',\n        value: function ping() {\n            var _this11 = this;\n\n            var currentSocket = this.ws_;\n\n            debug('Pinging...');\n            return this.send_(new Message({ name: Message.Name.PING })).catch(function (err) {\n                // If socket is changed, dismiss\n                if (_this11.ws_ != currentSocket) {\n                    debug('Auto-ping failed, but socket is also changed, dismissing...');\n                    return;\n                }\n\n                // No matter what error is, start disconnection process\n                debug('Auto-ping failed, manually disconnecting...');\n                _this11.disconnect(CloseStatus.PING_FAILED.code, 'Auto ping failed', true);\n                throw new LineError(Client.ErrorCode.PING_ERROR, 'Ping failed, disconnecting...', err);\n            });\n        }\n\n        /**\n         * On uptime tick event handler. Check current state and push a marker to buffer.\n         *\n         * @ignore\n         */\n\n    }, {\n        key: 'uptimeTick_',\n        value: function uptimeTick_() {\n            debug('Uptime Tick');\n            this.uptimeBuffer_.push(this.state == Client.State.CONNECTED);\n\n            if (this.uptimeBuffer_.length > this.uptimeBufferLength_) {\n                this.uptimeBuffer_.splice(0, this.uptimeBufferLength_ - this.uptimeBuffer_.length);\n            }\n        }\n\n        /**\n         * Calculates (connection) uptime for last `options.uptime.window` (default 5 minutes)\n         * with `options.uptime.interval` (default 5 seconds) interval. Returns a number between\n         * 0 and 1. If `options.uptime` is false, this method returns nothing.\n         *\n         * @returns {number?}\n         */\n\n    }, {\n        key: 'getUptime',\n        value: function getUptime() {\n            if (!this.options.uptime) return;\n            if (this.uptimeBuffer_.length == 0) return 0;\n            return this.uptimeBuffer_.filter(function (val) {\n                return val;\n            }).length / this.uptimeBuffer_.length;\n        }\n\n        /**\n         * Disposes the client.\n         *\n         * @returns {Promise}\n         */\n\n    }, {\n        key: 'dispose',\n        value: function dispose() {\n            var _this12 = this;\n\n            return new Promise(function (resolve) {\n                debug('Disposing...');\n\n                switch (_this12.state) {\n                    case Client.State.CONNECTING:\n                    case Client.State.HANDSHAKING:\n                    case Client.State.CONNECTED:\n                        _this12.once(Client.Event.DISCONNECTED, function () {\n                            _this12.removeAllListeners();\n                            _this12.uptimeBuffer_ = [];\n                            if (_this12.uptimeInterval_) clearInterval(_this12.uptimeInterval_);\n                            debug('Disposed!');\n                            resolve();\n                        });\n\n                        _this12.disconnect(CloseStatus.DISPOSED.code, CloseStatus.DISPOSED.reason);\n                        break;\n\n                    case Client.State.READY:\n                    case Client.State.DISCONNECTING:\n                    case Client.State.DISCONNECTED:\n                        _this12.resetReconnectState_();\n                        _this12.removeAllListeners();\n                        _this12.uptimeBuffer_ = [];\n                        if (_this12.uptimeInterval_) clearInterval(_this12.uptimeInterval_);\n                        debug('Disposed!');\n                        resolve();\n                        break;\n                }\n            });\n        }\n\n        /**\n         * Reject all the awaiting deferred with given error.\n         *\n         * @param {Error} err An error object to reject all awaiting deferreds.\n         * @ignore\n         */\n\n    }, {\n        key: 'rejectAllDeferreds_',\n        value: function rejectAllDeferreds_(err) {\n            forEach(this.deferreds_, function (deferred) {\n                return deferred.reject(err);\n            });\n            this.deferreds_ = {};\n        }\n\n        /**\n         * Resets the reconnection state.\n         *\n         * @ignore\n         */\n\n    }, {\n        key: 'resetReconnectState_',\n        value: function resetReconnectState_() {\n            debug('Resetting reconnection state...');\n            if (this.reconnectState_.timeout) clearTimeout(this.reconnectState_.timeout);\n            this.reconnectState_ = { disabled: false, attempt: 0, timeout: null };\n        }\n    }]);\n\n    return Client;\n}(EventEmitterExtra);\n\nClient.ws2http = function (url) {\n    var rv = void 0;\n    var mapping = {\n        'ws://': 'http://',\n        'wss://': 'https://'\n    };\n    forEach(mapping, function (replace, target) {\n        if (url.indexOf(target) != 0) return;\n        rv = replace + url.substr(target.length);\n    });\n    return rv;\n};\n\nClient.http2ws = function (url) {\n    var rv = void 0;\n    var mapping = {\n        'http://': 'ws://',\n        'https://': 'wss://'\n    };\n    forEach(mapping, function (replace, target) {\n        if (url.indexOf(target) != 0) return;\n        rv = replace + url.substr(target.length);\n    });\n    return rv;\n};\n\nClient.fetchResponseUrl = function (url) {\n    var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3000;\n\n    return new Deferred({\n        timeout: timeout,\n        handler: function handler(deferred) {\n            var req = new XMLHttpRequest();\n            req.addEventListener('error', function () {\n                return deferred.reject(new Error('Native XMLHttpRequest error'));\n            });\n            req.addEventListener('abort', function () {\n                return deferred.reject(new Error('Aborted XMLHttpRequest'));\n            });\n            req.addEventListener('load', function () {\n                return deferred.resolve(req.responseURL);\n            });\n            req.open('HEAD', url);\n\n            try {\n                req.send();\n            } catch (err) {\n                deferred.reject(err);\n            }\n        }\n    });\n};\n\n// Expose internal classes\nClient.Message = Message;\nClient.Error = LineError;\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nClient.ErrorCode = {\n    /**\n     * When constructing `new Client()`, this error could be thrown.\n     */\n    INVALID_OPTIONS: 'cInvalidOptions',\n    /**\n     * Indicates an error while json parsing/stringify.\n     */\n    INVALID_JSON: 'cInvalidJSON',\n    /**\n     * This error can be emitted in `Client.Events.CONNECTING_ERROR` event.\n     * It indicates an operational error during the handshake. If `options.reconnect` is true,\n     * the client will try to reconnect again.\n     */\n    HANDSHAKE_ERROR: 'cHandshakeError',\n    /**\n     * This error can be emitted in `Client.Events.CONNECTING_ERROR` event.\n     * It indicates that server is explicitly rejected the handshake, which probably means\n     * client's handshake payload is not accepted by server.\n     */\n    HANDSHAKE_REJECTED: 'cHandshakeRejected',\n    /**\n     * This error can be seen in rejection of `client.send()` method. This means the\n     * message is reached to server but the timeout is exceeded.\n     */\n    MESSAGE_TIMEOUT: 'cMessageTimeout',\n    /**\n     * This error can be seen in rejection of `client.send()` method, which again indicates that\n     * server is explicitly rejected the message.\n     */\n    MESSAGE_REJECTED: 'cMessageRejected',\n    /**\n     * When the response of a message failed to send to server, this error\n     * will be emitted in `Client.Event.ERROR` event.\n     */\n    MESSAGE_NOT_RESPONDED: 'cMessageNotResponded',\n    /**\n     * This error is for native websocket errors. Native error is wrapped by `LineError`\n     * and can be accessible under `err.payload`.\n     */\n    WEBSOCKET_ERROR: 'cWebsocketError',\n    /**\n     * When disconnect timeout is exceed, this error will be emited in\n     * `Client.Events.ERROR` event. After this event, the disconnect\n     * procedure will be started forcefully.\n     */\n    DISCONNECT_TIMEOUT: 'cDisconnectError',\n    /**\n     * This error can be seen in rejection of `client.ping()` method. After this error,\n     * client will be disconnected.\n     */\n    PING_ERROR: 'cPingError',\n    /**\n     * This error indicates the action is prohibited because client is not\n     * in connected state or connection is closing.\n     */\n    DISCONNECTED: 'cDisconnected'\n};\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nClient.State = {\n    /**\n     * `ready`\n     */\n    READY: 'ready',\n    /**\n     * `connecting`\n     */\n    CONNECTING: 'connecting',\n    /**\n     * `handshaking`\n     */\n    HANDSHAKING: 'handshaking',\n    /**\n     * `connected`\n     */\n    CONNECTED: 'connected',\n    /**\n     * `disconnecting`\n     */\n    DISCONNECTING: 'disconnecting',\n    /**\n     * `disconnected`\n     */\n    DISCONNECTED: 'disconnected'\n};\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nClient.Event = {\n    /**\n     * `_connecting`\n     */\n    CONNECTING: '_connecting',\n    /**\n     * `_connecting_error`\n     */\n    CONNECTING_ERROR: '_connecting_error',\n    /**\n     * `_connected`\n     */\n    CONNECTED: '_connected',\n    /**\n     * `_disconnecting`\n     */\n    DISCONNECTING: '_disconnecting',\n    /**\n     * `_disconnected`\n     */\n    DISCONNECTED: '_disconnected',\n    /**\n     * `_error`\n     */\n    ERROR: '_error'\n};\n\nmodule.exports = Client;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"ws\");\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\"use strict\";\n'use strict';\n\nmodule.exports = {\n    INTERNAL_ERROR: { code: 4200, reason: 'Internal error' },\n    PING_FAILED: { code: 4201, reason: 'Ping failed' },\n    HANDSHAKE_FAILED: { code: 4202, reason: 'Handshake failed' },\n    HANDSHAKE_REJECTED: { code: 4203, reason: 'Handshake rejected' },\n    DISCONNECT_TIMEOUT: { code: 4204, reason: 'Disconnect timeout' },\n    DISPOSED: { code: 4205, reason: 'Client disposed' },\n    UNKNOWN_ERROR: { code: 4299, reason: 'Unknown error' }\n};\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar isUndefined = __webpack_require__(19);\nvar isString = __webpack_require__(5);\nvar isObject = __webpack_require__(4);\nvar isFunction = __webpack_require__(16);\nvar values = __webpack_require__(20);\nvar assign = __webpack_require__(1);\n\nvar _require = __webpack_require__(10),\n    generateDummyId = _require.generateDummyId;\n\nvar EventEmitterExtra = __webpack_require__(3);\nvar LineError = __webpack_require__(0);\n\n/**\n * Message class.\n *\n * @private\n * @class Message\n * @extends {EventEmitterExtra}\n */\n\nvar Message = function (_EventEmitterExtra) {\n    _inherits(Message, _EventEmitterExtra);\n\n    _createClass(Message, null, [{\n        key: 'parse',\n        value: function parse(raw) {\n            try {\n                var data = JSON.parse(raw);\n\n                // If error is error-like object, construct real error\n                if (isObject(data.e) && isString(data.e.name) && isString(data.e.message)) {\n                    data.e = assign(new Error(), data.e);\n                }\n\n                return new Message({\n                    name: data.n,\n                    payload: data.p,\n                    err: data.e,\n                    id: data.i\n                });\n            } catch (err) {\n                throw new LineError(Message.ErrorCode.INVALID_JSON, 'Could not parse incoming message.');\n            }\n        }\n    }]);\n\n    function Message(_ref) {\n        var name = _ref.name,\n            payload = _ref.payload,\n            id = _ref.id,\n            err = _ref.err;\n\n        _classCallCheck(this, Message);\n\n        var _this = _possibleConstructorReturn(this, (Message.__proto__ || Object.getPrototypeOf(Message)).call(this));\n\n        try {\n            JSON.stringify(payload);\n            JSON.stringify(err);\n        } catch (err) {\n            throw new LineError(Message.ErrorCode.INVALID_JSON, 'Message payload or error must be json-friendly. Maybe circular json?');\n        }\n\n        _this.name = name;\n        _this.payload = payload;\n        _this.id = id;\n        _this.err = err;\n\n        _this.isResponded_ = false;\n        return _this;\n    }\n\n    _createClass(Message, [{\n        key: 'setId',\n        value: function setId() {\n            var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : generateDummyId();\n\n            this.id = id;\n            return id;\n        }\n    }, {\n        key: 'createResponse',\n        value: function createResponse(err, payload) {\n            return new Message({ name: '_r', payload: payload, err: err, id: this.id });\n        }\n\n        /**\n         * Resolves the message with sending a response back. If the source\n         * does not expecting a response, you don't need to call these methods.\n         *\n         * This method can throw:\n         * - `Message.ErrorCode.MISSING_ID`: Message source is not expecting a response.\n         * - `Message.ErrorCode.ALREADY_RESPONDED`: This message is already responded.\n         * - `Message.ErrorCode.INVALID_JSON`: Could not stringify payload. Probably circular json.\n         *\n         * @param {any=} payload\n         */\n\n    }, {\n        key: 'resolve',\n        value: function resolve(payload) {\n            if (isUndefined(this.id)) {\n                throw new LineError(Message.ErrorCode.MISSING_ID, 'This message could not be resolved (no id)');\n            }\n\n            if (this.isResponded_) {\n                throw new LineError(Message.ErrorCode.ALREADY_RESPONDED, 'This message has already responded');\n            }\n\n            try {\n                JSON.stringify(payload);\n            } catch (err_) {\n                throw new LineError(Message.ErrorCode.INVALID_JSON, 'Message must be resolved with json-friendly payload. Maybe circular json?');\n            }\n\n            this.isResponded_ = true;\n            this.emit('resolved', payload);\n        }\n\n        /**\n         * Rejects the message, with sending error response back to the source.\n         *\n         * This method can throw:\n         * - `Message.ErrorCode.MISSING_ID`: Message source is not expecting a response.\n         * - `Message.ErrorCode.ALREADY_RESPONDED`: This message is already responded.\n         * - `Message.ErrorCode.INVALID_JSON`: Could not stringify payload. Probably circular json.\n         *\n         * @param {any=} err\n         */\n\n    }, {\n        key: 'reject',\n        value: function reject(err) {\n            if (isUndefined(this.id)) {\n                throw new LineError(Message.ErrorCode.MISSING_ID, 'This message could not be rejected (no id)');\n            }\n\n            if (this.isResponded_) {\n                throw new LineError(Message.ErrorCode.ALREADY_RESPONDED, 'This message has already responded');\n            }\n\n            try {\n                JSON.stringify(err);\n            } catch (err_) {\n                throw new LineError(Message.ErrorCode.INVALID_JSON, 'Message must be resolved with json-friendly payload. Maybe circular json?');\n            }\n\n            this.isResponded_ = true;\n            this.emit('rejected', err);\n        }\n    }, {\n        key: 'toString',\n        value: function toString() {\n            var data = { n: this.name };\n\n            if (!isUndefined(this.payload)) data.p = this.payload;\n\n            if (!isUndefined(this.id)) data.i = this.id;\n\n            if (!isUndefined(this.err)) {\n                data.e = this.err instanceof Error ? assign({\n                    name: this.err.name,\n                    message: this.err.message\n                }, this.err) : this.err;\n            }\n\n            // We're sure the data is json-friendly\n            return JSON.stringify(data);\n        }\n    }, {\n        key: 'dispose',\n        value: function dispose() {\n            var _this2 = this;\n\n            var events = this.eventNames();\n            events.forEach(function (event) {\n                return _this2.removeAllListeners(event);\n            });\n        }\n    }]);\n\n    return Message;\n}(EventEmitterExtra);\n\n/**\n * These message names are reserved for internal usage.\n * We recommend to not use any message name starts with `_` (underscore).\n *\n * @static\n * @readonly\n * @enum {string}\n */\n\n\nMessage.Name = {\n    /**\n     * `_r`\n     */\n    RESPONSE: '_r',\n    /**\n     * `_h`\n     */\n    HANDSHAKE: '_h',\n    /**\n     * `_p`\n     */\n    PING: '_p'\n};\n\nMessage.ReservedNames = values(Message.Name);\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nMessage.ErrorCode = {\n    /**\n     * `mInvalidJson`\n     */\n    INVALID_JSON: 'mInvalidJson',\n    /**\n     * `mMissingId`\n     */\n    MISSING_ID: 'mMissingId',\n    /**\n     * `mAlreadyResponded`\n     */\n    ALREADY_RESPONDED: 'mAlreadyResponded'\n};\n\nmodule.exports = Message;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\n\nvar assign = __webpack_require__(1);\n\n// http://stackoverflow.com/a/6248722\nfunction generateDummyId() {\n    var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;\n\n    return (\"0000\" + (Math.random() * Math.pow(36, length) << 0).toString(36)).slice(-length);\n}\n\nmodule.exports = { generateDummyId: generateDummyId };\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"debug\");\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/debounce\");\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/defaultsDeep\");\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/forEach\");\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isBoolean\");\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isFunction\");\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isInteger\");\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isNumber\");\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isUndefined\");\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/values\");\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nglobal.WebSocket = __webpack_require__(7); // Polyfill for extending browser code\nvar Client = __webpack_require__(6);\nvar Deferred = __webpack_require__(2);\n\n/**\n * Polyfill http request for node\n */\nClient.fetchResponseUrl = function (url) {\n    var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3000;\n\n    return new Deferred({\n        timeout: timeout,\n        handler: function handler(deferred) {\n            deferred.resolve({});\n        }\n    });\n};\n\nmodule.exports = Client;\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// client-node.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmory imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmory exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tObject.defineProperty(exports, name, {\n \t\t\tconfigurable: false,\n \t\t\tenumerable: true,\n \t\t\tget: getter\n \t\t});\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 21);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a6554857a3d3b8bc3421","function LineError(code, message, payload) {\n    this.name = 'LineError';\n    this.message = message;\n    this.code = code;\n    this.payload = payload;\n    this.stack = (new Error()).stack;\n}\nLineError.prototype = new Error;\n\n\nmodule.exports = LineError;\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/error.js","module.exports = require(\"lodash/assign\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/assign\"\n// module id = 1\n// module chunks = 0","const LineError = require('./error');\n\n\nclass Deferred {\n    constructor({\n        handler = () => {},\n        onExpire = () => {},\n        timeout = 0\n    } = {}) {\n        this.resolve_ = null;\n        this.reject_ = null;\n\n        this.timeout_ = null;\n        this.timeoutDuration_ = timeout;\n        this.onExpire_ = onExpire;\n        this.isFinished_ = false;\n\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve_ = resolve;\n            this.reject_ = reject;\n\n            try {\n                handler(this);\n            } catch (err) {\n                this.reject(err);\n            }\n        });\n\n        if (timeout > 0) {\n            this.timeout_ = setTimeout(this.expire.bind(this), timeout);\n        }\n    }\n\n\n    resolve(data) {\n        if (this.isFinished_) return;\n\n        this.isFinished_ = true;\n        this.clearTimeout_();\n        this.resolve_(data);\n    }\n\n\n    reject(err) {\n        if (this.isFinished_) return;\n\n        this.isFinished_ = true;\n        this.clearTimeout_();\n        this.reject_(err);\n    }\n\n\n    expire() {\n        this.isFinished_ = true;\n        this.clearTimeout_();\n        this.onExpire_();\n        this.reject_(new LineError(Deferred.ErrorCode.EXPIRED, `Timeout ${this.timeoutDuration_} ms exceed`));\n    }\n\n\n    dispose() {\n        this.isFinished_ = true;\n        this.clearTimeout_();\n    }\n\n\n    then(...args) {\n        return this.promise.then.apply(this.promise, args);\n    }\n\n\n    catch(...args) {\n        return this.promise.catch.apply(this.promise, args);\n    }\n\n\n    clearTimeout_() {\n        if (this.timeout_) {\n            clearTimeout(this.timeout_);\n            this.timeout_ = null;\n        }\n    }\n}\n\n\nDeferred.ErrorCode = {\n    EXPIRED: 'dExpired'\n};\n\n\nmodule.exports = Deferred;\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/deferred.js","module.exports = require(\"event-emitter-extra\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"event-emitter-extra\"\n// module id = 3\n// module chunks = 0","module.exports = require(\"lodash/isObject\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isObject\"\n// module id = 4\n// module chunks = 0","module.exports = require(\"lodash/isString\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isString\"\n// module id = 5\n// module chunks = 0","const Message = require('../lib/message');\nconst EventEmitterExtra = require('event-emitter-extra');\nconst Deferred = require('../lib/deferred');\nconst assign = require('lodash/assign');\nconst forEach = require('lodash/forEach');\nconst debounce = require('lodash/debounce');\nconst isObject = require('lodash/isObject');\nconst isBoolean = require('lodash/isBoolean');\nconst isString = require('lodash/isString');\nconst isNumber = require('lodash/isNumber');\nconst isInteger = require('lodash/isInteger');\nconst defaultsDeep = require('lodash/defaultsDeep');\nconst debug = require('debug')('line:client');\nconst LineError = require('../lib/error');\nconst CloseStatus = require('../lib/closestatus');\n\n\n\n/**\n * Line client class.\n *\n * @class Client\n * @extends {EventEmitterExtra}\n * @param {string=} url Server url, default: `ws://localhost`.\n * @param {Object=} options Options object.\n * @param {Object=} options.handshake Handshake options\n * @param {number=} options.handshake.timeout Handshake timeout duration in milliseconds.\n *      Default: `30000` (30 seconds).\n * @param {any=} options.handshake.payload Handshake payload that will be send to server.\n * @param {number=} options.responseTimeout This is the timeout for getting response from the server\n *      when using `client.send()` method. Default: `10000` (10 seconds). Note that this option is ineffective for\n *      `client.sendWithoutResponse()` method.\n * @param {number=} options.disconnectTimeout In some browsers, `close` frame is not fired immediately.\n *      This timeout is for starting `close` procedure even if close frame is not arrived. Default: `5000` (5 seconds).\n * @param {number=} options.pingInterval Pinging interval. Default: `20000` (20 seconds).\n * @param {boolean=} options.reconnect Whether try to reconnect server after unexpected disconnection,\n *      default `true`.\n * @param {Object=} options.reconnectOptions Reconnection options.\n * @param {number=} options.reconnectOptions.initialDelay In milliseconds. Default: `1000` (1 second).\n * @param {number=} options.reconnectOptions.multiply Default: `1.5`\n * @param {number=} options.reconnectOptions.maxDelay In milliseconds. Default: `30000`\n * @param {number=} options.reconnectOptions.randomness Random delay multiplier. Default: `0.5`\n * @param {boolean=} options.uptime Whether keep & calculate uptime, default `false`.\n *      If this option is not true, `client.getUptime()` returns undefined.\n * @param {Object=} options.uptimeOptions Uptime options.\n * @param {number=} options.uptimeOptions.interval Uptime checking interval. In milliseconds. Default: `5000` (5 seconds).\n * @param {number=} options.uptimeOptions.window Uptime checking window length. In milliseconds. Default: `300000` (5 minutes)\n * @param {boolean=} options.followRedirections Attempt to follow 30X redirections. If this options is set, after\n *      a native websocket connection error, line will try to make a http request to server url. If it is success,\n *      final response url will be used as server after couple of connection attempts. Default: `false`\n * @property {string} url Server url\n * @property {string} id Unique connection id assigned by the server. It will be accessible after handshake.\n * @property {Client.State} state Connection state\n * @example\n * // Add line-client to your html document\n * <script src=\"./node_modules/line-socket/dist/client-web-globals.js\"></script>\n *\n * // For web browsers (consuming as a commonjs module)\n * const LineClient = require('line-socket/client-web');\n *\n * // For node.js\n * const LineClient = require('line-socket/client-node');\n *\n * // Usage\n * const client = new LineClient('ws://localhost:8080');\n * client.connect();\n */\nclass Client extends EventEmitterExtra {\n    constructor(url = 'ws://localhost', options = {}) {\n        super();\n\n        if (!isString(url) || url.trim().length == 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, 'Url parameter must be string and cannot be empty');\n\n        if (!isObject(options))\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, 'Options parameter must be an object');\n\n        this.url = url.trim();\n        this.urlFollowed = null;\n        this.options = defaultsDeep(options, {\n            handshake: {\n                timeout: 30000,\n                payload: undefined\n            },\n            responseTimeout: 10000,\n            disconnectTimeout: 5000,\n            pingInterval: 20000,\n            reconnect: true,\n            reconnectOptions: {\n                initialDelay: 1000,\n                multiply: 1.5,\n                maxDelay: 30000,\n                randomness: 0.5\n            },\n            uptime: false,\n            uptimeOptions: {\n                interval: 5000,\n                window: 300000\n            },\n            followRedirections: false\n        });\n\n\n        if (!isObject(this.options.handshake))\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.handshake\" must be an object`);\n\n        if (!isInteger(this.options.handshake.timeout) || this.options.handshake.timeout < 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.handshake.timeout\" must be a positive integer or zero`);\n\n        try {\n            JSON.stringify(this.options.handshake.payload);\n        } catch (err) {\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.handshake.payload\" must be json friendly, probably circular dependency?`);\n        }\n\n        if (!isInteger(this.options.responseTimeout) || this.options.responseTimeout < 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.responseTimeout\" must be a positive integer or zero`);\n\n        if (!isInteger(this.options.disconnectTimeout) || this.options.disconnectTimeout < 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.disconnectTimeout\" must be a positive integer or zero`);\n\n        if (!isInteger(this.options.pingInterval) || this.options.pingInterval < 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.pingInterval\" must be a positive integer or zero`);\n\n        if (!isBoolean(this.options.reconnect))\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.reconnect\" must be a boolean`);\n\n        if (!isObject(this.options.reconnectOptions))\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.reconnectOptions\" must be an object`);\n\n        if (!isInteger(this.options.reconnectOptions.initialDelay) || this.options.reconnectOptions.initialDelay <= 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.reconnectOptions.initialDelay\" must be a positive integer`);\n\n        if (!isNumber(this.options.reconnectOptions.multiply) || this.options.reconnectOptions.multiply < 1)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.reconnectOptions.multiply\" must be a number >= 1`);\n\n        if (!isInteger(this.options.reconnectOptions.maxDelay) || this.options.reconnectOptions.maxDelay <= 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.reconnectOptions.maxDelay\" must be a positive integer`);\n\n        if (this.options.reconnectOptions.maxDelay < this.options.reconnectOptions.initialDelay)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.reconnectOptions.maxDelay\" must be a greater than initial delay`);\n\n        if (!isNumber(this.options.reconnectOptions.randomness) || this.options.reconnectOptions.randomness < 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.reconnectOptions.randomness\" must be a positive number or zero`);\n\n        if (!isBoolean(this.options.uptime))\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.uptime\" must be a boolean`);\n\n        if (!isObject(this.options.uptimeOptions))\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.uptimeOptions\" must be an object`);\n\n        if (!isInteger(this.options.uptimeOptions.interval) || this.options.uptimeOptions.interval <= 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.uptimeOptions.interval\" must be a positive integer`);\n\n        if (!isInteger(this.options.uptimeOptions.window) || this.options.uptimeOptions.window <= 0)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.uptimeOptions.window\" must be a positive integer`);\n\n        if (this.options.uptimeOptions.window < this.options.uptimeOptions.interval)\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.uptimeOptions.window\" must be a greater than interval`);\n\n        if (!isBoolean(this.options.followRedirections))\n            throw new LineError(Client.ErrorCode.INVALID_OPTIONS, `\"options.followRedirections\" must be a boolean`);\n\n        this.ws_ = null;\n        this.id = null;\n        this.state = Client.State.READY;\n\n        this.reconnectState_ = {disabled: false, attempt: 0, timeout: null};\n        this.deferreds_ = {};\n        this.disconnectTimeout_ = null;\n        this.uptimeBuffer_ = [];\n        this.uptimeBufferLength_ = Math.round(this.options.uptimeOptions.window / this.options.uptimeOptions.interval);\n        this.uptimeInterval_ = options.uptime ? setInterval(this.uptimeTick_.bind(this), this.options.uptimeOptions.interval) : null;\n        this.autoPing_ = debounce(() => {});\n\n        if (this.options.pingInterval > 0) {\n            this.autoPing_ = debounce(() => {\n                this\n                    .ping()\n                    .then(() => {\n                        // Ping successfull. If we still connected, debounce next one!\n                        if (this.options.pingInterval > 0 && this.state == Client.State.CONNECTED) {\n                            this.autoPing_(); // Recursive\n                        }\n                    })\n                    .catch(() => { /* ping() method handles disconnection the logic itself */ });\n            }, this.options.pingInterval);\n        }\n    }\n\n\n    /**\n     * Starts the connection procedure.\n     *\n     * If server url is invalid or there is a security error,\n     * this method will throw `Client.ErrorCode.WEBSOCKET_ERROR`.\n     *\n     * When procedure is started, `Client.Event.CONNECTING` event will be emitted.\n     *\n     * If an error occured during connection or handshake, the client will emit `Client.Event.CONNECTING_ERROR`.\n     *\n     * If connection is failed for some reason and `options.reconnect` is `true`. The client will\n     * retry to connect.\n     *\n     * @returns {boolean}\n     * @example\n     * client.connect();\n     *\n     * client.on(Client.Event.CONNECTED, () => {\n     *   console.log('Client connected.');\n     * });\n     *\n     * client.on(Client.Event.CONNECTING_ERROR, (err) => {\n     *   console.log('Could not connect!', err);\n     * });\n     */\n    connect() {\n        switch (this.state) {\n            case Client.State.DISCONNECTED:\n            case Client.State.READY:\n                let url = this.url;\n\n                if (this.options.followRedirections && this.urlFollowed) {\n                    url = this.urlFollowed;\n                    debug(`Following redirection \"${this.url}\" -> \"${this.urlFollowed}\"`);\n                }\n\n                debug(`Connecting to \"${url}\" ...`);\n\n                try {\n                    this.reconnectState_.disabled = false;\n                    this.ws_ = new WebSocket(url);\n                    this.bindEvents_();\n                    this.state = Client.State.CONNECTING;\n                    this.emit(Client.Event.CONNECTING);\n                    return true;\n                } catch (err) {\n                    throw new LineError(\n                        Client.ErrorCode.WEBSOCKET_ERROR,\n                        `Native websocket error. Invalid url or security error`,\n                        err\n                    );\n                }\n\n            default:\n                debug(`Ignoring connect() call, client is in \"${this.state}\" state`);\n                return false;\n        }\n    }\n\n\n    /**\n     * TODO: This is an experimental method currently, it's just used in tests.\n     * DO NOT use in production.\n     *\n     * @returns {Promise}\n     * @ignore\n     */\n    connectAsync() {\n        return new Promise((resolve, reject) => {\n            this.connect(); // Can throw WEBSOCKET_ERROR or ignore silently\n\n            let removeListeners = () => {};\n\n            const onConnectingError = (err) => {\n                removeListeners();\n                reject(err);\n            };\n\n            const onConnected = (data) => {\n                removeListeners();\n                resolve(data);\n            };\n\n            const onDisconnected = (e) => {\n                removeListeners();\n                reject(new LineError(Client.ErrorCode.DISCONNECTED, `Client disconnected`, e));\n            };\n\n            removeListeners = () => {\n                this.removeListener(Client.Event.CONNECTING_ERROR, onConnectingError);\n                this.removeListener(Client.Event.CONNECTED, onConnected);\n                this.removeListener(Client.Event.DISCONNECTED, onDisconnected);\n            }\n\n            this.once(Client.Event.CONNECTING_ERROR, onConnectingError);\n            this.once(Client.Event.CONNECTED, onConnected);\n            this.once(Client.Event.DISCONNECTED, onDisconnected);\n        });\n    }\n\n\n    /**\n     * Gracefully closes the connection. This method can throw `Client.ErrorCode.WEBSOCKET_ERROR` if\n     * provided parameters are invalid. If websocket is not closed after `options.disconnectTimeout` ms,\n     * the client will start the disconnection procedure forcefully.\n     *\n     * @param {number=} code A numeric value indicating the status code explaining why the connection is being closed.\n     *      Must be between 1000-4999. Default is 1000.\n     * @param {any=} reason A human-readable string explaining why the connection is closing. This string must\n     *      be no longer than 123 bytes of UTF-8 text (not characters).\n     * @param {boolean=} opt_retry Whether retry to connect after disconnection.\n     * @returns {boolean}\n     * @example\n     * client.disconnect();\n     *\n     * client.on(Client.Event.DISCONNECTED, (e) => {\n     *   console.log('Disconnected', e.code, e.reason);\n     * });\n     */\n    disconnect(code, reason, opt_retry) {\n        switch (this.state) {\n            case Client.State.CONNECTING:\n            case Client.State.HANDSHAKING:\n            case Client.State.CONNECTED:\n                debug(`Disconnecting... (State: ${this.state})`);\n\n                try {\n                    this.ws_.close(code || 1000, reason); // Can throw INVALID_ACCESS_ERR, SYNTAX_ERR\n                    debug(`Websocket is closed`);\n                    this.reconnectState_.disabled = !opt_retry;\n                    this.rejectAllDeferreds_(new LineError(Client.ErrorCode.DISCONNECTED, 'Disconnect procedure started'));\n                    this.autoPing_.cancel();\n\n                    // Wait \"close\" event for some time, then manually start onClose procedure\n                    if (this.disconnectTimeout_) clearTimeout(this.disconnectTimeout_);\n                    if (this.options.disconnectTimeout) {\n                        this.disconnectTimeout_ = setTimeout(() => {\n                            debug(`Disconnect timeout exceeded, force disconnecting...`);\n\n                            this.emit(Client.Event.ERROR, new LineError(\n                                Client.ErrorCode.DISCONNECT_TIMEOUT,\n                                'Disconnect timeout exceeded, force disconnecting...'\n                            ));\n\n                            this.onClose_(CloseStatus.DISCONNECT_TIMEOUT);\n\n                            clearTimeout(this.disconnectTimeout_);\n                        }, this.options.disconnectTimeout);\n                    }\n\n                    this.state = Client.State.DISCONNECTING;\n                    this.emit(Client.Event.DISCONNECTING);\n\n                    return true;\n                } catch (err) {\n                    throw new LineError(\n                        Client.ErrorCode.WEBSOCKET_ERROR,\n                        'Could not disconnect. Invalid code or reason, check payload.',\n                        err\n                    );\n                }\n\n            default:\n                debug(`Ignoring disconnect() call, client is in \"${this.state}\" state.`);\n                return false;\n        }\n    }\n\n\n    /**\n     * TODO: This is an experimental method currently, it's just used in tests.\n     * DO NOT use in production.\n     *\n     * @returns {Promise}\n     * @ignore\n     */\n    disconnectAsync(code, reason, retry) {\n        return new Promise((resolve, reject) => {\n            this.disconnect(code, reason, retry); // Can throw WEBSOCKET_ERROR or ignore silently\n\n            const onDisconnected = (e) => {\n                // this.removeListener(Client.Event.DISCONNECTED, onDisconnected);\n                resolve(e);\n            };\n\n            this.once(Client.Event.DISCONNECTED, onDisconnected);\n        });\n    }\n\n\n    /**\n     * Binds websocket events\n     *\n     * @ignore\n     */\n    bindEvents_() {\n        debug('Binding native event handlers.');\n        this.ws_.onopen = this.onOpen_.bind(this);\n        this.ws_.onclose = this.onClose_.bind(this);\n        this.ws_.onerror = this.onError_.bind(this);\n        this.ws_.onmessage = this.onMessage_.bind(this);\n    }\n\n\n    /**\n     * Unbinds websocket events\n     *\n     * @ignore\n     */\n    unBindEvents_() {\n        if (!this.ws_) return;\n        debug('Unbinding native event handlers.');\n        this.ws_.onopen = function() {};\n        this.ws_.onclose = function() {};\n        this.ws_.onerror = function() {};\n        this.ws_.onmessage = function() {};\n    }\n\n\n    /**\n     * Native \"open\" event handler. At this time we will start the handshakin process.\n     *\n     * @ignore\n     */\n    onOpen_() {\n        debug('Native \"open\" event received, starting handshake process');\n\n        this.state = Client.State.HANDSHAKING;\n        const message = new Message({\n            name: Message.Name.HANDSHAKE,\n            payload: this.options.handshake.payload // We're sure that this is json friendly\n        });\n\n        this\n            .send_(message, this.options.handshake.timeout)\n            .then(data => {\n                // Message is sent and we got the response!\n                if (!isObject(data)) {\n                    debug('Unexpected handshake response!?');\n\n                    this.emit(Client.Event.CONNECTING_ERROR, new LineError(\n                        Client.ErrorCode.HANDSHAKE_ERROR,\n                        'Handshake response is not object. Aborting handshake...',\n                        data\n                    ));\n\n                    this.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Handshake failed, unexpected handshake response.', true);\n                    return;\n                }\n\n                debug('Handshake successful.');\n                this.resetReconnectState_();\n                this.id = data.id;\n                this.state = Client.State.CONNECTED;\n                this.autoPing_(); // Start auto-ping\n\n                debug('Emitting \"connected\" event...');\n                this.emit(Client.Event.CONNECTED, data.payload);\n            })\n            .catch(err => {\n                if (err instanceof LineError) {\n                    switch (err.code) {\n                        case Client.ErrorCode.DISCONNECTED:\n                            debug('Handshake failed, connection lost (disconnected)');\n                            this.emit(Client.Event.CONNECTING_ERROR, new LineError(\n                                Client.ErrorCode.HANDSHAKE_ERROR,\n                                `Connection lost during handshake.`\n                            ));\n                            return;\n\n                        case Client.ErrorCode.MESSAGE_TIMEOUT:\n                            // TODO: Try again maybe?\n                            debug('Handshake failed, message timeout');\n                            this.emit(Client.Event.CONNECTING_ERROR, new LineError(\n                                Client.ErrorCode.HANDSHAKE_ERROR,\n                                'Handshake failed, request timeout.'\n                            ));\n                            return this.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Handshake failed, request timeout.', true);\n\n                        case Client.ErrorCode.MESSAGE_REJECTED:\n                            debug('Handshake REJECTED!');\n                            this.emit(Client.Event.CONNECTING_ERROR, new LineError(\n                                Client.ErrorCode.HANDSHAKE_REJECTED,\n                                'Handshake rejected, check payload for further details.',\n                                err && err.payload\n                            ));\n                            return this.disconnect(CloseStatus.HANDSHAKE_REJECTED.code, 'Handshake rejected', true);\n\n                        case Client.ErrorCode.WEBSOCKET_ERROR:\n                            debug('Handshake failed, native websocket error');\n                            this.emit(Client.Event.CONNECTING_ERROR, new LineError(\n                                Client.ErrorCode.HANDSHAKE_ERROR,\n                                `Handshake failed. Websocket protocol error, check payload.`,\n                                err && err.payload\n                            ));\n                            return this.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Handshake failed, native websocket error', true);\n\n                        default:\n                            debug('Handshake failed, unknown line error', err);\n                            return this.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Unknown line error', true);\n                    }\n                }\n\n                // Unknown error\n                debug('Handshake failed, unknown error', err);\n                return this.disconnect(CloseStatus.HANDSHAKE_FAILED.code, 'Unknown error', true);\n            });\n    }\n\n\n    /**\n     * Native \"close\" event handler.\n     *\n     * @param {Event} closeEvent Native close event.\n     * @param {number} closeEvent.code Close status code sent by server.\n     * @param {string=} closeEvent.reason Human readable close reason.\n     * @ignore\n     */\n    onClose_(closeEvent) {\n        debug(`Native \"close\" event received in \"${this.state}\" state (code: ${closeEvent.code}, reason: ${closeEvent.reason})`);\n\n        if (this.disconnectTimeout_) clearTimeout(this.disconnectTimeout_);\n        this.rejectAllDeferreds_(new LineError(Client.ErrorCode.DISCONNECTED, 'Client is disconnected'));\n        this.unBindEvents_();\n        this.autoPing_.cancel();\n\n        this.id = null;\n        this.ws_ = null;\n\n        debug('Emitting \"disconnected\" event...');\n        this.state = Client.State.DISCONNECTED;\n        this.emit(Client.Event.DISCONNECTED, closeEvent);\n\n        if (this.options.reconnect && !this.reconnectState_.disabled) {\n            let timeout = this.options.reconnectOptions.initialDelay *\n                Math.max(this.options.reconnectOptions.multiply * this.reconnectState_.attempt, 1);\n            timeout = Math.min(timeout, this.options.reconnectOptions.maxDelay);\n            timeout += Math.round(Math.random() * this.options.reconnectOptions.randomness * timeout);\n\n            debug(`Will try to reconnect in ${timeout} ms`);\n\n            this.reconnectState_.timeout && clearTimeout(this.reconnectState_.timeout);\n            this.reconnectState_.timeout = setTimeout(() => {\n                this.reconnectState_.attempt++;\n                this.connect();\n            }, timeout);\n        }\n    }\n\n\n    /**\n     * Native \"error\" handler. A \"close\" event will ALWAYS follow this event.\n     * See: https://www.w3.org/TR/websockets/#closeWebSocket\n     * So, if client state is connecting/handshaking, emit `CONNECTING_ERROR`.\n     *\n     * @param {Error} err Native error object.\n     * @ignore\n     */\n    onError_(err) {\n        debug(`Native \"error\" event received in \"${this.state}\" state.`);\n        let eventName = Client.Event.ERROR;\n\n        if (this.state == Client.State.CONNECTING || this.state == Client.State.HANDSHAKING) {\n            eventName = Client.Event.CONNECTING_ERROR;\n        }\n\n        this.emit(eventName, new LineError(\n            Client.ErrorCode.WEBSOCKET_ERROR,\n            `Native websocket error occured, check payload.`,\n            err\n        ));\n\n        // For 30X redirects, we get this error: \"Unexpected response code: 30X\"\n        // Attempt to make a http request to server url (this request will follow redirections).\n        // If it is successful, use the final response url as websocket url\n        if (this.options.followRedirections) {\n            debug('Attempting to follow redirections...');\n            const httpUrl = Client.ws2http(this.url);\n\n            if (httpUrl) {\n                debug(`Making a request to \"${httpUrl}\" for following`);\n                Client\n                    .fetchResponseUrl(httpUrl)\n                    .then((httpUrlFollowed) => {\n                        const wsUrl = Client.http2ws(httpUrlFollowed);\n                        if (!wsUrl) return debug(`Could not convert http url \"${httpUrlFollowed}\" to ws`);\n                        if (this.urlFollowed == wsUrl) return;\n                        debug(`Updating followed url to \"${wsUrl}\"`);\n                        this.urlFollowed = wsUrl;\n                    })\n                    .catch(err => debug('Could not follow redirection, ignoring...', err));\n            } else {\n                debug(`Could not convert ws url to http`);\n            }\n        }\n    }\n\n\n    /**\n     * Native \"message\" handler.\n     *\n     * @param {Event} e Native message event.\n     * @param {string} e.data Raw message data.\n     * @ignore\n     */\n    onMessage_(e) {\n        debug(`Native \"message\" event received in \"${this.state}\" state.`);\n        let message;\n\n        // A message is recieved, debounce our auto-ping handler\n        if (this.state == Client.State.CONNECTED) {\n            this.autoPing_();\n        }\n\n        /**\n         * Try to parse incoming message\n         */\n        try {\n            message = Message.parse(e.data);\n        } catch (err) {\n            debug('Could not parse message', e.data);\n            this.emit(Client.Event.ERROR, new LineError(\n                Client.ErrorCode.INVALID_JSON,\n                'Could not parse incoming message, invalid json. Check payload for incoming data.',\n                e.data\n            ));\n            return;\n        }\n\n        /**\n         * Route the incoming message\n         */\n        if (message.name == Message.Name.PING) { // Ping message arrived\n            this.onPingMessage_(message);\n        } else if (message.name == Message.Name.RESPONSE) { // Response message arrive\n            this.onResponseMessage_(message);\n        } else if (Message.ReservedNames.indexOf(message.name) == -1) { // If message name is not reserved\n            if (!message.id) { // A message arrived without response\n                this.onMessageWithoutResponse_(message);\n            } else { // A message arrived awaiting its response\n                this.onMessageWithResponse_(message);\n            }\n        } else {\n            debug(`Could not route the message`, message);\n        }\n    }\n\n\n    /**\n     * On \"ping\" message handler. Respond with \"pong\".\n     *\n     * @param {Message} message\n     * @ignore\n     */\n    onPingMessage_(message) {\n        debug('Ping received, responding \"pong\"...');\n\n        this\n            .sendWithoutResponse_(message.createResponse(null, 'pong'))\n            .catch(err => debug('Ping response failed to send back, ignoring for now...', err));\n    }\n\n\n    /**\n     * A response is arrived, find the related deferred and finalize it.\n     *\n     * @param {Message} message\n     * @ignore\n     */\n    onResponseMessage_(message) {\n        const deferred = this.deferreds_[message.id];\n\n        if (!deferred)\n            return debug(`Unknown message response, ignoring... (name=\"${message.name}\" id=\"${message.id}\")`);\n\n        debug(`Message response arrived: name=\"${message.name}\" id=\"${message.id}\"`);\n\n        if (message.err) {\n            // Server rejects the message\n            deferred.reject(new LineError(\n                Client.ErrorCode.MESSAGE_REJECTED,\n                'Message is rejected by server, check payload.',\n                message.err\n            ));\n        } else {\n            // Server resolves the message\n            deferred.resolve(message.payload);\n        }\n\n        delete this.deferreds_[message.id];\n    }\n\n\n    /**\n     * A message is arrived without awaiting a response.\n     *\n     * @param {Message} message\n     * @ignore\n     */\n    onMessageWithoutResponse_(message) {\n        debug(`Message without response: name=\"${message.name}\"`);\n        this.emit(message.name, message);\n    }\n\n\n    /**\n     * A message is arrived and server is waiting for a response.\n     *\n     * @param {Message} message\n     * @ignore\n     */\n    onMessageWithResponse_(message) {\n        debug(`Message with response: name=\"${message.name}\" id=\"${message.id}\"`);\n\n        message.once('resolved', (payload) => {\n            debug(`Client resolving: name=\"${message.name}\" id=\"${message.id}\"`);\n\n            // Try to send our response back to server, if not emit an error\n            this\n                .sendWithoutResponse_(message.createResponse(null, payload))\n                .catch((err) => {\n                    this.emit(Client.Event.ERROR, new LineError(\n                        Client.ErrorCode.MESSAGE_NOT_RESPONDED,\n                        `Message (name=\"${message.name}\" id=\"${message.id}\") could not responded (resolve)`,\n                        err\n                    ));\n                })\n                .then(() => message.dispose());\n        });\n\n        message.once('rejected', (err) => {\n            debug(`Client rejecting: name=\"${message.name}\" id=\"${message.id}\"`);\n\n            // Try to send our response back to server, if not emit an error\n            this\n                .sendWithoutResponse_(message.createResponse(err))\n                .catch((err) => {\n                    this.emit(Client.Event.ERROR, new LineError(\n                        Client.ErrorCode.MESSAGE_NOT_RESPONDED,\n                        `Message (name=\"${message.name}\" id=\"${message.id}\") could not responded (reject)`,\n                        err\n                    ));\n                })\n                .then(() => message.dispose());\n        });\n\n        this.emit(message.name, message);\n    }\n\n\n    /**\n     * Sends a message to server with awaiting its response. This method returns a promise\n     * which resolves the payload parameter will be passed into `message.resolve(...)` in server-side.\n     *\n     * If server rejects the message with `message.reject(...)`, this promise will be rejected with\n     * `Client.ErrorCode.MESSAGE_REJECTED`. You can access the original error object with `err.payload`.\n     *\n     * Rejections:\n     * - `Client.ErrorCode.INVALID_JSON`: Could not stringify the message payload. Probably circular json.\n     * - `Client.ErrorCode.MESSAGE_REJECTED`: Message is explicitly rejected by the server.\n     * - `Client.ErrorCode.MESSAGE_TIMEOUT`: Message response did not arrived, timeout exceeded.\n     * - `Client.ErrorCode.DISCONNECTED`: Client is not connected or connection is closing\n     * - `Client.ErrorCode.WEBSOCKET_ERROR`: Native websocket error (INVALID_STATE_ERR or SYNTAX_ERR)\n     *\n     * @param {string} name Message name.\n     * @param {any=} payload Optional message payload.\n     * @param {number=} timeout Timeout duration for waiting the response. If this parameter\n     *      is not provided, `options.responseTimeout` will be used.\n     * @returns {Promise}\n     * @example\n     * client\n     *   .send('hello', {some: 'payload'})\n     *   .then((data) => {\n     *     console.log('Sent and got the response', data);\n     *   })\n     *   .catch((err) => {\n     *     if (err.code == Client.ErrorCode.MESSAGE_REJECTED) {\n     *       console.log('Message rejected by server', err.payload);\n     *     } else if (err.code == Client.ErrorCode.MESSAGE_TIMEOUT) {\n     *       console.log('Server did not responded, timeout exceeded');\n     *     } else {\n     *       console.log('Could not send message', err);\n     *     }\n     *   });\n     */\n    send(name, payload, opt_timeout) { // This method is for external usage!\n        if (this.state != Client.State.CONNECTED) {\n            return Promise.reject(new LineError(\n                Client.ErrorCode.DISCONNECTED,\n                `Could not send message, client is not connected.`\n            ));\n        }\n\n        try {\n            const message = new Message({name, payload});\n            return this.send_(message, opt_timeout);\n        } catch (err) {\n            // `err` can only be Message.ErrorCode.INVALID_JSON\n            return Promise.reject(new LineError(\n                Client.ErrorCode.INVALID_JSON,\n                `Could not send message, \"payload\" stringify error. Probably circular json issue.`\n            ));\n        }\n    }\n\n\n    /**\n     * Sends a message to server without waiting its response. This method returns a promise\n     * that resolves with nothing if the message is successfully sent.\n     *\n     * Rejections:\n     * - `Client.ErrorCode.INVALID_JSON`: Could not stringify the message payload. Probably circular json.\n     * - `Client.ErrorCode.DISCONNECTED`: Client is not connected or connection is closing\n     * - `Client.ErrorCode.WEBSOCKET_ERROR`: Native websocket error (INVALID_STATE_ERR or SYNTAX_ERR)\n     *\n     * @param {string} name\n     * @param {any=} payload\n     * @returns {Promise}\n     * @example\n     * client\n     *   .sendWithoutResponse('hello', {some: data})\n     *   .then(() => {\n     *     console.log('Message is sent');\n     *   })\n     *   .catch((err) => {\n     *     console.log('Could not send message');\n     *   });\n     */\n    sendWithoutResponse(name, payload) { // This method is for external usage!\n        if (this.state != Client.State.CONNECTED) {\n            return Promise.reject(new LineError(\n                Client.ErrorCode.DISCONNECTED,\n                `Could not send message, client is not connected.`\n            ));\n        }\n\n        try {\n            const message = new Message({name, payload}); // Can throw Message.ErrorCode.INVALID_JSON\n            return this.sendWithoutResponse_(message);\n        } catch (err) {\n            // `err` can only be Message.ErrorCode.INVALID_JSON\n            return Promise.reject(new LineError(\n                Client.ErrorCode.INVALID_JSON,\n                `Could not send message, \"payload\" stringify error. Probably circular json issue.`\n            ));\n        }\n    }\n\n\n    /**\n     * Base method for sending a message with timeout. Please favor this method internally\n     * instead of using `send` method.\n     *\n     * Rejections:\n     * - `Client.ErrorCode.MESSAGE_REJECTED`: Message is explicitly rejected by the server.\n     * - `Client.ErrorCode.MESSAGE_TIMEOUT`: Message response did not arrived, timeout exceeded.\n     * - `Client.ErrorCode.DISCONNECTED`: Client is not connected or connection is closing\n     * - `Client.ErrorCode.WEBSOCKET_ERROR`: Native websocket error (INVALID_STATE_ERR or SYNTAX_ERR)\n     *\n     * @param {Message} message\n     * @param {number=} opt_timeout\n     * @returns {Promise}\n     * @ignore\n     */\n    send_(message, opt_timeout) {\n        const timeout = isInteger(opt_timeout) && opt_timeout >= 0 ? opt_timeout : this.options.responseTimeout;\n        message.setId();\n\n        const deferred = this.deferreds_[message.id] = new Deferred({\n            onExpire: () => {\n                delete this.deferreds_[message.id];\n            },\n            timeout: timeout\n        });\n\n        return this\n            .sendWithoutResponse_(message)\n            .then(() => deferred)\n            .catch((err) => {\n                deferred.dispose();\n\n                // Convert expired -> timeout error\n                if (err instanceof LineError && err.code == Deferred.ErrorCode.EXPIRED) {\n                    throw new LineError(\n                        Client.ErrorCode.MESSAGE_TIMEOUT,\n                        `Message timeout! Its response did not recived after ${timeout} ms`\n                    );\n                }\n\n                throw err;\n            });\n    }\n\n\n    /**\n     * Base method for sending a message without response. Please favor this method internally\n     * instead of using `sendWithoutResponse` method.\n     *\n     * Rejections:\n     * - `Client.ErrorCode.DISCONNECTED`: Client is not connected or connection is closing\n     * - `Client.ErrorCode.WEBSOCKET_ERROR`: Native websocket error (INVALID_STATE_ERR or SYNTAX_ERR)\n     *\n     * @param {Message} message\n     * @returns {Promise}\n     * @ignore\n     */\n    sendWithoutResponse_(message) {\n        if (!this.ws_ || this.ws_.readyState != 1) {\n            return Promise.reject(new LineError(\n                Client.ErrorCode.DISCONNECTED,\n                `Could not send message, there is no open connection.`\n            ));\n        }\n\n        return new Promise((resolve, reject) => {\n            const messageStr = message.toString();\n\n            try {\n                debug(`Sending message: ${messageStr}`);\n                this.ws_.send(messageStr); // Can throw INVALID_STATE_ERR, SYNTAX_ERR\n                resolve();\n            } catch (err) {\n                reject(new LineError(\n                    Client.ErrorCode.WEBSOCKET_ERROR,\n                    'Could not send message. Either socket is not connected or syntax error, check payload.',\n                    err\n                ));\n            }\n        });\n    }\n\n\n    /**\n     * Sends a ping message to server, if it's failed, the connection\n     * will be closed and will retry to connect again. Server and client ping each\n     * other automatically with an interval.\n     *\n     * @returns {Promise}\n     */\n    ping() {\n        const currentSocket = this.ws_;\n\n        debug('Pinging...');\n        return this\n            .send_(new Message({name: Message.Name.PING}))\n            .catch(err => {\n                // If socket is changed, dismiss\n                if (this.ws_ != currentSocket) {\n                    debug('Auto-ping failed, but socket is also changed, dismissing...');\n                    return;\n                }\n\n                // No matter what error is, start disconnection process\n                debug('Auto-ping failed, manually disconnecting...');\n                this.disconnect(CloseStatus.PING_FAILED.code, 'Auto ping failed', true);\n                throw new LineError(Client.ErrorCode.PING_ERROR, `Ping failed, disconnecting...`, err);\n            });\n    }\n\n\n    /**\n     * On uptime tick event handler. Check current state and push a marker to buffer.\n     *\n     * @ignore\n     */\n    uptimeTick_() {\n        debug('Uptime Tick');\n        this.uptimeBuffer_.push(this.state == Client.State.CONNECTED);\n\n        if (this.uptimeBuffer_.length > this.uptimeBufferLength_) {\n            this.uptimeBuffer_.splice(0, this.uptimeBufferLength_ - this.uptimeBuffer_.length);\n        }\n    }\n\n\n    /**\n     * Calculates (connection) uptime for last `options.uptime.window` (default 5 minutes)\n     * with `options.uptime.interval` (default 5 seconds) interval. Returns a number between\n     * 0 and 1. If `options.uptime` is false, this method returns nothing.\n     *\n     * @returns {number?}\n     */\n    getUptime() {\n        if (!this.options.uptime) return;\n        if (this.uptimeBuffer_.length == 0) return 0;\n        return this.uptimeBuffer_.filter(val => val).length / this.uptimeBuffer_.length;\n    }\n\n\n    /**\n     * Disposes the client.\n     *\n     * @returns {Promise}\n     */\n    dispose() {\n        return new Promise((resolve) => {\n            debug('Disposing...');\n\n            switch (this.state) {\n                case Client.State.CONNECTING:\n                case Client.State.HANDSHAKING:\n                case Client.State.CONNECTED:\n                    this.once(Client.Event.DISCONNECTED, () => {\n                        this.removeAllListeners();\n                        this.uptimeBuffer_ = [];\n                        if (this.uptimeInterval_) clearInterval(this.uptimeInterval_);\n                        debug('Disposed!');\n                        resolve();\n                    });\n\n                    this.disconnect(CloseStatus.DISPOSED.code, CloseStatus.DISPOSED.reason);\n                    break;\n\n                case Client.State.READY:\n                case Client.State.DISCONNECTING:\n                case Client.State.DISCONNECTED:\n                    this.resetReconnectState_();\n                    this.removeAllListeners();\n                    this.uptimeBuffer_ = [];\n                    if (this.uptimeInterval_) clearInterval(this.uptimeInterval_);\n                    debug('Disposed!');\n                    resolve();\n                    break;\n            }\n        });\n    }\n\n\n    /**\n     * Reject all the awaiting deferred with given error.\n     *\n     * @param {Error} err An error object to reject all awaiting deferreds.\n     * @ignore\n     */\n    rejectAllDeferreds_(err) {\n        forEach(this.deferreds_, deferred => deferred.reject(err));\n        this.deferreds_ = {};\n    }\n\n\n    /**\n     * Resets the reconnection state.\n     *\n     * @ignore\n     */\n    resetReconnectState_() {\n        debug('Resetting reconnection state...');\n        if (this.reconnectState_.timeout) clearTimeout(this.reconnectState_.timeout);\n        this.reconnectState_ = {disabled: false, attempt: 0, timeout: null};\n    }\n}\n\n\nClient.ws2http = function(url) {\n    let rv;\n    const mapping = {\n        'ws://': 'http://',\n        'wss://': 'https://'\n    };\n    forEach(mapping, (replace, target) => {\n        if (url.indexOf(target) != 0) return;\n        rv = replace + url.substr(target.length);\n    });\n    return rv;\n};\n\n\nClient.http2ws = function(url) {\n    let rv;\n    const mapping = {\n        'http://': 'ws://',\n        'https://': 'wss://'\n    };\n    forEach(mapping, (replace, target) => {\n        if (url.indexOf(target) != 0) return;\n        rv = replace + url.substr(target.length);\n    });\n    return rv;\n};\n\n\nClient.fetchResponseUrl = function(url, timeout = 3000) {\n    return new Deferred({\n        timeout,\n        handler: (deferred) => {\n            const req = new XMLHttpRequest();\n            req.addEventListener('error', () => deferred.reject(new Error('Native XMLHttpRequest error')));\n            req.addEventListener('abort', () => deferred.reject(new Error('Aborted XMLHttpRequest')));\n            req.addEventListener('load', () => deferred.resolve(req.responseURL));\n            req.open('HEAD', url);\n\n            try {\n                req.send();\n            } catch (err) {\n                deferred.reject(err);\n            }\n        }\n    });\n};\n\n\n// Expose internal classes\nClient.Message = Message;\nClient.Error = LineError;\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nClient.ErrorCode = {\n    /**\n     * When constructing `new Client()`, this error could be thrown.\n     */\n    INVALID_OPTIONS: 'cInvalidOptions',\n    /**\n     * Indicates an error while json parsing/stringify.\n     */\n    INVALID_JSON: 'cInvalidJSON',\n    /**\n     * This error can be emitted in `Client.Events.CONNECTING_ERROR` event.\n     * It indicates an operational error during the handshake. If `options.reconnect` is true,\n     * the client will try to reconnect again.\n     */\n    HANDSHAKE_ERROR: 'cHandshakeError',\n    /**\n     * This error can be emitted in `Client.Events.CONNECTING_ERROR` event.\n     * It indicates that server is explicitly rejected the handshake, which probably means\n     * client's handshake payload is not accepted by server.\n     */\n    HANDSHAKE_REJECTED: 'cHandshakeRejected',\n    /**\n     * This error can be seen in rejection of `client.send()` method. This means the\n     * message is reached to server but the timeout is exceeded.\n     */\n    MESSAGE_TIMEOUT: 'cMessageTimeout',\n    /**\n     * This error can be seen in rejection of `client.send()` method, which again indicates that\n     * server is explicitly rejected the message.\n     */\n    MESSAGE_REJECTED: 'cMessageRejected',\n    /**\n     * When the response of a message failed to send to server, this error\n     * will be emitted in `Client.Event.ERROR` event.\n     */\n    MESSAGE_NOT_RESPONDED: 'cMessageNotResponded',\n    /**\n     * This error is for native websocket errors. Native error is wrapped by `LineError`\n     * and can be accessible under `err.payload`.\n     */\n    WEBSOCKET_ERROR: 'cWebsocketError',\n    /**\n     * When disconnect timeout is exceed, this error will be emited in\n     * `Client.Events.ERROR` event. After this event, the disconnect\n     * procedure will be started forcefully.\n     */\n    DISCONNECT_TIMEOUT: 'cDisconnectError',\n    /**\n     * This error can be seen in rejection of `client.ping()` method. After this error,\n     * client will be disconnected.\n     */\n    PING_ERROR: 'cPingError',\n    /**\n     * This error indicates the action is prohibited because client is not\n     * in connected state or connection is closing.\n     */\n    DISCONNECTED: 'cDisconnected'\n};\n\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nClient.State = {\n    /**\n     * `ready`\n     */\n    READY: 'ready',\n    /**\n     * `connecting`\n     */\n    CONNECTING: 'connecting',\n    /**\n     * `handshaking`\n     */\n    HANDSHAKING: 'handshaking',\n    /**\n     * `connected`\n     */\n    CONNECTED: 'connected',\n    /**\n     * `disconnecting`\n     */\n    DISCONNECTING: 'disconnecting',\n    /**\n     * `disconnected`\n     */\n    DISCONNECTED: 'disconnected'\n};\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nClient.Event = {\n    /**\n     * `_connecting`\n     */\n    CONNECTING: '_connecting',\n    /**\n     * `_connecting_error`\n     */\n    CONNECTING_ERROR: '_connecting_error',\n    /**\n     * `_connected`\n     */\n    CONNECTED: '_connected',\n    /**\n     * `_disconnecting`\n     */\n    DISCONNECTING: '_disconnecting',\n    /**\n     * `_disconnected`\n     */\n    DISCONNECTED: '_disconnected',\n    /**\n     * `_error`\n     */\n    ERROR: '_error'\n};\n\n\nmodule.exports = Client;\n\n\n\n// WEBPACK FOOTER //\n// ./src/client/client-web.js","module.exports = require(\"ws\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"ws\"\n// module id = 7\n// module chunks = 0","module.exports = {\n    INTERNAL_ERROR: {code: 4200, reason: 'Internal error'},\n    PING_FAILED: {code: 4201, reason: 'Ping failed'},\n    HANDSHAKE_FAILED: {code: 4202, reason: 'Handshake failed'},\n    HANDSHAKE_REJECTED: {code: 4203, reason: 'Handshake rejected'},\n    DISCONNECT_TIMEOUT: {code: 4204, reason: 'Disconnect timeout'},\n    DISPOSED: {code: 4205, reason: 'Client disposed'},\n    UNKNOWN_ERROR: {code: 4299, reason: 'Unknown error'},\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/closestatus.js","const isUndefined = require('lodash/isUndefined');\nconst isString = require('lodash/isString');\nconst isObject = require('lodash/isObject');\nconst isFunction = require('lodash/isFunction');\nconst values = require('lodash/values');\nconst assign = require('lodash/assign');\nconst {generateDummyId} = require('./utils');\nconst EventEmitterExtra = require('event-emitter-extra');\nconst LineError = require('./error');\n\n\n/**\n * Message class.\n *\n * @private\n * @class Message\n * @extends {EventEmitterExtra}\n */\nclass Message extends EventEmitterExtra {\n    static parse(raw) {\n        try {\n            const data = JSON.parse(raw);\n\n            // If error is error-like object, construct real error\n            if (isObject(data.e) && isString(data.e.name) && isString(data.e.message)) {\n                data.e = assign(new Error(), data.e);\n            }\n\n            return new Message({\n                name: data.n,\n                payload: data.p,\n                err: data.e,\n                id: data.i\n            });\n        } catch(err) {\n            throw new LineError(Message.ErrorCode.INVALID_JSON, `Could not parse incoming message.`);\n        }\n    }\n\n\n    constructor({name, payload, id, err}) {\n        super();\n\n        try {\n            JSON.stringify(payload);\n            JSON.stringify(err);\n        } catch (err) {\n            throw new LineError(\n                Message.ErrorCode.INVALID_JSON,\n                `Message payload or error must be json-friendly. Maybe circular json?`\n            );\n        }\n\n        this.name = name;\n        this.payload = payload;\n        this.id = id;\n        this.err = err;\n\n        this.isResponded_ = false;\n    }\n\n\n    setId(id = generateDummyId()) {\n        this.id = id;\n        return id;\n    }\n\n\n    createResponse(err, payload) {\n        return new Message({name: '_r', payload, err, id: this.id});\n    }\n\n\n    /**\n     * Resolves the message with sending a response back. If the source\n     * does not expecting a response, you don't need to call these methods.\n     *\n     * This method can throw:\n     * - `Message.ErrorCode.MISSING_ID`: Message source is not expecting a response.\n     * - `Message.ErrorCode.ALREADY_RESPONDED`: This message is already responded.\n     * - `Message.ErrorCode.INVALID_JSON`: Could not stringify payload. Probably circular json.\n     *\n     * @param {any=} payload\n     */\n    resolve(payload) {\n        if (isUndefined(this.id)) {\n            throw new LineError(Message.ErrorCode.MISSING_ID, `This message could not be resolved (no id)`);\n        }\n\n        if (this.isResponded_) {\n            throw new LineError(Message.ErrorCode.ALREADY_RESPONDED, `This message has already responded`);\n        }\n\n        try {\n            JSON.stringify(payload);\n        } catch (err_) {\n            throw new LineError(\n                Message.ErrorCode.INVALID_JSON,\n                `Message must be resolved with json-friendly payload. Maybe circular json?`\n            );\n        }\n\n        this.isResponded_ = true;\n        this.emit('resolved', payload);\n    }\n\n\n    /**\n     * Rejects the message, with sending error response back to the source.\n     *\n     * This method can throw:\n     * - `Message.ErrorCode.MISSING_ID`: Message source is not expecting a response.\n     * - `Message.ErrorCode.ALREADY_RESPONDED`: This message is already responded.\n     * - `Message.ErrorCode.INVALID_JSON`: Could not stringify payload. Probably circular json.\n     *\n     * @param {any=} err\n     */\n    reject(err) {\n        if (isUndefined(this.id)) {\n            throw new LineError(Message.ErrorCode.MISSING_ID, `This message could not be rejected (no id)`);\n        }\n\n        if (this.isResponded_) {\n            throw new LineError(Message.ErrorCode.ALREADY_RESPONDED, `This message has already responded`);\n        }\n\n\n        try {\n            JSON.stringify(err);\n        } catch (err_) {\n            throw new LineError(\n                Message.ErrorCode.INVALID_JSON,\n                `Message must be resolved with json-friendly payload. Maybe circular json?`\n            );\n        }\n\n        this.isResponded_ = true;\n        this.emit('rejected', err);\n    }\n\n\n    toString() {\n        const data = {n: this.name};\n\n        if (!isUndefined(this.payload))\n            data.p = this.payload;\n\n        if (!isUndefined(this.id))\n            data.i = this.id;\n\n        if (!isUndefined(this.err)) {\n            data.e = this.err instanceof Error ? assign({\n                name: this.err.name,\n                message: this.err.message\n            }, this.err) : this.err;\n        }\n\n        // We're sure the data is json-friendly\n        return JSON.stringify(data);\n    }\n\n\n    dispose() {\n        const events = this.eventNames();\n        events.forEach(event => this.removeAllListeners(event));\n    }\n}\n\n\n/**\n * These message names are reserved for internal usage.\n * We recommend to not use any message name starts with `_` (underscore).\n *\n * @static\n * @readonly\n * @enum {string}\n */\nMessage.Name = {\n    /**\n     * `_r`\n     */\n    RESPONSE: '_r',\n    /**\n     * `_h`\n     */\n    HANDSHAKE: '_h',\n    /**\n     * `_p`\n     */\n    PING: '_p'\n};\n\n\nMessage.ReservedNames = values(Message.Name);\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nMessage.ErrorCode = {\n    /**\n     * `mInvalidJson`\n     */\n    INVALID_JSON: 'mInvalidJson',\n    /**\n     * `mMissingId`\n     */\n    MISSING_ID: 'mMissingId',\n    /**\n     * `mAlreadyResponded`\n     */\n    ALREADY_RESPONDED: 'mAlreadyResponded',\n};\n\n\nmodule.exports = Message;\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/message.js","const assign = require('lodash/assign');\n\n\n// http://stackoverflow.com/a/6248722\nfunction generateDummyId(length = 4) {\n    return (\"0000\" + (Math.random()*Math.pow(36,length) << 0).toString(36)).slice(-length);\n}\n\n\nmodule.exports = {generateDummyId};\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/utils.js","module.exports = require(\"debug\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"debug\"\n// module id = 11\n// module chunks = 0","module.exports = require(\"lodash/debounce\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/debounce\"\n// module id = 12\n// module chunks = 0","module.exports = require(\"lodash/defaultsDeep\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/defaultsDeep\"\n// module id = 13\n// module chunks = 0","module.exports = require(\"lodash/forEach\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/forEach\"\n// module id = 14\n// module chunks = 0","module.exports = require(\"lodash/isBoolean\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isBoolean\"\n// module id = 15\n// module chunks = 0","module.exports = require(\"lodash/isFunction\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isFunction\"\n// module id = 16\n// module chunks = 0","module.exports = require(\"lodash/isInteger\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isInteger\"\n// module id = 17\n// module chunks = 0","module.exports = require(\"lodash/isNumber\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isNumber\"\n// module id = 18\n// module chunks = 0","module.exports = require(\"lodash/isUndefined\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isUndefined\"\n// module id = 19\n// module chunks = 0","module.exports = require(\"lodash/values\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/values\"\n// module id = 20\n// module chunks = 0","global.WebSocket = require('ws'); // Polyfill for extending browser code\nconst Client = require('./client-web');\nconst Deferred = require('../lib/deferred');\n\n\n/**\n * Polyfill http request for node\n */\nClient.fetchResponseUrl = function(url, timeout = 3000) {\n    return new Deferred({\n        timeout,\n        handler: (deferred) => {\n            deferred.resolve({});\n        }\n    });\n};\n\n\nmodule.exports = Client;\n\n\n\n// WEBPACK FOOTER //\n// ./src/client/client-node.js"],"sourceRoot":""}