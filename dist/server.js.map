{"version":3,"sources":["webpack:///server.js","webpack:///webpack/bootstrap 528ab750088ed0dd8c3f","webpack:///./src/lib/error.js","webpack:///external \"lodash/assign\"","webpack:///./src/lib/message.js","webpack:///external \"debug\"","webpack:///external \"event-emitter-extra\"","webpack:///external \"lodash/forEach\"","webpack:///external \"lodash/isInteger\"","webpack:///external \"lodash/isObject\"","webpack:///./src/server/connection.js","webpack:///./src/server/rooms.js","webpack:///external \"http\"","webpack:///external \"https\"","webpack:///external \"uws\"","webpack:///external \"websocket\"","webpack:///external \"ws\"","webpack:///./src/lib/closestatus.js","webpack:///./src/lib/deferred.js","webpack:///./src/lib/utils.js","webpack:///./src/server/room.js","webpack:///external \"lodash/clone\"","webpack:///external \"lodash/debounce\"","webpack:///external \"lodash/filter\"","webpack:///external \"lodash/isFunction\"","webpack:///external \"lodash/isString\"","webpack:///external \"lodash/isUndefined\"","webpack:///external \"lodash/map\"","webpack:///external \"lodash/values\"","webpack:///external \"uuid\"","webpack:///./src/server/server.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","Object","defineProperty","configurable","enumerable","get","n","__esModule","o","object","property","prototype","hasOwnProperty","p","s","LineError","code","message","payload","this","stack","Error","require","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","writable","setPrototypeOf","__proto__","_createClass","defineProperties","target","props","length","descriptor","key","protoProps","staticProps","isUndefined","isString","isObject","values","assign","_require","generateDummyId","EventEmitterExtra","Message","_EventEmitterExtra","_ref","id","err","_this","getPrototypeOf","JSON","stringify","ErrorCode","INVALID_JSON","isResponded_","raw","data","parse","e","arguments","undefined","MISSING_ID","ALREADY_RESPONDED","err_","emit","_this2","events","eventNames","forEach","event","removeAllListeners","Name","RESPONSE","HANDSHAKE","PING","ReservedNames","isInteger","debounce","Deferred","uuid","debug","CloseStatus","ServerConnection","socket","server","v4","state","State","AWAITING_HANDSHAKE","deferreds_","autoPing_","on","onMessage_","bind","onError_","onClose_","options","pingInterval","ping","then","CONNECTED","catch","handshakeTimeout","handshakeTimeout_","setTimeout","close","HANDSHAKE_FAILED","flags","wslib","utf8Data","Event","ERROR","onHandshakeMessage_","onPingMessage_","onResponseMessage_","indexOf","onMessageWithResponse_","onMessageWithoutResponse_","sendWithoutResponse_","createResponse","once","clearTimeout","responsePayload","rooms","root","add","DISCONNECTED","WEBSOCKET_ERROR","reason","dispose","HANDSHAKE_REJECTED","handshakeListener","resolve","deferred","MESSAGE_REJECTED","reject","_this3","MESSAGE_NOT_RESPONDED","cancel","removeFromAll","remove","rejectAllDeferreds_","newId","HANDSHAKE_ENDED","getConnectionById","ID_CONFLICT","roomName","getRoomsOf","opt_timeout","Promise","send_","_this4","timeout","responseTimeout","setId","onExpire","EXPIRED","MESSAGE_TIMEOUT","_this5","connected","readyState","messageStr","toString","send","_this6","PING_FAILED","PING_ERROR","delay","_this7","filter","map","Room","Rooms","connection","getConnectionsCount","room","INTERNAL_ERROR","DISCONNECT_TIMEOUT","DISPOSED","UNKNOWN_ERROR","_ref$handler","handler","_ref$onExpire","_ref$timeout","resolve_","reject_","timeout_","timeoutDuration_","onExpire_","isFinished_","promise","expire","clearTimeout_","_len","args","Array","_key","apply","_len2","_key2","Math","random","pow","slice","clone","ServerRoom","connections","connectionId","keys","broadcast_","Connection","http","https","WebSocketServer","Server","console","log","INVALID_OPTIONS","INVALID_ACTION","port","secure","httpServer","createServer","bindEvents_","listen","shutDown","onRequest_","onConnection_","onHeaders_","request","accept","origin","headers","HEADERS","getConnections","broadcast","getRoom","CONNECTION"],"mappings":"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","file":"server.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmory imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmory exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tObject.defineProperty(exports, name, {\n/******/ \t\t\tconfigurable: false,\n/******/ \t\t\tenumerable: true,\n/******/ \t\t\tget: getter\n/******/ \t\t});\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 28);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\"use strict\";\n'use strict';\n\nfunction LineError(code, message, payload) {\n    this.name = 'LineError';\n    this.message = message;\n    this.code = code;\n    this.payload = payload;\n    this.stack = new Error().stack;\n}\nLineError.prototype = new Error();\n\nmodule.exports = LineError;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/assign\");\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar isUndefined = __webpack_require__(24);\nvar isString = __webpack_require__(23);\nvar isObject = __webpack_require__(7);\nvar isFunction = __webpack_require__(22);\nvar values = __webpack_require__(26);\nvar assign = __webpack_require__(1);\n\nvar _require = __webpack_require__(17),\n    generateDummyId = _require.generateDummyId;\n\nvar EventEmitterExtra = __webpack_require__(4);\nvar LineError = __webpack_require__(0);\n\n/**\n * Message class.\n *\n * @private\n * @class Message\n * @extends {EventEmitterExtra}\n */\n\nvar Message = function (_EventEmitterExtra) {\n    _inherits(Message, _EventEmitterExtra);\n\n    _createClass(Message, null, [{\n        key: 'parse',\n        value: function parse(raw) {\n            try {\n                var data = JSON.parse(raw);\n\n                // If error is error-like object, construct real error\n                if (isObject(data.e) && isString(data.e.name) && isString(data.e.message)) {\n                    data.e = assign(new Error(), data.e);\n                }\n\n                return new Message({\n                    name: data.n,\n                    payload: data.p,\n                    err: data.e,\n                    id: data.i\n                });\n            } catch (err) {\n                throw new LineError(Message.ErrorCode.INVALID_JSON, 'Could not parse incoming message.');\n            }\n        }\n    }]);\n\n    function Message(_ref) {\n        var name = _ref.name,\n            payload = _ref.payload,\n            id = _ref.id,\n            err = _ref.err;\n\n        _classCallCheck(this, Message);\n\n        var _this = _possibleConstructorReturn(this, (Message.__proto__ || Object.getPrototypeOf(Message)).call(this));\n\n        try {\n            JSON.stringify(payload);\n            JSON.stringify(err);\n        } catch (err) {\n            throw new LineError(Message.ErrorCode.INVALID_JSON, 'Message payload or error must be json-friendly. Maybe circular json?');\n        }\n\n        _this.name = name;\n        _this.payload = payload;\n        _this.id = id;\n        _this.err = err;\n\n        _this.isResponded_ = false;\n        return _this;\n    }\n\n    _createClass(Message, [{\n        key: 'setId',\n        value: function setId() {\n            var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : generateDummyId();\n\n            this.id = id;\n            return id;\n        }\n    }, {\n        key: 'createResponse',\n        value: function createResponse(err, payload) {\n            return new Message({ name: '_r', payload: payload, err: err, id: this.id });\n        }\n\n        /**\n         * Resolves the message with sending a response back. If the source\n         * does not expecting a response, you don't need to call these methods.\n         *\n         * This method can throw:\n         * - `Message.ErrorCode.MISSING_ID`: Message source is not expecting a response.\n         * - `Message.ErrorCode.ALREADY_RESPONDED`: This message is already responded.\n         * - `Message.ErrorCode.INVALID_JSON`: Could not stringify payload. Probably circular json.\n         *\n         * @param {any=} payload\n         */\n\n    }, {\n        key: 'resolve',\n        value: function resolve(payload) {\n            if (isUndefined(this.id)) {\n                throw new LineError(Message.ErrorCode.MISSING_ID, 'This message could not be resolved (no id)');\n            }\n\n            if (this.isResponded_) {\n                throw new LineError(Message.ErrorCode.ALREADY_RESPONDED, 'This message has already responded');\n            }\n\n            try {\n                JSON.stringify(payload);\n            } catch (err_) {\n                throw new LineError(Message.ErrorCode.INVALID_JSON, 'Message must be resolved with json-friendly payload. Maybe circular json?');\n            }\n\n            this.isResponded_ = true;\n            this.emit('resolved', payload);\n        }\n\n        /**\n         * Rejects the message, with sending error response back to the source.\n         *\n         * This method can throw:\n         * - `Message.ErrorCode.MISSING_ID`: Message source is not expecting a response.\n         * - `Message.ErrorCode.ALREADY_RESPONDED`: This message is already responded.\n         * - `Message.ErrorCode.INVALID_JSON`: Could not stringify payload. Probably circular json.\n         *\n         * @param {any=} err\n         */\n\n    }, {\n        key: 'reject',\n        value: function reject(err) {\n            if (isUndefined(this.id)) {\n                throw new LineError(Message.ErrorCode.MISSING_ID, 'This message could not be rejected (no id)');\n            }\n\n            if (this.isResponded_) {\n                throw new LineError(Message.ErrorCode.ALREADY_RESPONDED, 'This message has already responded');\n            }\n\n            try {\n                JSON.stringify(err);\n            } catch (err_) {\n                throw new LineError(Message.ErrorCode.INVALID_JSON, 'Message must be resolved with json-friendly payload. Maybe circular json?');\n            }\n\n            this.isResponded_ = true;\n            this.emit('rejected', err);\n        }\n    }, {\n        key: 'toString',\n        value: function toString() {\n            var data = { n: this.name };\n\n            if (!isUndefined(this.payload)) data.p = this.payload;\n\n            if (!isUndefined(this.id)) data.i = this.id;\n\n            if (!isUndefined(this.err)) {\n                data.e = this.err instanceof Error ? assign({\n                    name: this.err.name,\n                    message: this.err.message\n                }, this.err) : this.err;\n            }\n\n            // We're sure the data is json-friendly\n            return JSON.stringify(data);\n        }\n    }, {\n        key: 'dispose',\n        value: function dispose() {\n            var _this2 = this;\n\n            var events = this.eventNames();\n            events.forEach(function (event) {\n                return _this2.removeAllListeners(event);\n            });\n        }\n    }]);\n\n    return Message;\n}(EventEmitterExtra);\n\n/**\n * These message names are reserved for internal usage.\n * We recommend to not use any message name starts with `_` (underscore).\n *\n * @static\n * @readonly\n * @enum {string}\n */\n\n\nMessage.Name = {\n    /**\n     * `_r`\n     */\n    RESPONSE: '_r',\n    /**\n     * `_h`\n     */\n    HANDSHAKE: '_h',\n    /**\n     * `_p`\n     */\n    PING: '_p'\n};\n\nMessage.ReservedNames = values(Message.Name);\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nMessage.ErrorCode = {\n    /**\n     * `mInvalidJson`\n     */\n    INVALID_JSON: 'mInvalidJson',\n    /**\n     * `mMissingId`\n     */\n    MISSING_ID: 'mMissingId',\n    /**\n     * `mAlreadyResponded`\n     */\n    ALREADY_RESPONDED: 'mAlreadyResponded'\n};\n\nmodule.exports = Message;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"debug\");\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"event-emitter-extra\");\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/forEach\");\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isInteger\");\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isObject\");\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Message = __webpack_require__(2);\nvar EventEmitterExtra = __webpack_require__(4);\nvar assign = __webpack_require__(1);\nvar forEach = __webpack_require__(5);\nvar isInteger = __webpack_require__(6);\nvar isObject = __webpack_require__(7);\nvar debounce = __webpack_require__(20);\nvar Deferred = __webpack_require__(16);\nvar uuid = __webpack_require__(27);\nvar debug = __webpack_require__(3)('line:server:connection');\nvar LineError = __webpack_require__(0);\nvar CloseStatus = __webpack_require__(15);\n\n/**\n * Server connection class. Constructor of this class is not publicly accessible.\n * When you listen `Server.Event.CONNECTION` or `Server.Event.HANDSHAKE`, an instance\n * of `ServerConnection` will be emitted.\n *\n * @class ServerConnection\n * @extends {EventEmitterExtra}\n * @private\n * @property {string} id Unique connection id\n */\n\nvar ServerConnection = function (_EventEmitterExtra) {\n    _inherits(ServerConnection, _EventEmitterExtra);\n\n    function ServerConnection(socket, server) {\n        _classCallCheck(this, ServerConnection);\n\n        var _this = _possibleConstructorReturn(this, (ServerConnection.__proto__ || Object.getPrototypeOf(ServerConnection)).call(this));\n\n        _this.id = uuid.v4();\n        debug('Creating connection with id ' + _this.id + ' ...');\n\n        _this.socket = socket;\n        _this.server = server;\n        _this.state = ServerConnection.State.AWAITING_HANDSHAKE;\n\n        _this.deferreds_ = {};\n        _this.autoPing_ = debounce(function () {});\n\n        _this.socket.on('message', _this.onMessage_.bind(_this));\n        _this.socket.on('error', _this.onError_.bind(_this));\n        _this.socket.on('close', _this.onClose_.bind(_this));\n\n        if (server.options.pingInterval > 0) {\n            _this.autoPing_ = debounce(function () {\n                _this.ping().then(function () {\n                    debug('Auto-ping successful');\n\n                    if (server.options.pingInterval > 0 && _this.state == ServerConnection.State.CONNECTED) {\n                        _this.autoPing_();\n                    }\n                }).catch(function (err) {/* Disconnection is handled in ping */});\n            }, server.options.pingInterval);\n        }\n\n        if (server.options.handshakeTimeout > 0) {\n            _this.handshakeTimeout_ = setTimeout(function () {\n                if (_this.state != ServerConnection.State.AWAITING_HANDSHAKE) {\n                    return debug('Handshake is not awaiting, ignoring handshake timeout...');\n                }\n\n                debug('Handshake timeout exceed, closing the connection...');\n                _this.close(CloseStatus.HANDSHAKE_FAILED.code, 'Handshake not completed after ' + server.options.handshakeTimeout + ' ms');\n            }, server.options.handshakeTimeout);\n        }\n        return _this;\n    }\n\n    /**\n     * Native \"message\" event handler.\n     *\n     * @param {string|Buffer} data\n     * @param {Object} flags\n     * @param {boolean} flags.binary Specifies if data is binary.\n     * @param {boolean} flags.Boolean Specifies if data was masked.\n     * @ignore\n     */\n\n\n    _createClass(ServerConnection, [{\n        key: 'onMessage_',\n        value: function onMessage_(data, flags) {\n            debug('Native \"message\" event recieved: ' + data);\n            var message = void 0;\n\n            if (this.server.wslib == 'websocket') data = data.utf8Data;\n\n            // A message is recieved, debounce our auto-ping handler if connected\n            if (this.state == ServerConnection.State.CONNECTED) {\n                this.autoPing_();\n            }\n\n            try {\n                message = Message.parse(data);\n            } catch (err) {\n                this.emit(ServerConnection.Event.ERROR, new LineError(ServerConnection.ErrorCode.INVALID_JSON, 'Could not parse message, invalid json. Check payload for incoming data.', data));\n                return;\n            }\n\n            /**\n             * Route the incoming message\n             */\n            if (message.name == Message.Name.HANDSHAKE) {\n                // Handshake\n                this.onHandshakeMessage_(message);\n            } else if (message.name == Message.Name.PING) {\n                // Ping\n                this.onPingMessage_(message);\n            } else if (message.name == Message.Name.RESPONSE) {\n                // Message response\n                this.onResponseMessage_(message);\n            } else if (Message.ReservedNames.indexOf(message.name) == -1) {\n                // If message name is not reserved\n                if (!message.id) {\n                    // Message without response (no id fields)\n                    this.onMessageWithoutResponse_(message);\n                } else {\n                    // Message arrived awaiting its response\n                    this.onMessageWithResponse_(message);\n                }\n            } else {\n                debug('Could not route the message', message);\n            }\n        }\n\n        /**\n         * On \"handshake\" message handler.\n         *\n         * @param {Message} message\n         * @ignore\n         */\n\n    }, {\n        key: 'onHandshakeMessage_',\n        value: function onHandshakeMessage_(message) {\n            var _this2 = this;\n\n            if (this.state == ServerConnection.State.CONNECTED) {\n                debug('Handshake message recieved but, handshake is already resolved, ignoring...');\n                return this.sendWithoutResponse_(message.createResponse(new Error('Handshake is already resolved'))).catch(function () {/* Ignoring */});\n            }\n\n            debug('Handshake message recieved: ' + message);\n\n            /**\n             * If handshake is resolved\n             */\n            message.once('resolved', function (payload) {\n                debug('Handshake is resolved, sending response...');\n                _this2.state = ServerConnection.State.CONNECTED;\n                _this2.handshakeTimeout_ && clearTimeout(_this2.handshakeTimeout_);\n                _this2.autoPing_(); // Start auto-pinging\n\n                var responsePayload = {\n                    payload: payload,\n                    id: _this2.id\n                };\n\n                _this2.sendWithoutResponse_(message.createResponse(null, responsePayload)).then(function () {\n                    debug('Handshake resolving response is sent, emitting connection...');\n                    _this2.server.rooms.root.add(_this2);\n                    _this2.server.emit('connection', _this2);\n                }).catch(function (err) {\n                    debug('Could not send handshake response', err);\n\n                    // TODO: Emit these errors from the server\n                    if (err instanceof LineError) {\n                        switch (err.code) {\n                            case ServerConnection.ErrorCode.DISCONNECTED:\n                                debug('Connection is gone before handshake completed, ignoring...');\n                                return;\n\n                            case ServerConnection.ErrorCode.WEBSOCKET_ERROR:\n                                // TODO: Try again!\n                                debug('Native websocket error', err.payload);\n                                return _this2.close(CloseStatus.HANDSHAKE_FAILED.code, CloseStatus.HANDSHAKE_FAILED.reason);\n\n                            default:\n                                debug('Unhandled line error', err);\n                                return _this2.close(CloseStatus.HANDSHAKE_FAILED.code, CloseStatus.HANDSHAKE_FAILED.reason);\n                        }\n                    }\n\n                    debug('Unknown error', err);\n                    return _this2.close(CloseStatus.HANDSHAKE_FAILED.code, CloseStatus.HANDSHAKE_FAILED.reason);\n                }).then(function () {\n                    message.dispose();\n                });\n            });\n\n            /**\n             * Id handshake is rejected\n             */\n            message.once('rejected', function (err) {\n                debug('Handshake is rejected, sending response...');\n\n                _this2.sendWithoutResponse_(message.createResponse(err)).catch(function (err) {\n                    return debug('Handshake rejecting response could not sent, manually calling \"close\"...', err);\n                }).then(function () {\n                    return _this2.close(CloseStatus.HANDSHAKE_REJECTED.code, CloseStatus.HANDSHAKE_REJECTED.reason, 50);\n                }).then(function () {\n                    message.dispose();\n                });\n            });\n\n            /**\n             * Emit handshake event from the server\n             */\n            debug('Emitting server\\'s \"handshake\" event...');\n            var handshakeListener = this.server.emit('handshake', this, message);\n\n            if (!handshakeListener) {\n                debug('There is no handshake listener, resolving the handshake by default...');\n                message.resolve();\n            }\n        }\n\n        /**\n         * On \"ping\" message handler. Reply with pong.\n         *\n         * @param {Message} message\n         * @ignore\n         */\n\n    }, {\n        key: 'onPingMessage_',\n        value: function onPingMessage_(message) {\n            debug('Ping received, responding with \"pong\"...');\n\n            this.sendWithoutResponse_(message.createResponse(null, 'pong')).catch(function (err) {\n                return debug('Ping response failed to send back, ignoring for now...', err);\n            });\n        }\n\n        /**\n         * A message is recieved, and its response is expected.\n         *\n         * @param {Message} message\n         * @ignore\n         */\n\n    }, {\n        key: 'onResponseMessage_',\n        value: function onResponseMessage_(message) {\n            var deferred = this.deferreds_[message.id];\n            if (!deferred) return;\n\n            if (message.err) {\n                debug('Response (rejecting) recieved: ' + message);\n                var err = new LineError(ServerConnection.ErrorCode.MESSAGE_REJECTED, 'Message is rejected by server, check payload.', message.err);\n                deferred.reject(err);\n            } else {\n                debug('Response (resolving) recieved: ' + message);\n                deferred.resolve(message.payload);\n            }\n\n            delete this.deferreds_[message.id];\n        }\n\n        /**\n         * A message is arrived without waiting its response.\n         *\n         * @param {Message} message\n         * @ignore\n         */\n\n    }, {\n        key: 'onMessageWithoutResponse_',\n        value: function onMessageWithoutResponse_(message) {\n            debug('Message without response: name=\"' + message.name + '\"');\n            this.emit(message.name, message);\n        }\n\n        /**\n         * A message is arrived and the client is expecting its response.\n         *\n         * @param {Message} message\n         * @ignore\n         */\n\n    }, {\n        key: 'onMessageWithResponse_',\n        value: function onMessageWithResponse_(message) {\n            var _this3 = this;\n\n            debug('Message with response: name=\"' + message.name + '\" id=\"' + message.id + '\"');\n\n            message.once('resolved', function (payload) {\n                debug('Message #' + message.id + ' is resolved, sending response...');\n                _this3.sendWithoutResponse_(message.createResponse(null, payload)).catch(function (err) {\n                    _this3.emit(ServerConnection.Event.ERROR, new LineError(ServerConnection.ErrorCode.MESSAGE_NOT_RESPONDED, 'Message (name=\"' + message.name + '\" id=\"' + message.id + '\") could not responded (resolve)', err));\n                }).then(function () {\n                    return message.dispose();\n                });\n            });\n\n            message.once('rejected', function (err) {\n                debug('Message #' + message.id + ' is rejected, sending response...');\n                _this3.sendWithoutResponse_(message.createResponse(err)).catch(function (err) {\n                    _this3.emit(ServerConnection.Event.ERROR, new LineError(ServerConnection.ErrorCode.MESSAGE_NOT_RESPONDED, 'Message (name=\"' + message.name + '\" id=\"' + message.id + '\") could not responded (reject)', err));\n                }).then(function () {\n                    return message.dispose();\n                });\n            });\n\n            this.emit(message.name, message);\n        }\n\n        /**\n         * Native \"error\" event.\n         *\n         * @param {Error} err\n         * @ignore\n         */\n\n    }, {\n        key: 'onError_',\n        value: function onError_(err) {\n            debug('Native \"error\" event recieved, emitting line\\'s \"error\" event: ' + err);\n            this.emit(ServerConnection.Event.ERROR, err);\n        }\n\n        /**\n         * Native \"close\" event.\n         *\n         * @param {number} code\n         * @param {string=} reason\n         * @ignore\n         */\n\n    }, {\n        key: 'onClose_',\n        value: function onClose_(code, reason) {\n            debug('Native \"close\" event recieved with code ' + code + ': ' + reason);\n            debug('Removing connection from all rooms, rejecting all waiting messages...');\n\n            this.handshakeTimeout_ && clearTimeout(this.handshakeTimeout_);\n            this.autoPing_.cancel();\n            this.server.rooms.removeFromAll(this);\n            this.server.rooms.root.remove(this);\n            this.rejectAllDeferreds_(new LineError(ServerConnection.ErrorCode.DISCONNECTED, 'Socket connection closed!'));\n\n            debug('Emitting line\\'s \"close\" event...');\n            this.state = ServerConnection.State.DISCONNECTED;\n            this.emit(ServerConnection.Event.DISCONNECTED, code, reason);\n        }\n\n        /**\n         * Changes connection's id, it's random by default. This method is helpful if you already have\n         * custom identification for your clients. You must do this before handshake resolved. If\n         * handshake is already resolved or there is conflict, this method will throw error.\n         *\n         * Throws:\n         * - `ServerConnection.ErrorCode.HANDSHAKE_ENDED`: Id could not be changed after handshake\n         * - `ServerConnection.ErrorCode.ID_CONFLICT`: There is alrady another connection with provided id.\n         *\n         * @param {string} newId New connection id\n         * @memberOf ServerConnection\n         * @example\n         * server.on(Server.Event.HANDSHAKE, (connection, handshake) => {\n         *   // Assuming client's `options.handshake.payload` is something like `{authToken: '...'}`\n         *\n         *   // Imaginary db\n         *   db.find(handshake.payload.authToken, (record) => {\n         *     if (!record) return handshake.reject(new Error('Invalid auth token'));\n         *     connection.setId(record.id);\n         *     handshake.resolve(record);\n         *   });\n         * });\n         */\n\n    }, {\n        key: 'setId',\n        value: function setId(newId) {\n            if (this.state != ServerConnection.State.AWAITING_HANDSHAKE) {\n                throw new LineError(ServerConnection.ErrorCode.HANDSHAKE_ENDED, 'Handshake already ended, you cannot change connection id anymore');\n            }\n\n            if (this.server.getConnectionById(newId)) {\n                throw new LineError(ServerConnection.ErrorCode.ID_CONFLICT, 'Conflict! There is already connection with id ' + newId);\n            }\n\n            this.id = newId;\n        }\n\n        /**\n         * Joins the connection into provided room. If there is no room, it will be created automatically.\n         *\n         * @param {string} roomName\n         * @memberOf ServerConnection\n         */\n\n    }, {\n        key: 'joinRoom',\n        value: function joinRoom(roomName) {\n            this.server.rooms.add(roomName, this);\n        }\n\n        /**\n         * Leaves the connection from provided room.\n         *\n         * @param {string} roomName\n         * @memberOf ServerConnection\n         */\n\n    }, {\n        key: 'leaveRoom',\n        value: function leaveRoom(roomName) {\n            this.server.rooms.remove(roomName, this);\n        }\n\n        /**\n         * Gets the joined room names.\n         *\n         * @returns {Array<string>}\n         * @memberOf ServerConnection\n         */\n\n    }, {\n        key: 'getRooms',\n        value: function getRooms() {\n            return this.server.rooms.getRoomsOf(this);\n        }\n\n        /**\n         * Sends a message to client with awaiting its response. This method returns a promise\n         * which resolves the payload parameter will be passed into `message.resolve(...)` in client-side.\n         *\n         * If client rejects the message with `message.reject(...)`, this promise will be rejected with\n         * `ServerConnection.ErrorCode.MESSAGE_REJECTED`. You can access the original error object with `err.payload`.\n         *\n         * Rejections:\n         * - `ServerConnection.ErrorCode.INVALID_JSON`: Could not stringify the message payload. Probably circular json.\n         * - `ServerConnection.ErrorCode.MESSAGE_REJECTED`: Message is explicitly rejected by the client.\n         * - `ServerConnection.ErrorCode.MESSAGE_TIMEOUT`: Message response did not arrived, timeout exceeded.\n         * - `ServerConnection.ErrorCode.DISCONNECTED`: Client is not connected (& handshake resolved) or connection is closing\n         * - `ServerConnection.ErrorCode.WEBSOCKET_ERROR`: Native websocket error\n         *\n         * @param {string} name\n         * @param {any=} payload\n         * @param {number=} timout\n         * @returns {Promise<any>}\n         * @memberOf ServerConnection\n         * @example\n         * connection\n         *   .send('hello', {optional: 'payload'})\n         *   .then((data) => {\n         *     // Message is resolved by client\n         *   })\n         *   .catch((err) => {\n         *     // Could not send message\n         *     // or\n         *     // Client rejected the message!\n         *   });\n         */\n\n    }, {\n        key: 'send',\n        value: function send(name, payload, opt_timeout) {\n            // This method is for external usage!\n            if (this.state != ServerConnection.State.CONNECTED) {\n                return Promise.reject(new LineError(ServerConnection.ErrorCode.DISCONNECTED, 'Could not send message, client is not connected.'));\n            }\n\n            try {\n                var message = new Message({ name: name, payload: payload });\n                return this.send_(message, opt_timeout);\n            } catch (err) {\n                // `err` can only be Message.ErrorCode.INVALID_JSON\n                return Promise.reject(new LineError(ServerConnection.ErrorCode.INVALID_JSON, 'Could not send message, \"payload\" stringify error. Probably circular json issue.'));\n            }\n        }\n\n        /**\n         * Sends a message to client without waiting its response. This method returns a promise\n         * that resolves with nothing if the message is successfully sent.\n         *\n         * Rejections:\n         * - `ServerConnection.ErrorCode.INVALID_JSON`: Could not stringify the message payload. Probably circular json.\n         * - `ServerConnection.ErrorCode.DISCONNECTED`: Client is not connected (& handshake resolved) or connection is closing\n         * - `ServerConnection.ErrorCode.WEBSOCKET_ERROR`: Native websocket error\n         *\n         * @param {string} name\n         * @param {any=} payload\n         * @returns {Promise}\n         * @memberOf ServerConnection\n         * @example\n         * connection\n         *   .sendWithoutResponse('hello', {optional: 'payload'})\n         *   .then(() => {\n         *     // Message sent successfully\n         *   })\n         *   .catch((err) => {\n         *     // Message could not be sent to client\n         *   })\n         */\n\n    }, {\n        key: 'sendWithoutResponse',\n        value: function sendWithoutResponse(name, payload) {\n            // For external usage\n            if (this.state != ServerConnection.State.CONNECTED) {\n                return Promise.reject(new LineError(ServerConnection.ErrorCode.DISCONNECTED, 'Could not send message, client is not connected.'));\n            }\n\n            try {\n                var message = new Message({ name: name, payload: payload }); // Can throw Message.ErrorCode.INVALID_JSON\n                return this.sendWithoutResponse_(message);\n            } catch (err) {\n                // `err` can only be Message.ErrorCode.INVALID_JSON\n                return Promise.reject(new LineError(ServerConnection.ErrorCode.INVALID_JSON, 'Could not send message, \"payload\" stringify error. Probably circular json issue.'));\n            }\n        }\n\n        /**\n         * Base method for sending a message with timeout. Please favor this method internally\n         * instead of using `send` method.\n         *\n         * Rejections:\n         * - `ServerConnection.ErrorCode.MESSAGE_REJECTED`: Message is explicitly rejected by the client.\n         * - `ServerConnection.ErrorCode.MESSAGE_TIMEOUT`: Message response did not arrived, timeout exceeded.\n         * - `ServerConnection.ErrorCode.DISCONNECTED`: Client is not connected (& handshake resolved) or connection is closing\n         * - `ServerConnection.ErrorCode.WEBSOCKET_ERROR`: Native websocket error\n         *\n         * @param {Message} message\n         * @param {number=} opt_timeout\n         * @returns {Promise}\n         * @ignore\n         */\n\n    }, {\n        key: 'send_',\n        value: function send_(message, opt_timeout) {\n            var _this4 = this;\n\n            var timeout = isInteger(opt_timeout) && opt_timeout >= 0 ? opt_timeout : this.server.options.responseTimeout;\n            message.setId();\n\n            var deferred = this.deferreds_[message.id] = new Deferred({\n                onExpire: function onExpire() {\n                    delete _this4.deferreds_[message.id];\n                },\n                timeout: timeout\n            });\n\n            return this.sendWithoutResponse_(message).then(function () {\n                return deferred;\n            }).catch(function (err) {\n                deferred.dispose();\n\n                // Convert expired -> timeout error\n                if (err instanceof LineError && err.code == Deferred.ErrorCode.EXPIRED) {\n                    throw new LineError(ServerConnection.ErrorCode.MESSAGE_TIMEOUT, 'Message timeout! Its response did not recived after ' + timeout + ' ms');\n                }\n\n                throw err;\n            });\n        }\n\n        /**\n         * Base method for sending a message without response. Please favor this method internally\n         * instead of using `sendWithoutResponse` method.\n         *\n         * Rejections:\n         * - `ServerConnection.ErrorCode.DISCONNECTED`: Client is not connected (& handshake resolved) or connection is closing\n         * - `ServerConnection.ErrorCode.WEBSOCKET_ERROR`: Native websocket error\n         *\n         * @param {Message} message\n         * @returns {Promise}\n         * @ignore\n         */\n\n    }, {\n        key: 'sendWithoutResponse_',\n        value: function sendWithoutResponse_(message) {\n            var _this5 = this;\n\n            if (!this.socket || this.server.wslib == 'websocket' && !this.socket.connected || (this.server.wslib == 'ws' || this.server.wslib == 'uws') && this.socket.readyState != 1) {\n                return Promise.reject(new LineError(ServerConnection.ErrorCode.DISCONNECTED, 'Could not send message, there is no open connection.'));\n            }\n\n            return new Promise(function (resolve, reject) {\n                debug('Sending message: ' + message);\n                var messageStr = message.toString();\n\n                _this5.socket.send(messageStr, function (err) {\n                    if (err) {\n                        return reject(new LineError(ServerConnection.ErrorCode.WEBSOCKET_ERROR, 'Could not send message, native websocket error, check payload.', err));\n                    }\n\n                    resolve();\n                });\n            });\n        }\n\n        /**\n         * Pings the client. If there is no respose, closes the connection.\n         *\n         * @returns {Promise}\n         * @memberOf ServerConnection\n         */\n\n    }, {\n        key: 'ping',\n        value: function ping() {\n            var _this6 = this;\n\n            debug('Pinging...');\n            return this.send_(new Message({ name: Message.Name.PING })).catch(function (err) {\n                // No matter what error is, start disconnection process\n                debug('Auto-ping failed, manually disconnecting...');\n                _this6.close(CloseStatus.PING_FAILED.code, CloseStatus.PING_FAILED.reason);\n                throw new LineError(ServerConnection.ErrorCode.PING_ERROR, 'Ping failed, manually disconnecting...', err);\n            });\n        }\n\n        /**\n         * Gracefully closes the client connection.\n         *\n         * @param {number=} code\n         * @param {string=} reason\n         * @param {number=} delay\n         * @returns {Promise}\n         */\n\n    }, {\n        key: 'close',\n        value: function close(code, reason, delay) {\n            var _this7 = this;\n\n            debug('Closing the connection in ' + (delay || 0) + ' ms...');\n            return new Promise(function (resolve) {\n                setTimeout(function () {\n                    _this7.socket.close(code || 1000, reason);\n                    resolve();\n                }, delay || 0);\n            });\n        }\n\n        /**\n         * Reject all the awaiting deferred with given error.\n         *\n         * @param {Error} err An error object to reject all awaiting deferreds.\n         * @ignore\n         */\n\n    }, {\n        key: 'rejectAllDeferreds_',\n        value: function rejectAllDeferreds_(err) {\n            forEach(this.deferreds_, function (deferred) {\n                return deferred.reject(err);\n            });\n            this.deferreds_ = {};\n        }\n    }]);\n\n    return ServerConnection;\n}(EventEmitterExtra);\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\n\n\nServerConnection.ErrorCode = {\n    /**\n     * This error can be seen in rejection of `serverConnection.send()` method.\n     */\n    MESSAGE_TIMEOUT: 'scMessageTimeout',\n    /**\n     * This error can be seen in rejection of `serverConnection.send()` method,\n     * which again indicates that server is explicitly rejected the message.\n     */\n    MESSAGE_REJECTED: 'scMessageRejected',\n    /**\n     * When the response of a message failed to send to client, this error\n     * will be emitted in `ServerConnection.Event.ERROR` event.\n     */\n    MESSAGE_NOT_RESPONDED: 'cMessageNotResponded',\n    /**\n     * Indicates an error while json parsing/stringify.\n     */\n    INVALID_JSON: 'scInvalidJson',\n    /**\n     * This error can be thrown in `serverConnection.setId()`. Connection id\n     * cannot be set after handshake.\n     */\n    HANDSHAKE_ENDED: 'scHandshakeEnded',\n    /**\n     * This error can be seen while using `serverConnection.setId()`. If there is\n     * already connection with that id, this error will be thrown.\n     */\n    ID_CONFLICT: 'scIdConflict',\n    /**\n     * This error indicates client is disconnected.\n     */\n    DISCONNECTED: 'scDisconnected',\n    /**\n     * This error is for native websocket errors.\n     */\n    WEBSOCKET_ERROR: 'scWebsocketError',\n    /**\n     * This error can be seen in rejection of `serverConnection.ping()` method.\n     */\n    PING_ERROR: 'scPingError'\n};\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nServerConnection.State = {\n    /**\n     * `awaitingHandshake` Connection is open but handshake is not completed yet.\n     */\n    AWAITING_HANDSHAKE: 'awaitingHandshake',\n    /**\n     * `connected` Connection is open and handshake resolved.\n     */\n    CONNECTED: 'connected',\n    /**\n     * `disconnected` There is no open connection.\n     */\n    DISCONNECTED: 'disconnected'\n};\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nServerConnection.Event = {\n    /**\n     * `_error`\n     */\n    ERROR: '_error',\n    /**\n     * `_close`\n     */\n    DISCONNECTED: '_disconnected'\n};\n\nmodule.exports = ServerConnection;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar filter = __webpack_require__(21);\nvar forEach = __webpack_require__(5);\nvar map = __webpack_require__(25);\nvar Room = __webpack_require__(18);\n\nvar Rooms = function () {\n    function Rooms() {\n        _classCallCheck(this, Rooms);\n\n        this.rooms = {};\n        this.root = new Room();\n    }\n\n    _createClass(Rooms, [{\n        key: 'add',\n        value: function add(roomName, connection) {\n            if (!this.rooms[roomName]) this.rooms[roomName] = new Room(roomName);\n\n            this.rooms[roomName].add(connection);\n        }\n    }, {\n        key: 'remove',\n        value: function remove(roomName, connection) {\n            if (!this.rooms[roomName]) return;\n\n            this.rooms[roomName].remove(connection);\n\n            if (!this.rooms[roomName].getConnectionsCount()) delete this.rooms[roomName];\n        }\n    }, {\n        key: 'getRoomsOf',\n        value: function getRoomsOf(connection) {\n            return map(filter(this.rooms, function (room) {\n                return room.getConnectionById(connection.id);\n            }), 'name');\n        }\n    }, {\n        key: 'getRoom',\n        value: function getRoom(room) {\n            return this.rooms[room];\n        }\n    }, {\n        key: 'removeFromAll',\n        value: function removeFromAll(connection) {\n            var _this = this;\n\n            var rooms = this.getRoomsOf(connection);\n            forEach(rooms, function (roomName) {\n                return _this.rooms[roomName].remove(connection);\n            });\n        }\n    }]);\n\n    return Rooms;\n}();\n\nmodule.exports = Rooms;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"http\");\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"https\");\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"uws\");\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"websocket\");\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"ws\");\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\"use strict\";\n'use strict';\n\nmodule.exports = {\n    INTERNAL_ERROR: { code: 4200, reason: 'Internal error' },\n    PING_FAILED: { code: 4201, reason: 'Ping failed' },\n    HANDSHAKE_FAILED: { code: 4202, reason: 'Handshake failed' },\n    HANDSHAKE_REJECTED: { code: 4203, reason: 'Handshake rejected' },\n    DISCONNECT_TIMEOUT: { code: 4204, reason: 'Disconnect timeout' },\n    DISPOSED: { code: 4205, reason: 'Client disposed' },\n    UNKNOWN_ERROR: { code: 4299, reason: 'Unknown error' }\n};\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar LineError = __webpack_require__(0);\n\nvar Deferred = function () {\n    function Deferred() {\n        var _this = this;\n\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n            _ref$handler = _ref.handler,\n            handler = _ref$handler === undefined ? function () {} : _ref$handler,\n            _ref$onExpire = _ref.onExpire,\n            onExpire = _ref$onExpire === undefined ? function () {} : _ref$onExpire,\n            _ref$timeout = _ref.timeout,\n            timeout = _ref$timeout === undefined ? 0 : _ref$timeout;\n\n        _classCallCheck(this, Deferred);\n\n        this.resolve_ = null;\n        this.reject_ = null;\n\n        this.timeout_ = null;\n        this.timeoutDuration_ = timeout;\n        this.onExpire_ = onExpire;\n        this.isFinished_ = false;\n\n        this.promise = new Promise(function (resolve, reject) {\n            _this.resolve_ = resolve;\n            _this.reject_ = reject;\n\n            try {\n                handler(_this);\n            } catch (err) {\n                _this.reject(err);\n            }\n        });\n\n        if (timeout > 0) {\n            this.timeout_ = setTimeout(this.expire.bind(this), timeout);\n        }\n    }\n\n    _createClass(Deferred, [{\n        key: 'resolve',\n        value: function resolve(data) {\n            if (this.isFinished_) return;\n\n            this.isFinished_ = true;\n            this.clearTimeout_();\n            this.resolve_(data);\n        }\n    }, {\n        key: 'reject',\n        value: function reject(err) {\n            if (this.isFinished_) return;\n\n            this.isFinished_ = true;\n            this.clearTimeout_();\n            this.reject_(err);\n        }\n    }, {\n        key: 'expire',\n        value: function expire() {\n            this.isFinished_ = true;\n            this.clearTimeout_();\n            this.onExpire_();\n            this.reject_(new LineError(Deferred.ErrorCode.EXPIRED, 'Timeout ' + this.timeoutDuration_ + ' ms exceed'));\n        }\n    }, {\n        key: 'dispose',\n        value: function dispose() {\n            this.isFinished_ = true;\n            this.clearTimeout_();\n        }\n    }, {\n        key: 'then',\n        value: function then() {\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n            }\n\n            return this.promise.then.apply(this.promise, args);\n        }\n    }, {\n        key: 'catch',\n        value: function _catch() {\n            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                args[_key2] = arguments[_key2];\n            }\n\n            return this.promise.catch.apply(this.promise, args);\n        }\n    }, {\n        key: 'clearTimeout_',\n        value: function clearTimeout_() {\n            if (this.timeout_) {\n                clearTimeout(this.timeout_);\n                this.timeout_ = null;\n            }\n        }\n    }]);\n\n    return Deferred;\n}();\n\nDeferred.ErrorCode = {\n    EXPIRED: 'dExpired'\n};\n\nmodule.exports = Deferred;\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\n\nvar assign = __webpack_require__(1);\n\n// http://stackoverflow.com/a/6248722\nfunction generateDummyId() {\n    var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;\n\n    return (\"0000\" + (Math.random() * Math.pow(36, length) << 0).toString(36)).slice(-length);\n}\n\nmodule.exports = { generateDummyId: generateDummyId };\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar forEach = __webpack_require__(5);\nvar clone = __webpack_require__(19);\nvar Message = __webpack_require__(2);\nvar debug = __webpack_require__(3)('line:server:room');\nvar LineError = __webpack_require__(0);\n\n/**\n * Line room class.\n *\n * @private\n * @class ServerRoom\n * @param {string} name Room name\n * @property {string} name\n */\n\nvar ServerRoom = function () {\n    function ServerRoom(name) {\n        var connections = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, ServerRoom);\n\n        this.name = name;\n        this.connections = connections;\n    }\n\n    /**\n     * Adds a connection into room.\n     * @param {ServerConnection} connection\n     */\n\n\n    _createClass(ServerRoom, [{\n        key: 'add',\n        value: function add(connection) {\n            // TODO: Check current existing connection maybe?\n            this.connections[connection.id] = connection;\n        }\n\n        /**\n         * Removes a connection from room.\n         * @param {ServerConnection} connection\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'remove',\n        value: function remove(connection) {\n            if (connection != this.connections[connection.id]) {\n                debug('[' + (this.name || 'root') + '] Did not remove \"' + connection.id + '\", connection instance is not added or different');\n                return false;\n            }\n\n            debug('[' + (this.name || 'root') + '] Removing \"' + connection.id + '\"');\n            delete this.connections[connection.id];\n            return true;\n        }\n\n        /**\n         * Gets a connection by id.\n         * @param {string} connectionId\n         * @returns {?ServerConnection}\n         */\n\n    }, {\n        key: 'getConnectionById',\n        value: function getConnectionById(connectionId) {\n            return this.connections[connectionId];\n        }\n\n        /**\n         * Gets all connections in the room. Returns a object where keys are\n         * connection id and values are ServerConnection.\n         * @returns {{string: ServerConnection}}\n         */\n\n    }, {\n        key: 'getConnections',\n        value: function getConnections() {\n            return clone(this.connections);\n        }\n\n        /**\n         * Returns the total connection count in room.\n         * @returns {number}\n         */\n\n    }, {\n        key: 'getConnectionsCount',\n        value: function getConnectionsCount() {\n            return Object.keys(this.connections).length;\n        }\n    }, {\n        key: 'broadcast_',\n        value: function broadcast_(message) {\n            var _this = this;\n\n            forEach(this.connections, function (connection) {\n                connection.sendWithoutResponse_(message).catch(function (err) {\n                    debug('[' + (_this.name || 'root') + '] Could not send \"' + message.name + '\" to \"' + connection.id + '\" while broadcasting, ignoring...');\n                });\n            });\n        }\n\n        /**\n         * Broadcast a message to all connections in the room.\n         * @param {string} name\n         * @param {any=} payload\n         */\n\n    }, {\n        key: 'broadcast',\n        value: function broadcast(name, payload) {\n            var message = new Message({ name: name, payload: payload }); // Can throw INVALID_JSON\n            this.broadcast_(message);\n        }\n    }]);\n\n    return ServerRoom;\n}();\n\nmodule.exports = ServerRoom;\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/clone\");\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/debounce\");\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/filter\");\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isFunction\");\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isString\");\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isUndefined\");\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/map\");\n\n/***/ },\n/* 26 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/values\");\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"uuid\");\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Connection = __webpack_require__(8);\nvar Message = __webpack_require__(2);\nvar Rooms = __webpack_require__(9);\nvar EventEmitterExtra = __webpack_require__(4);\nvar debug = __webpack_require__(3)('line:server');\nvar LineError = __webpack_require__(0);\nvar assign = __webpack_require__(1);\nvar isInteger = __webpack_require__(6);\nvar http = __webpack_require__(10);\nvar https = __webpack_require__(11);\n\nvar WebSocketServer = void 0;\nvar wslib = void 0;\ntry {\n    WebSocketServer = __webpack_require__(12).Server;\n    wslib = 'uws';\n} catch (err) {\n    try {\n        debug('Could not find module uws lib, falling back to websocket lib', err);\n        WebSocketServer = __webpack_require__(13).server;\n        wslib = 'websocket';\n    } catch (err) {\n        debug('Could not find module websocket lib, falling back to ws lib', err);\n        WebSocketServer = __webpack_require__(14).Server;\n        wslib = 'ws';\n    }\n}\n\nconsole.log('Continuing with', wslib);\n\n/**\n * Line Server Class\n *\n * @class Server\n * @extends {EventEmitterExtra}\n * @param {Object=} options Options object.\n * @param {string=} options.host The hostname where to bind the server. [Inherited from uws.](https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketserveroptions-callback)\n * @param {number=} options.port The port where to bind the server. [Inherited from uws.](https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketserveroptions-callback)\n * @param {http.Server=} options.server A pre-created Node.js HTTP server. If provided, `host` and `port`\n *      will ignored. [Inherited from uws.](https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketserveroptions-callback)\n * @param {string=} options.path Accept only connections matching this path. [Inherited from uws](https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketserveroptions-callback)\n * @param {number=} options.responseTimeout Default timeout duration (in ms) for message responses. Default: `10000` (10 seconds)\n * @param {number=} options.handshakeTimeout This is the duration how long a client can stay connected\n *      without handshake. Default `60000` (1 minute).\n * @param {number=} options.pingInterval Ping interval in ms. Default: 15 seconds.\n * @example\n * const Server = require('line-socket/server');\n * const server = new Server({\n *   port: 8080\n * });\n */\n\nvar Server = function (_EventEmitterExtra) {\n    _inherits(Server, _EventEmitterExtra);\n\n    function Server() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Server);\n\n        var _this = _possibleConstructorReturn(this, (Server.__proto__ || Object.getPrototypeOf(Server)).call(this));\n\n        _this.wslib = wslib;\n\n        _this.options = assign({\n            responseTimeout: 10000,\n            handshakeTimeout: 60000,\n            pingInterval: 15000\n        }, options);\n\n        if (!isInteger(_this.options.responseTimeout) || _this.options.responseTimeout < 0) throw new LineError(Server.ErrorCode.INVALID_OPTIONS, '\"options.responseTimeout\" must be a positive integer or zero');\n\n        if (!isInteger(_this.options.handshakeTimeout) || _this.options.handshakeTimeout < 0) throw new LineError(Server.ErrorCode.INVALID_OPTIONS, '\"options.handshakeTimeout\" must be a positive integer or zero');\n\n        if (!isInteger(_this.options.pingInterval) || _this.options.pingInterval < 0) throw new LineError(Server.ErrorCode.INVALID_OPTIONS, '\"options.pingInterval\" must be a positive integer or zero');\n\n        _this.rooms = new Rooms();\n\n        debug('Initalizing with options: ' + JSON.stringify(_this.options));\n        return _this;\n    }\n\n    /**\n     * Starts the server.\n     *\n     * @returns {Promise}\n     * @memberOf Server\n     * @example\n     * server\n     *   .start()\n     *   .then(() => {\n     *     console.log('Server started');\n     *   })\n     *   .catch((err) => {\n     *     console.log('Server could not started', err);\n     *   });\n     */\n\n\n    _createClass(Server, [{\n        key: 'start',\n        value: function start() {\n            var _this2 = this;\n\n            if (this.server) {\n                return Promise.reject(new LineError(Server.ErrorCode.INVALID_ACTION, 'Could not start server, already started!'));\n            }\n\n            debug('Starting with port \"' + this.options.port + '\" ...');\n\n            if (this.wslib == 'websocket') {\n                if (this.options.secure) this.httpServer = https.createServer();else this.httpServer = http.createServer();\n\n                this.server = new WebSocketServer({ httpServer: this.httpServer });\n                this.bindEvents_();\n\n                return new Promise(function (resolve, reject) {\n                    _this2.httpServer.listen(_this2.options.port, function (err) {\n                        if (err) {\n                            debug('Could not start: ' + err);\n                            return reject(new LineError(Server.ErrorCode.WEBSOCKET_ERROR, 'Could not start the server, websocket error, check payload', err));\n                        }\n\n                        resolve();\n                    });\n                });\n            } else {\n                return new Promise(function (resolve, reject) {\n                    _this2.server = new WebSocketServer(_this2.options, function (err) {\n                        if (err) {\n                            debug('Could not start: ' + err);\n                            return reject(new LineError(Server.ErrorCode.WEBSOCKET_ERROR, 'Could not start the server, websocket error, check payload', err));\n                        }\n\n                        resolve();\n                    });\n\n                    _this2.bindEvents_();\n                });\n            }\n        }\n\n        /**\n         * Stops the server.\n         *\n         * @returns {Promise}\n         * @memberOf Server\n         * @example\n         * server\n         *   .stop()\n         *   .then(() => {\n         *     console.log('Server stopped');\n         *   })\n         *   .catch((err) => {\n         *     console.log('Server could not stopped', err);\n         *   });\n         */\n\n    }, {\n        key: 'stop',\n        value: function stop() {\n            var _this3 = this;\n\n            if (!this.server) {\n                debug('Could not stop server. Server is probably not started, or already stopped.');\n                return Promise.reject(new LineError(Server.ErrorCode.INVALID_ACTION, 'Could not stop server. Server is probably not started, or already stopped!'));\n            }\n\n            return new Promise(function (resolve) {\n                debug('Closing and disposing the server...');\n                if (_this3.wslib == 'websocket') {\n                    _this3.server.shutDown();\n                    _this3.httpServer.close(function () {\n                        _this3.server = null;\n                        resolve();\n                    });\n                } else {\n                    _this3.server.close();\n                    _this3.server = null;\n                    resolve();\n                }\n            });\n        }\n\n        /**\n         * Binds websocket server events.\n         *\n         * @ignore\n         */\n\n    }, {\n        key: 'bindEvents_',\n        value: function bindEvents_() {\n            debug('Binding server events...');\n\n            if (this.wslib == 'websocket') {\n                this.server.on('request', this.onRequest_.bind(this));\n                this.server.on('connect', this.onConnection_.bind(this));\n            } else {\n                this.server.on('connection', this.onConnection_.bind(this));\n                this.server.on('headers', this.onHeaders_.bind(this));\n            }\n\n            this.server.on('error', this.onError_.bind(this));\n        }\n    }, {\n        key: 'onRequest_',\n        value: function onRequest_(request) {\n            var connection = request.accept(null, request.origin);\n        }\n\n        /**\n         * Native \"connection\" event handler.\n         *\n         * @param {WebSocket} socket\n         * @ignore\n         */\n\n    }, {\n        key: 'onConnection_',\n        value: function onConnection_(socket) {\n            debug('Native \"connection\" event recieved, creating line connection...');\n            var connection = new Connection(socket, this);\n        }\n\n        /**\n         * Native \"headers\" event handler.\n         *\n         * @param {Array} headers\n         * @ignore\n         */\n\n    }, {\n        key: 'onHeaders_',\n        value: function onHeaders_(headers) {\n            debug('Native \"headers\" event recieved, emitting line\\'s \"headers\" event... (' + headers + ')');\n            this.emit(Server.Event.HEADERS, headers);\n        }\n\n        /**\n         * Native \"error\" event handler.\n         *\n         * @param {Error} err\n         * @ignore\n         */\n\n    }, {\n        key: 'onError_',\n        value: function onError_(err) {\n            debug('Native \"error\" event recieved, emitting line\\'s \"error\" event... (' + err + ')');\n            this.emit(Server.Event.ERROR, err);\n        }\n\n        /**\n         * Returns a object where keys are connection id and values are ServerConnection.\n         *\n         * @returns {{string: ServerConnection}}\n         * @memberOf Server\n         */\n\n    }, {\n        key: 'getConnections',\n        value: function getConnections() {\n            return this.rooms.root.getConnections();\n        }\n\n        /**\n         * Gets a connection by id\n         *\n         * @param {string} id Unique connection id, which can be accessed at `connection.id`\n         * @returns {?ServerConnection}\n         * @memberOf Server\n         * @example\n         * const connection = server.getConnectionById('someId');\n         *\n         * if (connection) {\n         *   connection.send('hello', {optional: 'payload'});\n         * }\n         */\n\n    }, {\n        key: 'getConnectionById',\n        value: function getConnectionById(id) {\n            return this.rooms.root.getConnectionById(id);\n        }\n\n        /**\n         * Broadcasts a message to all the connected (& handshaked) clients.\n         *\n         * @param {string} name Message name\n         * @param {any=} payload Optional message payload.\n         * @memberOf Server\n         * @example\n         * server.broadcast('hello', {optional: 'payload'});\n         */\n\n    }, {\n        key: 'broadcast',\n        value: function broadcast(name, payload) {\n            debug('Broadcasting \"' + name + '\" message...');\n            this.rooms.root.broadcast(name, payload); // Can throw INVALID_JSON\n        }\n\n        /**\n         * Gets a room by name.\n         * @param {string} room Room name\n         * @returns {?ServerRoom}\n         */\n\n    }, {\n        key: 'getRoom',\n        value: function getRoom(room) {\n            return this.rooms.getRoom(room);\n        }\n\n        /**\n         * Gets all the rooms of a connection.\n         * @param {ServerConnection} connection\n         * @returns {Array.<string>} Array of room names.\n         */\n\n    }, {\n        key: 'getRoomsOf',\n        value: function getRoomsOf(connection) {\n            return this.rooms.getRoomsOf(connection);\n        }\n\n        /**\n         * Remove a connection from all the rooms.\n         * @param {ServerConnection} connection\n         */\n\n    }, {\n        key: 'removeFromAllRooms',\n        value: function removeFromAllRooms(connection) {\n            this.rooms.removeFromAll(connection);\n        }\n    }]);\n\n    return Server;\n}(EventEmitterExtra);\n\n// Expose internal classes\n\n\nServer.Message = Message;\nServer.Connection = Connection;\nServer.Error = LineError;\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nServer.ErrorCode = {\n    /**\n     * When constructing `new Server()`, this error could be thrown.\n     */\n    INVALID_OPTIONS: 'sInvalidOptions',\n    /**\n     * This error can be seen in rejection of `server.start()` or `server.stop()` methods.\n     */\n    INVALID_ACTION: 'sInvalidAction',\n    /**\n     * This error is for native websocket errors.\n     */\n    WEBSOCKET_ERROR: 'sWebsocketError'\n};\n\n/**\n * @static\n * @readonly\n * @enum {string}\n * @example\n * server.on('connection', (connection) => {\n *   connection.send('hello');\n *   ...\n * });\n *\n * // or better, you can use enums\n *\n * server.on(Server.Event.CONNECTION, (connection) => {\n *   connection.send('hello');\n *   ...\n * });\n *\n * // If you want to authorize your client\n * server.on('handshake', (connection, handshake) => {\n *   if (handshake.payload && handshake.payload.authToken == '...')\n *     handshake.resolve({welcome: 'bro'});\n *   else\n *     handshake.reject(new Error('Invalid auth token'));\n * });\n */\nServer.Event = {\n    /**\n     * `handshake` When a client connection is established, this event will be fired before\n     * `connection` event. Please note that, this event has nothing in common with native websocket\n     * handshaking process. If you want to authorize your clients, you must listen this event and\n     * call `handshake.resolve(...)` or `handshake.reject(...)` accordingly. If you do not consume\n     * this events, all the client connections will be accepted.\n     *\n     * ```\n     * function (connection, handshake) {}\n     * ```\n     *\n     * where `connection` is `ServerConnection` and `handshake` is a `Message` instance.\n     */\n    HANDSHAKE: 'handshake',\n    /**\n     * `connection` This event will fire on a client connects **after successful handshake**.\n     *\n     * ```\n     * function (connection) {}\n     * ```\n     *\n     * where `connection` is a `ServerConnection` instance.\n     */\n    CONNECTION: 'connection',\n    /**\n     * `'headers'` Inherited from uws, [see docs](https://github.com/websockets/ws/blob/master/doc/ws.md#event-headers)\n     */\n    HEADERS: 'headers',\n    /**\n     * `'error'` Inherited from uws, [see docs](https://github.com/websockets/ws/blob/master/doc/ws.md#event-error)\n     */\n    ERROR: 'error'\n};\n\nmodule.exports = Server;\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// server.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmory imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmory exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tObject.defineProperty(exports, name, {\n \t\t\tconfigurable: false,\n \t\t\tenumerable: true,\n \t\t\tget: getter\n \t\t});\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 28);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 528ab750088ed0dd8c3f","function LineError(code, message, payload) {\n    this.name = 'LineError';\n    this.message = message;\n    this.code = code;\n    this.payload = payload;\n    this.stack = (new Error()).stack;\n}\nLineError.prototype = new Error;\n\n\nmodule.exports = LineError;\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/error.js","module.exports = require(\"lodash/assign\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/assign\"\n// module id = 1\n// module chunks = 0","const isUndefined = require('lodash/isUndefined');\nconst isString = require('lodash/isString');\nconst isObject = require('lodash/isObject');\nconst isFunction = require('lodash/isFunction');\nconst values = require('lodash/values');\nconst assign = require('lodash/assign');\nconst {generateDummyId} = require('./utils');\nconst EventEmitterExtra = require('event-emitter-extra');\nconst LineError = require('./error');\n\n\n/**\n * Message class.\n *\n * @private\n * @class Message\n * @extends {EventEmitterExtra}\n */\nclass Message extends EventEmitterExtra {\n    static parse(raw) {\n        try {\n            const data = JSON.parse(raw);\n\n            // If error is error-like object, construct real error\n            if (isObject(data.e) && isString(data.e.name) && isString(data.e.message)) {\n                data.e = assign(new Error(), data.e);\n            }\n\n            return new Message({\n                name: data.n,\n                payload: data.p,\n                err: data.e,\n                id: data.i\n            });\n        } catch(err) {\n            throw new LineError(Message.ErrorCode.INVALID_JSON, `Could not parse incoming message.`);\n        }\n    }\n\n\n    constructor({name, payload, id, err}) {\n        super();\n\n        try {\n            JSON.stringify(payload);\n            JSON.stringify(err);\n        } catch (err) {\n            throw new LineError(\n                Message.ErrorCode.INVALID_JSON,\n                `Message payload or error must be json-friendly. Maybe circular json?`\n            );\n        }\n\n        this.name = name;\n        this.payload = payload;\n        this.id = id;\n        this.err = err;\n\n        this.isResponded_ = false;\n    }\n\n\n    setId(id = generateDummyId()) {\n        this.id = id;\n        return id;\n    }\n\n\n    createResponse(err, payload) {\n        return new Message({name: '_r', payload, err, id: this.id});\n    }\n\n\n    /**\n     * Resolves the message with sending a response back. If the source\n     * does not expecting a response, you don't need to call these methods.\n     *\n     * This method can throw:\n     * - `Message.ErrorCode.MISSING_ID`: Message source is not expecting a response.\n     * - `Message.ErrorCode.ALREADY_RESPONDED`: This message is already responded.\n     * - `Message.ErrorCode.INVALID_JSON`: Could not stringify payload. Probably circular json.\n     *\n     * @param {any=} payload\n     */\n    resolve(payload) {\n        if (isUndefined(this.id)) {\n            throw new LineError(Message.ErrorCode.MISSING_ID, `This message could not be resolved (no id)`);\n        }\n\n        if (this.isResponded_) {\n            throw new LineError(Message.ErrorCode.ALREADY_RESPONDED, `This message has already responded`);\n        }\n\n        try {\n            JSON.stringify(payload);\n        } catch (err_) {\n            throw new LineError(\n                Message.ErrorCode.INVALID_JSON,\n                `Message must be resolved with json-friendly payload. Maybe circular json?`\n            );\n        }\n\n        this.isResponded_ = true;\n        this.emit('resolved', payload);\n    }\n\n\n    /**\n     * Rejects the message, with sending error response back to the source.\n     *\n     * This method can throw:\n     * - `Message.ErrorCode.MISSING_ID`: Message source is not expecting a response.\n     * - `Message.ErrorCode.ALREADY_RESPONDED`: This message is already responded.\n     * - `Message.ErrorCode.INVALID_JSON`: Could not stringify payload. Probably circular json.\n     *\n     * @param {any=} err\n     */\n    reject(err) {\n        if (isUndefined(this.id)) {\n            throw new LineError(Message.ErrorCode.MISSING_ID, `This message could not be rejected (no id)`);\n        }\n\n        if (this.isResponded_) {\n            throw new LineError(Message.ErrorCode.ALREADY_RESPONDED, `This message has already responded`);\n        }\n\n\n        try {\n            JSON.stringify(err);\n        } catch (err_) {\n            throw new LineError(\n                Message.ErrorCode.INVALID_JSON,\n                `Message must be resolved with json-friendly payload. Maybe circular json?`\n            );\n        }\n\n        this.isResponded_ = true;\n        this.emit('rejected', err);\n    }\n\n\n    toString() {\n        const data = {n: this.name};\n\n        if (!isUndefined(this.payload))\n            data.p = this.payload;\n\n        if (!isUndefined(this.id))\n            data.i = this.id;\n\n        if (!isUndefined(this.err)) {\n            data.e = this.err instanceof Error ? assign({\n                name: this.err.name,\n                message: this.err.message\n            }, this.err) : this.err;\n        }\n\n        // We're sure the data is json-friendly\n        return JSON.stringify(data);\n    }\n\n\n    dispose() {\n        const events = this.eventNames();\n        events.forEach(event => this.removeAllListeners(event));\n    }\n}\n\n\n/**\n * These message names are reserved for internal usage.\n * We recommend to not use any message name starts with `_` (underscore).\n *\n * @static\n * @readonly\n * @enum {string}\n */\nMessage.Name = {\n    /**\n     * `_r`\n     */\n    RESPONSE: '_r',\n    /**\n     * `_h`\n     */\n    HANDSHAKE: '_h',\n    /**\n     * `_p`\n     */\n    PING: '_p'\n};\n\n\nMessage.ReservedNames = values(Message.Name);\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nMessage.ErrorCode = {\n    /**\n     * `mInvalidJson`\n     */\n    INVALID_JSON: 'mInvalidJson',\n    /**\n     * `mMissingId`\n     */\n    MISSING_ID: 'mMissingId',\n    /**\n     * `mAlreadyResponded`\n     */\n    ALREADY_RESPONDED: 'mAlreadyResponded',\n};\n\n\nmodule.exports = Message;\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/message.js","module.exports = require(\"debug\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"debug\"\n// module id = 3\n// module chunks = 0","module.exports = require(\"event-emitter-extra\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"event-emitter-extra\"\n// module id = 4\n// module chunks = 0","module.exports = require(\"lodash/forEach\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/forEach\"\n// module id = 5\n// module chunks = 0","module.exports = require(\"lodash/isInteger\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isInteger\"\n// module id = 6\n// module chunks = 0","module.exports = require(\"lodash/isObject\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isObject\"\n// module id = 7\n// module chunks = 0","const Message = require('../lib/message');\nconst EventEmitterExtra = require('event-emitter-extra');\nconst assign = require('lodash/assign');\nconst forEach = require('lodash/forEach');\nconst isInteger = require('lodash/isInteger');\nconst isObject = require('lodash/isObject');\nconst debounce = require('lodash/debounce');\nconst Deferred = require('../lib/deferred');\nconst uuid = require('uuid');\nconst debug = require('debug')('line:server:connection');\nconst LineError = require('../lib/error');\nconst CloseStatus = require('../lib/closestatus');\n\n\n/**\n * Server connection class. Constructor of this class is not publicly accessible.\n * When you listen `Server.Event.CONNECTION` or `Server.Event.HANDSHAKE`, an instance\n * of `ServerConnection` will be emitted.\n *\n * @class ServerConnection\n * @extends {EventEmitterExtra}\n * @private\n * @property {string} id Unique connection id\n */\nclass ServerConnection extends EventEmitterExtra {\n    constructor(socket, server) {\n        super();\n\n        this.id = uuid.v4();\n        debug(`Creating connection with id ${this.id} ...`);\n\n        this.socket = socket;\n        this.server = server;\n        this.state = ServerConnection.State.AWAITING_HANDSHAKE;\n\n        this.deferreds_ = {};\n        this.autoPing_ = debounce(() => {});\n\n        this.socket.on('message', this.onMessage_.bind(this));\n        this.socket.on('error', this.onError_.bind(this));\n        this.socket.on('close', this.onClose_.bind(this));\n\n        if (server.options.pingInterval > 0) {\n            this.autoPing_ = debounce(() => {\n                this\n                    .ping()\n                    .then(() => {\n                        debug(`Auto-ping successful`);\n\n                        if (server.options.pingInterval > 0 && this.state == ServerConnection.State.CONNECTED) {\n                            this.autoPing_();\n                        }\n                    })\n                    .catch((err) => {/* Disconnection is handled in ping */});\n            }, server.options.pingInterval);\n        }\n\n        if (server.options.handshakeTimeout > 0) {\n            this.handshakeTimeout_ = setTimeout(() => {\n                if (this.state != ServerConnection.State.AWAITING_HANDSHAKE) {\n                    return debug(`Handshake is not awaiting, ignoring handshake timeout...`);\n                }\n\n                debug(`Handshake timeout exceed, closing the connection...`);\n                this.close(CloseStatus.HANDSHAKE_FAILED.code, `Handshake not completed after ${server.options.handshakeTimeout} ms`);\n            }, server.options.handshakeTimeout);\n        }\n    }\n\n\n    /**\n     * Native \"message\" event handler.\n     *\n     * @param {string|Buffer} data\n     * @param {Object} flags\n     * @param {boolean} flags.binary Specifies if data is binary.\n     * @param {boolean} flags.Boolean Specifies if data was masked.\n     * @ignore\n     */\n    onMessage_(data, flags) {\n        debug(`Native \"message\" event recieved: ${data}`);\n        let message;\n\n        if (this.server.wslib == 'websocket')\n            data = data.utf8Data;\n\n        // A message is recieved, debounce our auto-ping handler if connected\n        if (this.state == ServerConnection.State.CONNECTED) {\n            this.autoPing_();\n        }\n\n        try {\n            message = Message.parse(data);\n        } catch (err) {\n            this.emit(ServerConnection.Event.ERROR, new LineError(\n                ServerConnection.ErrorCode.INVALID_JSON,\n                'Could not parse message, invalid json. Check payload for incoming data.',\n                data\n            ));\n            return;\n        }\n\n        /**\n         * Route the incoming message\n         */\n        if (message.name == Message.Name.HANDSHAKE) { // Handshake\n            this.onHandshakeMessage_(message);\n        } else if (message.name == Message.Name.PING) { // Ping\n            this.onPingMessage_(message);\n        } else if (message.name == Message.Name.RESPONSE) { // Message response\n            this.onResponseMessage_(message);\n        } else if (Message.ReservedNames.indexOf(message.name) == -1) { // If message name is not reserved\n            if (!message.id) { // Message without response (no id fields)\n                this.onMessageWithoutResponse_(message);\n            } else { // Message arrived awaiting its response\n                this.onMessageWithResponse_(message);\n            }\n        } else {\n            debug(`Could not route the message`, message);\n        }\n    }\n\n\n    /**\n     * On \"handshake\" message handler.\n     *\n     * @param {Message} message\n     * @ignore\n     */\n    onHandshakeMessage_(message) {\n        if (this.state == ServerConnection.State.CONNECTED) {\n            debug(`Handshake message recieved but, handshake is already resolved, ignoring...`);\n            return this\n                .sendWithoutResponse_(message.createResponse(new Error('Handshake is already resolved')))\n                .catch(() => { /* Ignoring */ });\n        }\n\n        debug(`Handshake message recieved: ${message}`);\n\n        /**\n         * If handshake is resolved\n         */\n        message.once('resolved', (payload) => {\n            debug(`Handshake is resolved, sending response...`);\n            this.state = ServerConnection.State.CONNECTED;\n            this.handshakeTimeout_ && clearTimeout(this.handshakeTimeout_);\n            this.autoPing_(); // Start auto-pinging\n\n            const responsePayload = {\n                payload,\n                id: this.id\n            };\n\n            this\n                .sendWithoutResponse_(message.createResponse(null, responsePayload))\n                .then(() => {\n                    debug(`Handshake resolving response is sent, emitting connection...`);\n                    this.server.rooms.root.add(this);\n                    this.server.emit('connection', this);\n                })\n                .catch((err) => {\n                    debug(`Could not send handshake response`, err);\n\n                    // TODO: Emit these errors from the server\n                    if (err instanceof LineError) {\n                        switch (err.code) {\n                            case ServerConnection.ErrorCode.DISCONNECTED:\n                                debug(`Connection is gone before handshake completed, ignoring...`);\n                                return;\n\n                            case ServerConnection.ErrorCode.WEBSOCKET_ERROR:\n                                // TODO: Try again!\n                                debug('Native websocket error', err.payload);\n                                return this.close(CloseStatus.HANDSHAKE_FAILED.code, CloseStatus.HANDSHAKE_FAILED.reason);\n\n                            default:\n                                debug('Unhandled line error', err);\n                                return this.close(CloseStatus.HANDSHAKE_FAILED.code, CloseStatus.HANDSHAKE_FAILED.reason);\n                        }\n                    }\n\n                    debug(`Unknown error`, err);\n                    return this.close(CloseStatus.HANDSHAKE_FAILED.code, CloseStatus.HANDSHAKE_FAILED.reason);\n                })\n                .then(() => {\n                    message.dispose();\n                });\n        });\n\n        /**\n         * Id handshake is rejected\n         */\n        message.once('rejected', (err) => {\n            debug(`Handshake is rejected, sending response...`);\n\n            this\n                .sendWithoutResponse_(message.createResponse(err))\n                .catch(err => debug(`Handshake rejecting response could not sent, manually calling \"close\"...`, err))\n                .then(() => this.close(CloseStatus.HANDSHAKE_REJECTED.code, CloseStatus.HANDSHAKE_REJECTED.reason, 50))\n                .then(() => {\n                    message.dispose();\n                });\n        });\n\n        /**\n         * Emit handshake event from the server\n         */\n        debug(`Emitting server's \"handshake\" event...`);\n        const handshakeListener = this.server.emit('handshake', this, message);\n\n        if (!handshakeListener) {\n            debug(`There is no handshake listener, resolving the handshake by default...`);\n            message.resolve();\n        }\n    }\n\n\n    /**\n     * On \"ping\" message handler. Reply with pong.\n     *\n     * @param {Message} message\n     * @ignore\n     */\n    onPingMessage_(message) {\n        debug('Ping received, responding with \"pong\"...');\n\n        this\n            .sendWithoutResponse_(message.createResponse(null, 'pong'))\n            .catch(err => debug('Ping response failed to send back, ignoring for now...', err));\n    }\n\n\n    /**\n     * A message is recieved, and its response is expected.\n     *\n     * @param {Message} message\n     * @ignore\n     */\n    onResponseMessage_(message) {\n        const deferred = this.deferreds_[message.id];\n        if (!deferred) return;\n\n        if (message.err) {\n            debug(`Response (rejecting) recieved: ${message}`);\n            const err = new LineError(\n                ServerConnection.ErrorCode.MESSAGE_REJECTED,\n                'Message is rejected by server, check payload.',\n                message.err\n            );\n            deferred.reject(err);\n        } else {\n            debug(`Response (resolving) recieved: ${message}`);\n            deferred.resolve(message.payload);\n        }\n\n        delete this.deferreds_[message.id];\n    }\n\n\n    /**\n     * A message is arrived without waiting its response.\n     *\n     * @param {Message} message\n     * @ignore\n     */\n    onMessageWithoutResponse_(message) {\n        debug(`Message without response: name=\"${message.name}\"`);\n        this.emit(message.name, message);\n    }\n\n\n    /**\n     * A message is arrived and the client is expecting its response.\n     *\n     * @param {Message} message\n     * @ignore\n     */\n    onMessageWithResponse_(message) {\n        debug(`Message with response: name=\"${message.name}\" id=\"${message.id}\"`);\n\n        message.once('resolved', (payload) => {\n            debug(`Message #${message.id} is resolved, sending response...`);\n            this\n                .sendWithoutResponse_(message.createResponse(null, payload))\n                .catch((err) => {\n                    this.emit(ServerConnection.Event.ERROR, new LineError(\n                        ServerConnection.ErrorCode.MESSAGE_NOT_RESPONDED,\n                        `Message (name=\"${message.name}\" id=\"${message.id}\") could not responded (resolve)`,\n                        err\n                    ));\n                })\n                .then(() => message.dispose());\n        });\n\n        message.once('rejected', (err) => {\n            debug(`Message #${message.id} is rejected, sending response...`);\n            this\n                .sendWithoutResponse_(message.createResponse(err))\n                .catch((err) => {\n                    this.emit(ServerConnection.Event.ERROR, new LineError(\n                        ServerConnection.ErrorCode.MESSAGE_NOT_RESPONDED,\n                        `Message (name=\"${message.name}\" id=\"${message.id}\") could not responded (reject)`,\n                        err\n                    ));\n                })\n                .then(() => message.dispose());\n        });\n\n        this.emit(message.name, message);\n    }\n\n\n    /**\n     * Native \"error\" event.\n     *\n     * @param {Error} err\n     * @ignore\n     */\n    onError_(err) {\n        debug(`Native \"error\" event recieved, emitting line's \"error\" event: ${err}`);\n        this.emit(ServerConnection.Event.ERROR, err);\n    }\n\n\n    /**\n     * Native \"close\" event.\n     *\n     * @param {number} code\n     * @param {string=} reason\n     * @ignore\n     */\n    onClose_(code, reason) {\n        debug(`Native \"close\" event recieved with code ${code}: ${reason}`);\n        debug(`Removing connection from all rooms, rejecting all waiting messages...`);\n\n        this.handshakeTimeout_ && clearTimeout(this.handshakeTimeout_);\n        this.autoPing_.cancel();\n        this.server.rooms.removeFromAll(this);\n        this.server.rooms.root.remove(this);\n        this.rejectAllDeferreds_(new LineError(ServerConnection.ErrorCode.DISCONNECTED, 'Socket connection closed!'));\n\n        debug(`Emitting line's \"close\" event...`);\n        this.state = ServerConnection.State.DISCONNECTED;\n        this.emit(ServerConnection.Event.DISCONNECTED, code, reason);\n    }\n\n\n    /**\n     * Changes connection's id, it's random by default. This method is helpful if you already have\n     * custom identification for your clients. You must do this before handshake resolved. If\n     * handshake is already resolved or there is conflict, this method will throw error.\n     *\n     * Throws:\n     * - `ServerConnection.ErrorCode.HANDSHAKE_ENDED`: Id could not be changed after handshake\n     * - `ServerConnection.ErrorCode.ID_CONFLICT`: There is alrady another connection with provided id.\n     *\n     * @param {string} newId New connection id\n     * @memberOf ServerConnection\n     * @example\n     * server.on(Server.Event.HANDSHAKE, (connection, handshake) => {\n     *   // Assuming client's `options.handshake.payload` is something like `{authToken: '...'}`\n     *\n     *   // Imaginary db\n     *   db.find(handshake.payload.authToken, (record) => {\n     *     if (!record) return handshake.reject(new Error('Invalid auth token'));\n     *     connection.setId(record.id);\n     *     handshake.resolve(record);\n     *   });\n     * });\n     */\n    setId(newId) {\n        if (this.state != ServerConnection.State.AWAITING_HANDSHAKE) {\n            throw new LineError(\n                ServerConnection.ErrorCode.HANDSHAKE_ENDED,\n                'Handshake already ended, you cannot change connection id anymore'\n            );\n        }\n\n        if (this.server.getConnectionById(newId)) {\n            throw new LineError(\n                ServerConnection.ErrorCode.ID_CONFLICT,\n                `Conflict! There is already connection with id ${newId}`\n            );\n        }\n\n        this.id = newId;\n    }\n\n\n    /**\n     * Joins the connection into provided room. If there is no room, it will be created automatically.\n     *\n     * @param {string} roomName\n     * @memberOf ServerConnection\n     */\n    joinRoom(roomName) {\n        this.server.rooms.add(roomName, this);\n    }\n\n\n    /**\n     * Leaves the connection from provided room.\n     *\n     * @param {string} roomName\n     * @memberOf ServerConnection\n     */\n    leaveRoom(roomName) {\n        this.server.rooms.remove(roomName, this);\n    }\n\n\n\n    /**\n     * Gets the joined room names.\n     *\n     * @returns {Array<string>}\n     * @memberOf ServerConnection\n     */\n    getRooms() {\n        return this.server.rooms.getRoomsOf(this);\n    }\n\n\n    /**\n     * Sends a message to client with awaiting its response. This method returns a promise\n     * which resolves the payload parameter will be passed into `message.resolve(...)` in client-side.\n     *\n     * If client rejects the message with `message.reject(...)`, this promise will be rejected with\n     * `ServerConnection.ErrorCode.MESSAGE_REJECTED`. You can access the original error object with `err.payload`.\n     *\n     * Rejections:\n     * - `ServerConnection.ErrorCode.INVALID_JSON`: Could not stringify the message payload. Probably circular json.\n     * - `ServerConnection.ErrorCode.MESSAGE_REJECTED`: Message is explicitly rejected by the client.\n     * - `ServerConnection.ErrorCode.MESSAGE_TIMEOUT`: Message response did not arrived, timeout exceeded.\n     * - `ServerConnection.ErrorCode.DISCONNECTED`: Client is not connected (& handshake resolved) or connection is closing\n     * - `ServerConnection.ErrorCode.WEBSOCKET_ERROR`: Native websocket error\n     *\n     * @param {string} name\n     * @param {any=} payload\n     * @param {number=} timout\n     * @returns {Promise<any>}\n     * @memberOf ServerConnection\n     * @example\n     * connection\n     *   .send('hello', {optional: 'payload'})\n     *   .then((data) => {\n     *     // Message is resolved by client\n     *   })\n     *   .catch((err) => {\n     *     // Could not send message\n     *     // or\n     *     // Client rejected the message!\n     *   });\n     */\n    send(name, payload, opt_timeout) { // This method is for external usage!\n        if (this.state != ServerConnection.State.CONNECTED) {\n            return Promise.reject(new LineError(\n                ServerConnection.ErrorCode.DISCONNECTED,\n                `Could not send message, client is not connected.`\n            ));\n        }\n\n        try {\n            const message = new Message({name, payload});\n            return this.send_(message, opt_timeout);\n        } catch (err) {\n            // `err` can only be Message.ErrorCode.INVALID_JSON\n            return Promise.reject(new LineError(\n                ServerConnection.ErrorCode.INVALID_JSON,\n                `Could not send message, \"payload\" stringify error. Probably circular json issue.`\n            ));\n        }\n    }\n\n\n    /**\n     * Sends a message to client without waiting its response. This method returns a promise\n     * that resolves with nothing if the message is successfully sent.\n     *\n     * Rejections:\n     * - `ServerConnection.ErrorCode.INVALID_JSON`: Could not stringify the message payload. Probably circular json.\n     * - `ServerConnection.ErrorCode.DISCONNECTED`: Client is not connected (& handshake resolved) or connection is closing\n     * - `ServerConnection.ErrorCode.WEBSOCKET_ERROR`: Native websocket error\n     *\n     * @param {string} name\n     * @param {any=} payload\n     * @returns {Promise}\n     * @memberOf ServerConnection\n     * @example\n     * connection\n     *   .sendWithoutResponse('hello', {optional: 'payload'})\n     *   .then(() => {\n     *     // Message sent successfully\n     *   })\n     *   .catch((err) => {\n     *     // Message could not be sent to client\n     *   })\n     */\n    sendWithoutResponse(name, payload) { // For external usage\n        if (this.state != ServerConnection.State.CONNECTED) {\n            return Promise.reject(new LineError(\n                ServerConnection.ErrorCode.DISCONNECTED,\n                `Could not send message, client is not connected.`\n            ));\n        }\n\n        try {\n            const message = new Message({name, payload}); // Can throw Message.ErrorCode.INVALID_JSON\n            return this.sendWithoutResponse_(message);\n        } catch (err) {\n            // `err` can only be Message.ErrorCode.INVALID_JSON\n            return Promise.reject(new LineError(\n                ServerConnection.ErrorCode.INVALID_JSON,\n                `Could not send message, \"payload\" stringify error. Probably circular json issue.`\n            ));\n        }\n    }\n\n\n    /**\n     * Base method for sending a message with timeout. Please favor this method internally\n     * instead of using `send` method.\n     *\n     * Rejections:\n     * - `ServerConnection.ErrorCode.MESSAGE_REJECTED`: Message is explicitly rejected by the client.\n     * - `ServerConnection.ErrorCode.MESSAGE_TIMEOUT`: Message response did not arrived, timeout exceeded.\n     * - `ServerConnection.ErrorCode.DISCONNECTED`: Client is not connected (& handshake resolved) or connection is closing\n     * - `ServerConnection.ErrorCode.WEBSOCKET_ERROR`: Native websocket error\n     *\n     * @param {Message} message\n     * @param {number=} opt_timeout\n     * @returns {Promise}\n     * @ignore\n     */\n    send_(message, opt_timeout) {\n        const timeout = isInteger(opt_timeout) && opt_timeout >= 0 ? opt_timeout : this.server.options.responseTimeout;\n        message.setId();\n\n        const deferred = this.deferreds_[message.id] = new Deferred({\n            onExpire: () => {\n                delete this.deferreds_[message.id];\n            },\n            timeout: timeout\n        });\n\n        return this\n            .sendWithoutResponse_(message)\n            .then(() => deferred)\n            .catch((err) => {\n                deferred.dispose();\n\n                // Convert expired -> timeout error\n                if (err instanceof LineError && err.code == Deferred.ErrorCode.EXPIRED) {\n                    throw new LineError(\n                        ServerConnection.ErrorCode.MESSAGE_TIMEOUT,\n                        `Message timeout! Its response did not recived after ${timeout} ms`\n                    );\n                }\n\n                throw err;\n            });\n    }\n\n\n    /**\n     * Base method for sending a message without response. Please favor this method internally\n     * instead of using `sendWithoutResponse` method.\n     *\n     * Rejections:\n     * - `ServerConnection.ErrorCode.DISCONNECTED`: Client is not connected (& handshake resolved) or connection is closing\n     * - `ServerConnection.ErrorCode.WEBSOCKET_ERROR`: Native websocket error\n     *\n     * @param {Message} message\n     * @returns {Promise}\n     * @ignore\n     */\n    sendWithoutResponse_(message) {\n        if  (!this.socket ||\n            (this.server.wslib == 'websocket' && !this.socket.connected) ||\n            ((this.server.wslib == 'ws' || this.server.wslib == 'uws') && this.socket.readyState != 1)) {\n            return Promise.reject(new LineError(\n                ServerConnection.ErrorCode.DISCONNECTED,\n                `Could not send message, there is no open connection.`\n            ));\n        }\n\n        return new Promise((resolve, reject) => {\n            debug(`Sending message: ${message}`);\n            const messageStr = message.toString();\n\n            this.socket.send(messageStr, (err) => {\n                if (err) {\n                    return reject(new LineError(\n                        ServerConnection.ErrorCode.WEBSOCKET_ERROR,\n                        `Could not send message, native websocket error, check payload.`,\n                        err\n                    ));\n                }\n\n                resolve();\n            });\n        });\n    }\n\n\n    /**\n     * Pings the client. If there is no respose, closes the connection.\n     *\n     * @returns {Promise}\n     * @memberOf ServerConnection\n     */\n    ping() {\n        debug(`Pinging...`);\n        return this\n            .send_(new Message({name: Message.Name.PING}))\n            .catch(err => {\n                // No matter what error is, start disconnection process\n                debug('Auto-ping failed, manually disconnecting...');\n                this.close(CloseStatus.PING_FAILED.code, CloseStatus.PING_FAILED.reason);\n                throw new LineError(\n                    ServerConnection.ErrorCode.PING_ERROR,\n                    `Ping failed, manually disconnecting...`,\n                    err\n                );\n            });\n    }\n\n\n    /**\n     * Gracefully closes the client connection.\n     *\n     * @param {number=} code\n     * @param {string=} reason\n     * @param {number=} delay\n     * @returns {Promise}\n     */\n    close(code, reason, delay) {\n        debug(`Closing the connection in ${delay || 0} ms...`);\n        return new Promise((resolve) => {\n            setTimeout(() => {\n                this.socket.close(code || 1000, reason);\n                resolve();\n            }, delay || 0);\n        });\n    }\n\n\n    /**\n     * Reject all the awaiting deferred with given error.\n     *\n     * @param {Error} err An error object to reject all awaiting deferreds.\n     * @ignore\n     */\n    rejectAllDeferreds_(err) {\n        forEach(this.deferreds_, deferred => deferred.reject(err));\n        this.deferreds_ = {};\n    }\n}\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nServerConnection.ErrorCode = {\n    /**\n     * This error can be seen in rejection of `serverConnection.send()` method.\n     */\n    MESSAGE_TIMEOUT: 'scMessageTimeout',\n    /**\n     * This error can be seen in rejection of `serverConnection.send()` method,\n     * which again indicates that server is explicitly rejected the message.\n     */\n    MESSAGE_REJECTED: 'scMessageRejected',\n    /**\n     * When the response of a message failed to send to client, this error\n     * will be emitted in `ServerConnection.Event.ERROR` event.\n     */\n    MESSAGE_NOT_RESPONDED: 'cMessageNotResponded',\n    /**\n     * Indicates an error while json parsing/stringify.\n     */\n    INVALID_JSON: 'scInvalidJson',\n    /**\n     * This error can be thrown in `serverConnection.setId()`. Connection id\n     * cannot be set after handshake.\n     */\n    HANDSHAKE_ENDED: 'scHandshakeEnded',\n    /**\n     * This error can be seen while using `serverConnection.setId()`. If there is\n     * already connection with that id, this error will be thrown.\n     */\n    ID_CONFLICT: 'scIdConflict',\n    /**\n     * This error indicates client is disconnected.\n     */\n    DISCONNECTED: 'scDisconnected',\n    /**\n     * This error is for native websocket errors.\n     */\n    WEBSOCKET_ERROR: 'scWebsocketError',\n    /**\n     * This error can be seen in rejection of `serverConnection.ping()` method.\n     */\n    PING_ERROR: 'scPingError'\n};\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nServerConnection.State = {\n    /**\n     * `awaitingHandshake` Connection is open but handshake is not completed yet.\n     */\n    AWAITING_HANDSHAKE: 'awaitingHandshake',\n    /**\n     * `connected` Connection is open and handshake resolved.\n     */\n    CONNECTED: 'connected',\n    /**\n     * `disconnected` There is no open connection.\n     */\n    DISCONNECTED: 'disconnected'\n};\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nServerConnection.Event = {\n    /**\n     * `_error`\n     */\n    ERROR: '_error',\n    /**\n     * `_close`\n     */\n    DISCONNECTED: '_disconnected'\n};\n\n\nmodule.exports = ServerConnection;\n\n\n\n// WEBPACK FOOTER //\n// ./src/server/connection.js","const filter = require('lodash/filter');\nconst forEach = require('lodash/forEach');\nconst map = require('lodash/map');\nconst Room = require('./room');\n\n\nclass Rooms {\n    constructor() {\n        this.rooms = {};\n        this.root = new Room();\n    }\n\n    add(roomName, connection) {\n        if(!this.rooms[roomName])\n            this.rooms[roomName] = new Room(roomName);\n\n        this.rooms[roomName].add(connection);\n    }\n\n    remove(roomName, connection) {\n        if(!this.rooms[roomName])\n            return;\n\n        this.rooms[roomName].remove(connection);\n\n        if (!this.rooms[roomName].getConnectionsCount())\n            delete this.rooms[roomName];\n    }\n\n    getRoomsOf(connection) {\n        return map(filter(this.rooms, room => room.getConnectionById(connection.id)), 'name');\n    }\n\n    getRoom(room) {\n        return this.rooms[room];\n    }\n\n    removeFromAll(connection) {\n        const rooms = this.getRoomsOf(connection);\n        forEach(rooms, roomName => this.rooms[roomName].remove(connection));\n    }\n}\n\n\nmodule.exports = Rooms;\n\n\n\n// WEBPACK FOOTER //\n// ./src/server/rooms.js","module.exports = require(\"http\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"http\"\n// module id = 10\n// module chunks = 0","module.exports = require(\"https\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"https\"\n// module id = 11\n// module chunks = 0","module.exports = require(\"uws\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"uws\"\n// module id = 12\n// module chunks = 0","module.exports = require(\"websocket\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"websocket\"\n// module id = 13\n// module chunks = 0","module.exports = require(\"ws\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"ws\"\n// module id = 14\n// module chunks = 0","module.exports = {\n    INTERNAL_ERROR: {code: 4200, reason: 'Internal error'},\n    PING_FAILED: {code: 4201, reason: 'Ping failed'},\n    HANDSHAKE_FAILED: {code: 4202, reason: 'Handshake failed'},\n    HANDSHAKE_REJECTED: {code: 4203, reason: 'Handshake rejected'},\n    DISCONNECT_TIMEOUT: {code: 4204, reason: 'Disconnect timeout'},\n    DISPOSED: {code: 4205, reason: 'Client disposed'},\n    UNKNOWN_ERROR: {code: 4299, reason: 'Unknown error'},\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/closestatus.js","const LineError = require('./error');\n\n\nclass Deferred {\n    constructor({\n        handler = () => {},\n        onExpire = () => {},\n        timeout = 0\n    } = {}) {\n        this.resolve_ = null;\n        this.reject_ = null;\n\n        this.timeout_ = null;\n        this.timeoutDuration_ = timeout;\n        this.onExpire_ = onExpire;\n        this.isFinished_ = false;\n\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve_ = resolve;\n            this.reject_ = reject;\n\n            try {\n                handler(this);\n            } catch (err) {\n                this.reject(err);\n            }\n        });\n\n        if (timeout > 0) {\n            this.timeout_ = setTimeout(this.expire.bind(this), timeout);\n        }\n    }\n\n\n    resolve(data) {\n        if (this.isFinished_) return;\n\n        this.isFinished_ = true;\n        this.clearTimeout_();\n        this.resolve_(data);\n    }\n\n\n    reject(err) {\n        if (this.isFinished_) return;\n\n        this.isFinished_ = true;\n        this.clearTimeout_();\n        this.reject_(err);\n    }\n\n\n    expire() {\n        this.isFinished_ = true;\n        this.clearTimeout_();\n        this.onExpire_();\n        this.reject_(new LineError(Deferred.ErrorCode.EXPIRED, `Timeout ${this.timeoutDuration_} ms exceed`));\n    }\n\n\n    dispose() {\n        this.isFinished_ = true;\n        this.clearTimeout_();\n    }\n\n\n    then(...args) {\n        return this.promise.then.apply(this.promise, args);\n    }\n\n\n    catch(...args) {\n        return this.promise.catch.apply(this.promise, args);\n    }\n\n\n    clearTimeout_() {\n        if (this.timeout_) {\n            clearTimeout(this.timeout_);\n            this.timeout_ = null;\n        }\n    }\n}\n\n\nDeferred.ErrorCode = {\n    EXPIRED: 'dExpired'\n};\n\n\nmodule.exports = Deferred;\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/deferred.js","const assign = require('lodash/assign');\n\n\n// http://stackoverflow.com/a/6248722\nfunction generateDummyId(length = 4) {\n    return (\"0000\" + (Math.random()*Math.pow(36,length) << 0).toString(36)).slice(-length);\n}\n\n\nmodule.exports = {generateDummyId};\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/utils.js","const forEach = require('lodash/forEach');\nconst clone = require('lodash/clone');\nconst Message = require('../lib/message');\nconst debug = require('debug')('line:server:room');\nconst LineError = require('../lib/error');\n\n\n/**\n * Line room class.\n *\n * @private\n * @class ServerRoom\n * @param {string} name Room name\n * @property {string} name\n */\nclass ServerRoom {\n    constructor(name, connections = {}) {\n        this.name = name;\n        this.connections = connections;\n    }\n\n\n    /**\n     * Adds a connection into room.\n     * @param {ServerConnection} connection\n     */\n    add(connection) {\n        // TODO: Check current existing connection maybe?\n        this.connections[connection.id] = connection;\n    }\n\n\n    /**\n     * Removes a connection from room.\n     * @param {ServerConnection} connection\n     * @returns {boolean}\n     */\n    remove(connection) {\n        if (connection != this.connections[connection.id]) {\n            debug(`[${this.name || 'root'}] Did not remove \"${connection.id}\", connection instance is not added or different`);\n            return false;\n        }\n\n        debug(`[${this.name || 'root'}] Removing \"${connection.id}\"`);\n        delete this.connections[connection.id];\n        return true;\n    }\n\n\n    /**\n     * Gets a connection by id.\n     * @param {string} connectionId\n     * @returns {?ServerConnection}\n     */\n    getConnectionById(connectionId) {\n        return this.connections[connectionId];\n    }\n\n\n    /**\n     * Gets all connections in the room. Returns a object where keys are\n     * connection id and values are ServerConnection.\n     * @returns {{string: ServerConnection}}\n     */\n    getConnections() {\n        return clone(this.connections);\n    }\n\n\n    /**\n     * Returns the total connection count in room.\n     * @returns {number}\n     */\n    getConnectionsCount() {\n        return Object.keys(this.connections).length;\n    }\n\n\n    broadcast_(message) {\n        forEach(this.connections, connection => {\n            connection\n                .sendWithoutResponse_(message)\n                .catch((err) => {\n                    debug(`[${this.name || 'root'}] Could not send \"${message.name}\" to \"${connection.id}\" while broadcasting, ignoring...`);\n                });\n        });\n    }\n\n\n    /**\n     * Broadcast a message to all connections in the room.\n     * @param {string} name\n     * @param {any=} payload\n     */\n    broadcast(name, payload) {\n        const message = new Message({name, payload}); // Can throw INVALID_JSON\n        this.broadcast_(message);\n    }\n}\n\n\nmodule.exports = ServerRoom;\n\n\n\n// WEBPACK FOOTER //\n// ./src/server/room.js","module.exports = require(\"lodash/clone\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/clone\"\n// module id = 19\n// module chunks = 0","module.exports = require(\"lodash/debounce\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/debounce\"\n// module id = 20\n// module chunks = 0","module.exports = require(\"lodash/filter\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/filter\"\n// module id = 21\n// module chunks = 0","module.exports = require(\"lodash/isFunction\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isFunction\"\n// module id = 22\n// module chunks = 0","module.exports = require(\"lodash/isString\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isString\"\n// module id = 23\n// module chunks = 0","module.exports = require(\"lodash/isUndefined\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isUndefined\"\n// module id = 24\n// module chunks = 0","module.exports = require(\"lodash/map\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/map\"\n// module id = 25\n// module chunks = 0","module.exports = require(\"lodash/values\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/values\"\n// module id = 26\n// module chunks = 0","module.exports = require(\"uuid\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"uuid\"\n// module id = 27\n// module chunks = 0","const Connection = require('./connection');\nconst Message = require('../lib/message');\nconst Rooms = require('./rooms');\nconst EventEmitterExtra = require('event-emitter-extra');\nconst debug = require('debug')('line:server');\nconst LineError = require('../lib/error');\nconst assign = require('lodash/assign');\nconst isInteger = require('lodash/isInteger');\nconst http = require('http');\nconst https = require('https');\n\nlet WebSocketServer;\nlet wslib;\ntry {\n    WebSocketServer = require('uws').Server;\n    wslib = 'uws';\n} catch (err) {\n    try {\n        debug(`Could not find module uws lib, falling back to websocket lib`, err);\n        WebSocketServer = require('websocket').server;\n        wslib = 'websocket';\n    } catch (err) {\n        debug(`Could not find module websocket lib, falling back to ws lib`, err);\n        WebSocketServer = require('ws').Server;\n        wslib = 'ws';\n    }\n}\n\nconsole.log('Continuing with', wslib);\n\n\n/**\n * Line Server Class\n *\n * @class Server\n * @extends {EventEmitterExtra}\n * @param {Object=} options Options object.\n * @param {string=} options.host The hostname where to bind the server. [Inherited from uws.](https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketserveroptions-callback)\n * @param {number=} options.port The port where to bind the server. [Inherited from uws.](https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketserveroptions-callback)\n * @param {http.Server=} options.server A pre-created Node.js HTTP server. If provided, `host` and `port`\n *      will ignored. [Inherited from uws.](https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketserveroptions-callback)\n * @param {string=} options.path Accept only connections matching this path. [Inherited from uws](https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketserveroptions-callback)\n * @param {number=} options.responseTimeout Default timeout duration (in ms) for message responses. Default: `10000` (10 seconds)\n * @param {number=} options.handshakeTimeout This is the duration how long a client can stay connected\n *      without handshake. Default `60000` (1 minute).\n * @param {number=} options.pingInterval Ping interval in ms. Default: 15 seconds.\n * @example\n * const Server = require('line-socket/server');\n * const server = new Server({\n *   port: 8080\n * });\n */\nclass Server extends EventEmitterExtra {\n    constructor(options = {}) {\n        super();\n\n        this.wslib = wslib;\n\n        this.options = assign({\n            responseTimeout: 10000,\n            handshakeTimeout: 60000,\n            pingInterval: 15000\n        }, options);\n\n        if (!isInteger(this.options.responseTimeout) || this.options.responseTimeout < 0)\n            throw new LineError(Server.ErrorCode.INVALID_OPTIONS, `\"options.responseTimeout\" must be a positive integer or zero`);\n\n        if (!isInteger(this.options.handshakeTimeout) || this.options.handshakeTimeout < 0)\n            throw new LineError(Server.ErrorCode.INVALID_OPTIONS, `\"options.handshakeTimeout\" must be a positive integer or zero`);\n\n        if (!isInteger(this.options.pingInterval) || this.options.pingInterval < 0)\n            throw new LineError(Server.ErrorCode.INVALID_OPTIONS, `\"options.pingInterval\" must be a positive integer or zero`);\n\n        this.rooms = new Rooms();\n\n        debug(`Initalizing with options: ${JSON.stringify(this.options)}`);\n    }\n\n    /**\n     * Starts the server.\n     *\n     * @returns {Promise}\n     * @memberOf Server\n     * @example\n     * server\n     *   .start()\n     *   .then(() => {\n     *     console.log('Server started');\n     *   })\n     *   .catch((err) => {\n     *     console.log('Server could not started', err);\n     *   });\n     */\n    start() {\n        if (this.server) {\n            return Promise.reject(new LineError(\n                Server.ErrorCode.INVALID_ACTION,\n                `Could not start server, already started!`\n            ));\n        }\n\n        debug(`Starting with port \"${this.options.port}\" ...`);\n\n        if (this.wslib == 'websocket') {\n            if (this.options.secure)\n                this.httpServer = https.createServer();\n            else\n                this.httpServer = http.createServer();\n\n            this.server = new WebSocketServer({httpServer: this.httpServer});\n            this.bindEvents_();\n\n            return new Promise((resolve, reject) => {\n                this.httpServer.listen(this.options.port, err => {\n                    if (err) {\n                        debug(`Could not start: ${err}`);\n                        return reject(new LineError(\n                            Server.ErrorCode.WEBSOCKET_ERROR,\n                            `Could not start the server, websocket error, check payload`,\n                            err\n                        ));\n                    }\n\n                    resolve();\n                });\n            });\n        } else {\n            return new Promise((resolve, reject) => {\n                this.server = new WebSocketServer(this.options, err => {\n                    if (err) {\n                        debug(`Could not start: ${err}`);\n                        return reject(new LineError(\n                            Server.ErrorCode.WEBSOCKET_ERROR,\n                            `Could not start the server, websocket error, check payload`,\n                            err\n                        ));\n                    }\n\n                    resolve();\n                });\n\n                this.bindEvents_();\n            });\n        }\n    }\n\n\n    /**\n     * Stops the server.\n     *\n     * @returns {Promise}\n     * @memberOf Server\n     * @example\n     * server\n     *   .stop()\n     *   .then(() => {\n     *     console.log('Server stopped');\n     *   })\n     *   .catch((err) => {\n     *     console.log('Server could not stopped', err);\n     *   });\n     */\n    stop() {\n        if (!this.server) {\n            debug(`Could not stop server. Server is probably not started, or already stopped.`);\n            return Promise.reject(new LineError(\n                Server.ErrorCode.INVALID_ACTION,\n                `Could not stop server. Server is probably not started, or already stopped!`\n            ));\n        }\n\n        return new Promise(resolve => {\n            debug(`Closing and disposing the server...`);\n            if (this.wslib == 'websocket') {\n                this.server.shutDown();\n                this.httpServer.close(() => {\n                    this.server = null;\n                    resolve();\n                });\n            } else {\n                this.server.close();\n                this.server = null;\n                resolve();\n            }\n        });\n    }\n\n\n    /**\n     * Binds websocket server events.\n     *\n     * @ignore\n     */\n    bindEvents_() {\n        debug(`Binding server events...`);\n\n        if (this.wslib == 'websocket') {\n            this.server.on('request', this.onRequest_.bind(this));\n            this.server.on('connect', this.onConnection_.bind(this));\n        } else {\n            this.server.on('connection', this.onConnection_.bind(this));\n            this.server.on('headers', this.onHeaders_.bind(this));\n        }\n\n        this.server.on('error', this.onError_.bind(this));\n    }\n\n    onRequest_(request) {\n        const connection = request.accept(null, request.origin);\n    }\n\n\n    /**\n     * Native \"connection\" event handler.\n     *\n     * @param {WebSocket} socket\n     * @ignore\n     */\n    onConnection_(socket) {\n        debug(`Native \"connection\" event recieved, creating line connection...`);\n        const connection = new Connection(socket, this);\n    }\n\n\n    /**\n     * Native \"headers\" event handler.\n     *\n     * @param {Array} headers\n     * @ignore\n     */\n    onHeaders_(headers) {\n        debug(`Native \"headers\" event recieved, emitting line's \"headers\" event... (${headers})`);\n        this.emit(Server.Event.HEADERS, headers);\n    }\n\n\n    /**\n     * Native \"error\" event handler.\n     *\n     * @param {Error} err\n     * @ignore\n     */\n    onError_(err) {\n        debug(`Native \"error\" event recieved, emitting line's \"error\" event... (${err})`);\n        this.emit(Server.Event.ERROR, err);\n    }\n\n\n    /**\n     * Returns a object where keys are connection id and values are ServerConnection.\n     *\n     * @returns {{string: ServerConnection}}\n     * @memberOf Server\n     */\n    getConnections() {\n        return this.rooms.root.getConnections();\n    }\n\n\n    /**\n     * Gets a connection by id\n     *\n     * @param {string} id Unique connection id, which can be accessed at `connection.id`\n     * @returns {?ServerConnection}\n     * @memberOf Server\n     * @example\n     * const connection = server.getConnectionById('someId');\n     *\n     * if (connection) {\n     *   connection.send('hello', {optional: 'payload'});\n     * }\n     */\n    getConnectionById(id) {\n        return this.rooms.root.getConnectionById(id);\n    }\n\n\n    /**\n     * Broadcasts a message to all the connected (& handshaked) clients.\n     *\n     * @param {string} name Message name\n     * @param {any=} payload Optional message payload.\n     * @memberOf Server\n     * @example\n     * server.broadcast('hello', {optional: 'payload'});\n     */\n    broadcast(name, payload) {\n        debug(`Broadcasting \"${name}\" message...`);\n        this.rooms.root.broadcast(name, payload); // Can throw INVALID_JSON\n    }\n\n\n    /**\n     * Gets a room by name.\n     * @param {string} room Room name\n     * @returns {?ServerRoom}\n     */\n    getRoom(room) {\n        return this.rooms.getRoom(room);\n    }\n\n    /**\n     * Gets all the rooms of a connection.\n     * @param {ServerConnection} connection\n     * @returns {Array.<string>} Array of room names.\n     */\n    getRoomsOf(connection) {\n        return this.rooms.getRoomsOf(connection);\n    }\n\n\n    /**\n     * Remove a connection from all the rooms.\n     * @param {ServerConnection} connection\n     */\n    removeFromAllRooms(connection) {\n        this.rooms.removeFromAll(connection);\n    }\n}\n\n\n// Expose internal classes\nServer.Message = Message;\nServer.Connection = Connection;\nServer.Error = LineError;\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nServer.ErrorCode = {\n    /**\n     * When constructing `new Server()`, this error could be thrown.\n     */\n    INVALID_OPTIONS: 'sInvalidOptions',\n    /**\n     * This error can be seen in rejection of `server.start()` or `server.stop()` methods.\n     */\n    INVALID_ACTION: 'sInvalidAction',\n    /**\n     * This error is for native websocket errors.\n     */\n    WEBSOCKET_ERROR: 'sWebsocketError'\n};\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n * @example\n * server.on('connection', (connection) => {\n *   connection.send('hello');\n *   ...\n * });\n *\n * // or better, you can use enums\n *\n * server.on(Server.Event.CONNECTION, (connection) => {\n *   connection.send('hello');\n *   ...\n * });\n *\n * // If you want to authorize your client\n * server.on('handshake', (connection, handshake) => {\n *   if (handshake.payload && handshake.payload.authToken == '...')\n *     handshake.resolve({welcome: 'bro'});\n *   else\n *     handshake.reject(new Error('Invalid auth token'));\n * });\n */\nServer.Event = {\n    /**\n     * `handshake` When a client connection is established, this event will be fired before\n     * `connection` event. Please note that, this event has nothing in common with native websocket\n     * handshaking process. If you want to authorize your clients, you must listen this event and\n     * call `handshake.resolve(...)` or `handshake.reject(...)` accordingly. If you do not consume\n     * this events, all the client connections will be accepted.\n     *\n     * ```\n     * function (connection, handshake) {}\n     * ```\n     *\n     * where `connection` is `ServerConnection` and `handshake` is a `Message` instance.\n     */\n    HANDSHAKE: 'handshake',\n    /**\n     * `connection` This event will fire on a client connects **after successful handshake**.\n     *\n     * ```\n     * function (connection) {}\n     * ```\n     *\n     * where `connection` is a `ServerConnection` instance.\n     */\n    CONNECTION: 'connection',\n    /**\n     * `'headers'` Inherited from uws, [see docs](https://github.com/websockets/ws/blob/master/doc/ws.md#event-headers)\n     */\n    HEADERS: 'headers',\n    /**\n     * `'error'` Inherited from uws, [see docs](https://github.com/websockets/ws/blob/master/doc/ws.md#event-error)\n     */\n    ERROR: 'error'\n};\n\n\nmodule.exports = Server;\n\n\n\n// WEBPACK FOOTER //\n// ./src/server/server.js"],"sourceRoot":""}