{"version":3,"sources":["webpack:///server.js","webpack:///webpack/bootstrap 4686893903eaadec0e8f","webpack:///./src/lib/error.js","webpack:///external \"lodash/assign\"","webpack:///./src/lib/message.js","webpack:///external \"debug\"","webpack:///external \"event-emitter-extra\"","webpack:///external \"lodash/forEach\"","webpack:///external \"lodash/isInteger\"","webpack:///external \"lodash/isObject\"","webpack:///./src/server/connection.js","webpack:///./src/server/rooms.js","webpack:///external \"uws\"","webpack:///external \"ws\"","webpack:///./src/lib/closestatus.js","webpack:///./src/lib/deferred.js","webpack:///./src/lib/utils.js","webpack:///./src/server/room.js","webpack:///external \"lodash/clone\"","webpack:///external \"lodash/debounce\"","webpack:///external \"lodash/filter\"","webpack:///external \"lodash/isFunction\"","webpack:///external \"lodash/isString\"","webpack:///external \"lodash/isUndefined\"","webpack:///external \"lodash/map\"","webpack:///external \"lodash/values\"","webpack:///external \"uuid\"","webpack:///./src/server/server.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","Object","defineProperty","configurable","enumerable","get","n","__esModule","o","object","property","prototype","hasOwnProperty","p","s","LineError","code","message","payload","this","stack","Error","require","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","writable","setPrototypeOf","__proto__","_createClass","defineProperties","target","props","length","descriptor","key","protoProps","staticProps","isUndefined","isString","isObject","values","assign","_require","generateDummyId","EventEmitterExtra","Message","_EventEmitterExtra","_ref","id","err","_this","getPrototypeOf","JSON","stringify","ErrorCode","INVALID_JSON","isResponded_","raw","data","parse","e","arguments","undefined","MISSING_ID","ALREADY_RESPONDED","err_","emit","_this2","events","eventNames","forEach","event","removeAllListeners","Name","RESPONSE","HANDSHAKE","PING","ReservedNames","isInteger","debounce","Deferred","uuid","debug","CloseStatus","ServerConnection","socket","server","v4","state","State","AWAITING_HANDSHAKE","deferreds_","autoPing_","on","onMessage_","bind","onError_","onClose_","options","pingInterval","ping","then","CONNECTED","catch","handshakeTimeout","handshakeTimeout_","setTimeout","close","HANDSHAKE_FAILED","flags","Event","ERROR","onHandshakeMessage_","onPingMessage_","onResponseMessage_","indexOf","onMessageWithResponse_","onMessageWithoutResponse_","sendWithoutResponse_","createResponse","once","clearTimeout","responsePayload","rooms","root","add","DISCONNECTED","WEBSOCKET_ERROR","reason","dispose","HANDSHAKE_REJECTED","handshakeListener","resolve","deferred","MESSAGE_REJECTED","reject","_this3","MESSAGE_NOT_RESPONDED","cancel","removeFromAll","remove","rejectAllDeferreds_","newId","HANDSHAKE_ENDED","getConnectionById","ID_CONFLICT","roomName","getRoomsOf","opt_timeout","Promise","send_","_this4","timeout","responseTimeout","setId","onExpire","EXPIRED","MESSAGE_TIMEOUT","_this5","readyState","messageStr","toString","send","_this6","PING_FAILED","PING_ERROR","delay","_this7","filter","map","Room","Rooms","connection","getConnectionsCount","room","INTERNAL_ERROR","DISCONNECT_TIMEOUT","DISPOSED","UNKNOWN_ERROR","_ref$handler","handler","_ref$onExpire","_ref$timeout","resolve_","reject_","timeout_","timeoutDuration_","onExpire_","isFinished_","promise","expire","clearTimeout_","_len","args","Array","_key","apply","_len2","_key2","Math","random","pow","slice","clone","ServerRoom","connections","connectionId","keys","broadcast_","Connection","WebSocketServer","Server","INVALID_OPTIONS","INVALID_ACTION","port","bindEvents_","onConnection_","onHeaders_","headers","HEADERS","getConnections","broadcast","getRoom","CONNECTION"],"mappings":"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","file":"server.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmory imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmory exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tObject.defineProperty(exports, name, {\n/******/ \t\t\tconfigurable: false,\n/******/ \t\t\tenumerable: true,\n/******/ \t\t\tget: getter\n/******/ \t\t});\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 25);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\"use strict\";\n'use strict';\n\nfunction LineError(code, message, payload) {\n    this.name = 'LineError';\n    this.message = message;\n    this.code = code;\n    this.payload = payload;\n    this.stack = new Error().stack;\n}\nLineError.prototype = new Error();\n\nmodule.exports = LineError;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/assign\");\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar isUndefined = __webpack_require__(21);\nvar isString = __webpack_require__(20);\nvar isObject = __webpack_require__(7);\nvar isFunction = __webpack_require__(19);\nvar values = __webpack_require__(23);\nvar assign = __webpack_require__(1);\n\nvar _require = __webpack_require__(14),\n    generateDummyId = _require.generateDummyId;\n\nvar EventEmitterExtra = __webpack_require__(4);\nvar LineError = __webpack_require__(0);\n\n/**\n * Message class.\n *\n * @private\n * @class Message\n * @extends {EventEmitterExtra}\n */\n\nvar Message = function (_EventEmitterExtra) {\n    _inherits(Message, _EventEmitterExtra);\n\n    _createClass(Message, null, [{\n        key: 'parse',\n        value: function parse(raw) {\n            try {\n                var data = JSON.parse(raw);\n\n                // If error is error-like object, construct real error\n                if (isObject(data.e) && isString(data.e.name) && isString(data.e.message)) {\n                    data.e = assign(new Error(), data.e);\n                }\n\n                return new Message({\n                    name: data.n,\n                    payload: data.p,\n                    err: data.e,\n                    id: data.i\n                });\n            } catch (err) {\n                throw new LineError(Message.ErrorCode.INVALID_JSON, 'Could not parse incoming message.');\n            }\n        }\n    }]);\n\n    function Message(_ref) {\n        var name = _ref.name,\n            payload = _ref.payload,\n            id = _ref.id,\n            err = _ref.err;\n\n        _classCallCheck(this, Message);\n\n        var _this = _possibleConstructorReturn(this, (Message.__proto__ || Object.getPrototypeOf(Message)).call(this));\n\n        try {\n            JSON.stringify(payload);\n            JSON.stringify(err);\n        } catch (err) {\n            throw new LineError(Message.ErrorCode.INVALID_JSON, 'Message payload or error must be json-friendly. Maybe circular json?');\n        }\n\n        _this.name = name;\n        _this.payload = payload;\n        _this.id = id;\n        _this.err = err;\n\n        _this.isResponded_ = false;\n        return _this;\n    }\n\n    _createClass(Message, [{\n        key: 'setId',\n        value: function setId() {\n            var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : generateDummyId();\n\n            this.id = id;\n            return id;\n        }\n    }, {\n        key: 'createResponse',\n        value: function createResponse(err, payload) {\n            return new Message({ name: '_r', payload: payload, err: err, id: this.id });\n        }\n\n        /**\n         * Resolves the message with sending a response back. If the source\n         * does not expecting a response, you don't need to call these methods.\n         *\n         * This method can throw:\n         * - `Message.ErrorCode.MISSING_ID`: Message source is not expecting a response.\n         * - `Message.ErrorCode.ALREADY_RESPONDED`: This message is already responded.\n         * - `Message.ErrorCode.INVALID_JSON`: Could not stringify payload. Probably circular json.\n         *\n         * @param {any=} payload\n         */\n\n    }, {\n        key: 'resolve',\n        value: function resolve(payload) {\n            if (isUndefined(this.id)) {\n                throw new LineError(Message.ErrorCode.MISSING_ID, 'This message could not be resolved (no id)');\n            }\n\n            if (this.isResponded_) {\n                throw new LineError(Message.ErrorCode.ALREADY_RESPONDED, 'This message has already responded');\n            }\n\n            try {\n                JSON.stringify(payload);\n            } catch (err_) {\n                throw new LineError(Message.ErrorCode.INVALID_JSON, 'Message must be resolved with json-friendly payload. Maybe circular json?');\n            }\n\n            this.isResponded_ = true;\n            this.emit('resolved', payload);\n        }\n\n        /**\n         * Rejects the message, with sending error response back to the source.\n         *\n         * This method can throw:\n         * - `Message.ErrorCode.MISSING_ID`: Message source is not expecting a response.\n         * - `Message.ErrorCode.ALREADY_RESPONDED`: This message is already responded.\n         * - `Message.ErrorCode.INVALID_JSON`: Could not stringify payload. Probably circular json.\n         *\n         * @param {any=} err\n         */\n\n    }, {\n        key: 'reject',\n        value: function reject(err) {\n            if (isUndefined(this.id)) {\n                throw new LineError(Message.ErrorCode.MISSING_ID, 'This message could not be rejected (no id)');\n            }\n\n            if (this.isResponded_) {\n                throw new LineError(Message.ErrorCode.ALREADY_RESPONDED, 'This message has already responded');\n            }\n\n            try {\n                JSON.stringify(err);\n            } catch (err_) {\n                throw new LineError(Message.ErrorCode.INVALID_JSON, 'Message must be resolved with json-friendly payload. Maybe circular json?');\n            }\n\n            this.isResponded_ = true;\n            this.emit('rejected', err);\n        }\n    }, {\n        key: 'toString',\n        value: function toString() {\n            var data = { n: this.name };\n\n            if (!isUndefined(this.payload)) data.p = this.payload;\n\n            if (!isUndefined(this.id)) data.i = this.id;\n\n            if (!isUndefined(this.err)) {\n                data.e = this.err instanceof Error ? assign({\n                    name: this.err.name,\n                    message: this.err.message\n                }, this.err) : this.err;\n            }\n\n            // We're sure the data is json-friendly\n            return JSON.stringify(data);\n        }\n    }, {\n        key: 'dispose',\n        value: function dispose() {\n            var _this2 = this;\n\n            var events = this.eventNames();\n            events.forEach(function (event) {\n                return _this2.removeAllListeners(event);\n            });\n        }\n    }]);\n\n    return Message;\n}(EventEmitterExtra);\n\n/**\n * These message names are reserved for internal usage.\n * We recommend to not use any message name starts with `_` (underscore).\n *\n * @static\n * @readonly\n * @enum {string}\n */\n\n\nMessage.Name = {\n    /**\n     * `_r`\n     */\n    RESPONSE: '_r',\n    /**\n     * `_h`\n     */\n    HANDSHAKE: '_h',\n    /**\n     * `_p`\n     */\n    PING: '_p'\n};\n\nMessage.ReservedNames = values(Message.Name);\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nMessage.ErrorCode = {\n    /**\n     * `mInvalidJson`\n     */\n    INVALID_JSON: 'mInvalidJson',\n    /**\n     * `mMissingId`\n     */\n    MISSING_ID: 'mMissingId',\n    /**\n     * `mAlreadyResponded`\n     */\n    ALREADY_RESPONDED: 'mAlreadyResponded'\n};\n\nmodule.exports = Message;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"debug\");\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"event-emitter-extra\");\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/forEach\");\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isInteger\");\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isObject\");\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Message = __webpack_require__(2);\nvar EventEmitterExtra = __webpack_require__(4);\nvar assign = __webpack_require__(1);\nvar forEach = __webpack_require__(5);\nvar isInteger = __webpack_require__(6);\nvar isObject = __webpack_require__(7);\nvar debounce = __webpack_require__(17);\nvar Deferred = __webpack_require__(13);\nvar uuid = __webpack_require__(24);\nvar debug = __webpack_require__(3)('line:server:connection');\nvar LineError = __webpack_require__(0);\nvar CloseStatus = __webpack_require__(12);\n\n/**\n * Server connection class. Constructor of this class is not publicly accessible.\n * When you listen `Server.Event.CONNECTION` or `Server.Event.HANDSHAKE`, an instance\n * of `ServerConnection` will be emitted.\n *\n * @class ServerConnection\n * @extends {EventEmitterExtra}\n * @private\n * @property {string} id Unique connection id\n */\n\nvar ServerConnection = function (_EventEmitterExtra) {\n    _inherits(ServerConnection, _EventEmitterExtra);\n\n    function ServerConnection(socket, server) {\n        _classCallCheck(this, ServerConnection);\n\n        var _this = _possibleConstructorReturn(this, (ServerConnection.__proto__ || Object.getPrototypeOf(ServerConnection)).call(this));\n\n        _this.id = uuid.v4();\n        debug('Creating connection with id ' + _this.id + ' ...');\n\n        _this.socket = socket;\n        _this.server = server;\n        _this.state = ServerConnection.State.AWAITING_HANDSHAKE;\n\n        _this.deferreds_ = {};\n        _this.autoPing_ = debounce(function () {});\n\n        _this.socket.on('message', _this.onMessage_.bind(_this));\n        _this.socket.on('error', _this.onError_.bind(_this));\n        _this.socket.on('close', _this.onClose_.bind(_this));\n\n        if (server.options.pingInterval > 0) {\n            _this.autoPing_ = debounce(function () {\n                _this.ping().then(function () {\n                    debug('Auto-ping successful');\n\n                    if (server.options.pingInterval > 0 && _this.state == ServerConnection.State.CONNECTED) {\n                        _this.autoPing_();\n                    }\n                }).catch(function (err) {/* Disconnection is handled in ping */});\n            }, server.options.pingInterval);\n        }\n\n        if (server.options.handshakeTimeout > 0) {\n            _this.handshakeTimeout_ = setTimeout(function () {\n                if (_this.state != ServerConnection.State.AWAITING_HANDSHAKE) {\n                    return debug('Handshake is not awaiting, ignoring handshake timeout...');\n                }\n\n                debug('Handshake timeout exceed, closing the connection...');\n                _this.close(CloseStatus.HANDSHAKE_FAILED.code, 'Handshake not completed after ' + server.options.handshakeTimeout + ' ms');\n            }, server.options.handshakeTimeout);\n        }\n        return _this;\n    }\n\n    /**\n     * Native \"message\" event handler.\n     *\n     * @param {string|Buffer} data\n     * @param {Object} flags\n     * @param {boolean} flags.binary Specifies if data is binary.\n     * @param {boolean} flags.Boolean Specifies if data was masked.\n     * @ignore\n     */\n\n\n    _createClass(ServerConnection, [{\n        key: 'onMessage_',\n        value: function onMessage_(data, flags) {\n            debug('Native \"message\" event recieved: ' + data);\n            var message = void 0;\n\n            // A message is recieved, debounce our auto-ping handler if connected\n            if (this.state == ServerConnection.State.CONNECTED) {\n                this.autoPing_();\n            }\n\n            try {\n                message = Message.parse(data);\n            } catch (err) {\n                this.emit(ServerConnection.Event.ERROR, new LineError(ServerConnection.ErrorCode.INVALID_JSON, 'Could not parse message, invalid json. Check payload for incoming data.', data));\n                return;\n            }\n\n            /**\n             * Route the incoming message\n             */\n            if (message.name == Message.Name.HANDSHAKE) {\n                // Handshake\n                this.onHandshakeMessage_(message);\n            } else if (message.name == Message.Name.PING) {\n                // Ping\n                this.onPingMessage_(message);\n            } else if (message.name == Message.Name.RESPONSE) {\n                // Message response\n                this.onResponseMessage_(message);\n            } else if (Message.ReservedNames.indexOf(message.name) == -1) {\n                // If message name is not reserved\n                if (!message.id) {\n                    // Message without response (no id fields)\n                    this.onMessageWithoutResponse_(message);\n                } else {\n                    // Message arrived awaiting its response\n                    this.onMessageWithResponse_(message);\n                }\n            } else {\n                debug('Could not route the message', message);\n            }\n        }\n\n        /**\n         * On \"handshake\" message handler.\n         *\n         * @param {Message} message\n         * @ignore\n         */\n\n    }, {\n        key: 'onHandshakeMessage_',\n        value: function onHandshakeMessage_(message) {\n            var _this2 = this;\n\n            if (this.state == ServerConnection.State.CONNECTED) {\n                debug('Handshake message recieved but, handshake is already resolved, ignoring...');\n                return this.sendWithoutResponse_(message.createResponse(new Error('Handshake is already resolved'))).catch(function () {/* Ignoring */});\n            }\n\n            debug('Handshake message recieved: ' + message);\n\n            /**\n             * If handshake is resolved\n             */\n            message.once('resolved', function (payload) {\n                debug('Handshake is resolved, sending response...');\n                _this2.state = ServerConnection.State.CONNECTED;\n                _this2.handshakeTimeout_ && clearTimeout(_this2.handshakeTimeout_);\n                _this2.autoPing_(); // Start auto-pinging\n\n                var responsePayload = {\n                    payload: payload,\n                    id: _this2.id\n                };\n\n                _this2.sendWithoutResponse_(message.createResponse(null, responsePayload)).then(function () {\n                    debug('Handshake resolving response is sent, emitting connection...');\n                    _this2.server.rooms.root.add(_this2);\n                    _this2.server.emit('connection', _this2);\n                }).catch(function (err) {\n                    debug('Could not send handshake response', err);\n\n                    // TODO: Emit these errors from the server\n                    if (err instanceof LineError) {\n                        switch (err.code) {\n                            case ServerConnection.ErrorCode.DISCONNECTED:\n                                debug('Connection is gone before handshake completed, ignoring...');\n                                return;\n\n                            case ServerConnection.ErrorCode.WEBSOCKET_ERROR:\n                                // TODO: Try again!\n                                debug('Native websocket error', err.payload);\n                                return _this2.close(CloseStatus.HANDSHAKE_FAILED.code, CloseStatus.HANDSHAKE_FAILED.reason);\n\n                            default:\n                                debug('Unhandled line error', err);\n                                return _this2.close(CloseStatus.HANDSHAKE_FAILED.code, CloseStatus.HANDSHAKE_FAILED.reason);\n                        }\n                    }\n\n                    debug('Unknown error', err);\n                    return _this2.close(CloseStatus.HANDSHAKE_FAILED.code, CloseStatus.HANDSHAKE_FAILED.reason);\n                }).then(function () {\n                    message.dispose();\n                });\n            });\n\n            /**\n             * Id handshake is rejected\n             */\n            message.once('rejected', function (err) {\n                debug('Handshake is rejected, sending response...');\n\n                _this2.sendWithoutResponse_(message.createResponse(err)).catch(function (err) {\n                    return debug('Handshake rejecting response could not sent, manually calling \"close\"...', err);\n                }).then(function () {\n                    return _this2.close(CloseStatus.HANDSHAKE_REJECTED.code, CloseStatus.HANDSHAKE_REJECTED.reason, 50);\n                }).then(function () {\n                    message.dispose();\n                });\n            });\n\n            /**\n             * Emit handshake event from the server\n             */\n            debug('Emitting server\\'s \"handshake\" event...');\n            var handshakeListener = this.server.emit('handshake', this, message);\n\n            if (!handshakeListener) {\n                debug('There is no handshake listener, resolving the handshake by default...');\n                message.resolve();\n            }\n        }\n\n        /**\n         * On \"ping\" message handler. Reply with pong.\n         *\n         * @param {Message} message\n         * @ignore\n         */\n\n    }, {\n        key: 'onPingMessage_',\n        value: function onPingMessage_(message) {\n            debug('Ping received, responding with \"pong\"...');\n\n            this.sendWithoutResponse_(message.createResponse(null, 'pong')).catch(function (err) {\n                return debug('Ping response failed to send back, ignoring for now...', err);\n            });\n        }\n\n        /**\n         * A message is recieved, and its response is expected.\n         *\n         * @param {Message} message\n         * @ignore\n         */\n\n    }, {\n        key: 'onResponseMessage_',\n        value: function onResponseMessage_(message) {\n            var deferred = this.deferreds_[message.id];\n            if (!deferred) return;\n\n            if (message.err) {\n                debug('Response (rejecting) recieved: ' + message);\n                var err = new LineError(ServerConnection.ErrorCode.MESSAGE_REJECTED, 'Message is rejected by server, check payload.', message.err);\n                deferred.reject(err);\n            } else {\n                debug('Response (resolving) recieved: ' + message);\n                deferred.resolve(message.payload);\n            }\n\n            delete this.deferreds_[message.id];\n        }\n\n        /**\n         * A message is arrived without waiting its response.\n         *\n         * @param {Message} message\n         * @ignore\n         */\n\n    }, {\n        key: 'onMessageWithoutResponse_',\n        value: function onMessageWithoutResponse_(message) {\n            debug('Message without response: name=\"' + message.name + '\"');\n            this.emit(message.name, message);\n        }\n\n        /**\n         * A message is arrived and the client is expecting its response.\n         *\n         * @param {Message} message\n         * @ignore\n         */\n\n    }, {\n        key: 'onMessageWithResponse_',\n        value: function onMessageWithResponse_(message) {\n            var _this3 = this;\n\n            debug('Message with response: name=\"' + message.name + '\" id=\"' + message.id + '\"');\n\n            message.once('resolved', function (payload) {\n                debug('Message #' + message.id + ' is resolved, sending response...');\n                _this3.sendWithoutResponse_(message.createResponse(null, payload)).catch(function (err) {\n                    _this3.emit(ServerConnection.Event.ERROR, new LineError(ServerConnection.ErrorCode.MESSAGE_NOT_RESPONDED, 'Message (name=\"' + message.name + '\" id=\"' + message.id + '\") could not responded (resolve)', err));\n                }).then(function () {\n                    return message.dispose();\n                });\n            });\n\n            message.once('rejected', function (err) {\n                debug('Message #' + message.id + ' is rejected, sending response...');\n                _this3.sendWithoutResponse_(message.createResponse(err)).catch(function (err) {\n                    _this3.emit(ServerConnection.Event.ERROR, new LineError(ServerConnection.ErrorCode.MESSAGE_NOT_RESPONDED, 'Message (name=\"' + message.name + '\" id=\"' + message.id + '\") could not responded (reject)', err));\n                }).then(function () {\n                    return message.dispose();\n                });\n            });\n\n            this.emit(message.name, message);\n        }\n\n        /**\n         * Native \"error\" event.\n         *\n         * @param {Error} err\n         * @ignore\n         */\n\n    }, {\n        key: 'onError_',\n        value: function onError_(err) {\n            debug('Native \"error\" event recieved, emitting line\\'s \"error\" event: ' + err);\n            this.emit(ServerConnection.Event.ERROR, err);\n        }\n\n        /**\n         * Native \"close\" event.\n         *\n         * @param {number} code\n         * @param {string=} reason\n         * @ignore\n         */\n\n    }, {\n        key: 'onClose_',\n        value: function onClose_(code, reason) {\n            debug('Native \"close\" event recieved with code ' + code + ': ' + reason);\n            debug('Removing connection from all rooms, rejecting all waiting messages...');\n\n            this.handshakeTimeout_ && clearTimeout(this.handshakeTimeout_);\n            this.autoPing_.cancel();\n            this.server.rooms.removeFromAll(this);\n            this.server.rooms.root.remove(this);\n            this.rejectAllDeferreds_(new LineError(ServerConnection.ErrorCode.DISCONNECTED, 'Socket connection closed!'));\n\n            debug('Emitting line\\'s \"close\" event...');\n            this.state = ServerConnection.State.DISCONNECTED;\n            this.emit(ServerConnection.Event.DISCONNECTED, code, reason);\n        }\n\n        /**\n         * Changes connection's id, it's random by default. This method is helpful if you already have\n         * custom identification for your clients. You must do this before handshake resolved. If\n         * handshake is already resolved or there is conflict, this method will throw error.\n         *\n         * Throws:\n         * - `ServerConnection.ErrorCode.HANDSHAKE_ENDED`: Id could not be changed after handshake\n         * - `ServerConnection.ErrorCode.ID_CONFLICT`: There is alrady another connection with provided id.\n         *\n         * @param {string} newId New connection id\n         * @memberOf ServerConnection\n         * @example\n         * server.on(Server.Event.HANDSHAKE, (connection, handshake) => {\n         *   // Assuming client's `options.handshake.payload` is something like `{authToken: '...'}`\n         *\n         *   // Imaginary db\n         *   db.find(handshake.payload.authToken, (record) => {\n         *     if (!record) return handshake.reject(new Error('Invalid auth token'));\n         *     connection.setId(record.id);\n         *     handshake.resolve(record);\n         *   });\n         * });\n         */\n\n    }, {\n        key: 'setId',\n        value: function setId(newId) {\n            if (this.state != ServerConnection.State.AWAITING_HANDSHAKE) {\n                throw new LineError(ServerConnection.ErrorCode.HANDSHAKE_ENDED, 'Handshake already ended, you cannot change connection id anymore');\n            }\n\n            if (this.server.getConnectionById(newId)) {\n                throw new LineError(ServerConnection.ErrorCode.ID_CONFLICT, 'Conflict! There is already connection with id ' + newId);\n            }\n\n            this.id = newId;\n        }\n\n        /**\n         * Joins the connection into provided room. If there is no room, it will be created automatically.\n         *\n         * @param {string} roomName\n         * @memberOf ServerConnection\n         */\n\n    }, {\n        key: 'joinRoom',\n        value: function joinRoom(roomName) {\n            this.server.rooms.add(roomName, this);\n        }\n\n        /**\n         * Leaves the connection from provided room.\n         *\n         * @param {string} roomName\n         * @memberOf ServerConnection\n         */\n\n    }, {\n        key: 'leaveRoom',\n        value: function leaveRoom(roomName) {\n            this.server.rooms.remove(roomName, this);\n        }\n\n        /**\n         * Gets the joined room names.\n         *\n         * @returns {Array<string>}\n         * @memberOf ServerConnection\n         */\n\n    }, {\n        key: 'getRooms',\n        value: function getRooms() {\n            return this.server.rooms.getRoomsOf(this);\n        }\n\n        /**\n         * Sends a message to client with awaiting its response. This method returns a promise\n         * which resolves the payload parameter will be passed into `message.resolve(...)` in client-side.\n         *\n         * If client rejects the message with `message.reject(...)`, this promise will be rejected with\n         * `ServerConnection.ErrorCode.MESSAGE_REJECTED`. You can access the original error object with `err.payload`.\n         *\n         * Rejections:\n         * - `ServerConnection.ErrorCode.INVALID_JSON`: Could not stringify the message payload. Probably circular json.\n         * - `ServerConnection.ErrorCode.MESSAGE_REJECTED`: Message is explicitly rejected by the client.\n         * - `ServerConnection.ErrorCode.MESSAGE_TIMEOUT`: Message response did not arrived, timeout exceeded.\n         * - `ServerConnection.ErrorCode.DISCONNECTED`: Client is not connected (& handshake resolved) or connection is closing\n         * - `ServerConnection.ErrorCode.WEBSOCKET_ERROR`: Native websocket error\n         *\n         * @param {string} name\n         * @param {any=} payload\n         * @param {number=} timout\n         * @returns {Promise<any>}\n         * @memberOf ServerConnection\n         * @example\n         * connection\n         *   .send('hello', {optional: 'payload'})\n         *   .then((data) => {\n         *     // Message is resolved by client\n         *   })\n         *   .catch((err) => {\n         *     // Could not send message\n         *     // or\n         *     // Client rejected the message!\n         *   });\n         */\n\n    }, {\n        key: 'send',\n        value: function send(name, payload, opt_timeout) {\n            // This method is for external usage!\n            if (this.state != ServerConnection.State.CONNECTED) {\n                return Promise.reject(new LineError(ServerConnection.ErrorCode.DISCONNECTED, 'Could not send message, client is not connected.'));\n            }\n\n            try {\n                var message = new Message({ name: name, payload: payload });\n                return this.send_(message, opt_timeout);\n            } catch (err) {\n                // `err` can only be Message.ErrorCode.INVALID_JSON\n                return Promise.reject(new LineError(ServerConnection.ErrorCode.INVALID_JSON, 'Could not send message, \"payload\" stringify error. Probably circular json issue.'));\n            }\n        }\n\n        /**\n         * Sends a message to client without waiting its response. This method returns a promise\n         * that resolves with nothing if the message is successfully sent.\n         *\n         * Rejections:\n         * - `ServerConnection.ErrorCode.INVALID_JSON`: Could not stringify the message payload. Probably circular json.\n         * - `ServerConnection.ErrorCode.DISCONNECTED`: Client is not connected (& handshake resolved) or connection is closing\n         * - `ServerConnection.ErrorCode.WEBSOCKET_ERROR`: Native websocket error\n         *\n         * @param {string} name\n         * @param {any=} payload\n         * @returns {Promise}\n         * @memberOf ServerConnection\n         * @example\n         * connection\n         *   .sendWithoutResponse('hello', {optional: 'payload'})\n         *   .then(() => {\n         *     // Message sent successfully\n         *   })\n         *   .catch((err) => {\n         *     // Message could not be sent to client\n         *   })\n         */\n\n    }, {\n        key: 'sendWithoutResponse',\n        value: function sendWithoutResponse(name, payload) {\n            // For external usage\n            if (this.state != ServerConnection.State.CONNECTED) {\n                return Promise.reject(new LineError(ServerConnection.ErrorCode.DISCONNECTED, 'Could not send message, client is not connected.'));\n            }\n\n            try {\n                var message = new Message({ name: name, payload: payload }); // Can throw Message.ErrorCode.INVALID_JSON\n                return this.sendWithoutResponse_(message);\n            } catch (err) {\n                // `err` can only be Message.ErrorCode.INVALID_JSON\n                return Promise.reject(new LineError(ServerConnection.ErrorCode.INVALID_JSON, 'Could not send message, \"payload\" stringify error. Probably circular json issue.'));\n            }\n        }\n\n        /**\n         * Base method for sending a message with timeout. Please favor this method internally\n         * instead of using `send` method.\n         *\n         * Rejections:\n         * - `ServerConnection.ErrorCode.MESSAGE_REJECTED`: Message is explicitly rejected by the client.\n         * - `ServerConnection.ErrorCode.MESSAGE_TIMEOUT`: Message response did not arrived, timeout exceeded.\n         * - `ServerConnection.ErrorCode.DISCONNECTED`: Client is not connected (& handshake resolved) or connection is closing\n         * - `ServerConnection.ErrorCode.WEBSOCKET_ERROR`: Native websocket error\n         *\n         * @param {Message} message\n         * @param {number=} opt_timeout\n         * @returns {Promise}\n         * @ignore\n         */\n\n    }, {\n        key: 'send_',\n        value: function send_(message, opt_timeout) {\n            var _this4 = this;\n\n            var timeout = isInteger(opt_timeout) && opt_timeout >= 0 ? opt_timeout : this.server.options.responseTimeout;\n            message.setId();\n\n            var deferred = this.deferreds_[message.id] = new Deferred({\n                onExpire: function onExpire() {\n                    delete _this4.deferreds_[message.id];\n                },\n                timeout: timeout\n            });\n\n            return this.sendWithoutResponse_(message).then(function () {\n                return deferred;\n            }).catch(function (err) {\n                deferred.dispose();\n\n                // Convert expired -> timeout error\n                if (err instanceof LineError && err.code == Deferred.ErrorCode.EXPIRED) {\n                    throw new LineError(ServerConnection.ErrorCode.MESSAGE_TIMEOUT, 'Message timeout! Its response did not recived after ' + timeout + ' ms');\n                }\n\n                throw err;\n            });\n        }\n\n        /**\n         * Base method for sending a message without response. Please favor this method internally\n         * instead of using `sendWithoutResponse` method.\n         *\n         * Rejections:\n         * - `ServerConnection.ErrorCode.DISCONNECTED`: Client is not connected (& handshake resolved) or connection is closing\n         * - `ServerConnection.ErrorCode.WEBSOCKET_ERROR`: Native websocket error\n         *\n         * @param {Message} message\n         * @returns {Promise}\n         * @ignore\n         */\n\n    }, {\n        key: 'sendWithoutResponse_',\n        value: function sendWithoutResponse_(message) {\n            var _this5 = this;\n\n            if (!this.socket || this.socket.readyState != 1) {\n                return Promise.reject(new LineError(ServerConnection.ErrorCode.DISCONNECTED, 'Could not send message, there is no open connection.'));\n            }\n\n            return new Promise(function (resolve, reject) {\n                debug('Sending message: ' + message);\n                var messageStr = message.toString();\n\n                _this5.socket.send(messageStr, function (err) {\n                    if (err) {\n                        return reject(new LineError(ServerConnection.ErrorCode.WEBSOCKET_ERROR, 'Could not send message, native websocket error, check payload.', err));\n                    }\n\n                    resolve();\n                });\n            });\n        }\n\n        /**\n         * Pings the client. If there is no respose, closes the connection.\n         *\n         * @returns {Promise}\n         * @memberOf ServerConnection\n         */\n\n    }, {\n        key: 'ping',\n        value: function ping() {\n            var _this6 = this;\n\n            debug('Pinging...');\n            return this.send_(new Message({ name: Message.Name.PING })).catch(function (err) {\n                // No matter what error is, start disconnection process\n                debug('Auto-ping failed, manually disconnecting...');\n                _this6.close(CloseStatus.PING_FAILED.code, CloseStatus.PING_FAILED.reason);\n                throw new LineError(ServerConnection.ErrorCode.PING_ERROR, 'Ping failed, manually disconnecting...', err);\n            });\n        }\n\n        /**\n         * Gracefully closes the client connection.\n         *\n         * @param {number=} code\n         * @param {string=} reason\n         * @param {number=} delay\n         * @returns {Promise}\n         */\n\n    }, {\n        key: 'close',\n        value: function close(code, reason, delay) {\n            var _this7 = this;\n\n            debug('Closing the connection in ' + (delay || 0) + ' ms...');\n            return new Promise(function (resolve) {\n                setTimeout(function () {\n                    _this7.socket.close(code || 1000, reason);\n                    resolve();\n                }, delay || 0);\n            });\n        }\n\n        /**\n         * Reject all the awaiting deferred with given error.\n         *\n         * @param {Error} err An error object to reject all awaiting deferreds.\n         * @ignore\n         */\n\n    }, {\n        key: 'rejectAllDeferreds_',\n        value: function rejectAllDeferreds_(err) {\n            forEach(this.deferreds_, function (deferred) {\n                return deferred.reject(err);\n            });\n            this.deferreds_ = {};\n        }\n    }]);\n\n    return ServerConnection;\n}(EventEmitterExtra);\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\n\n\nServerConnection.ErrorCode = {\n    /**\n     * This error can be seen in rejection of `serverConnection.send()` method.\n     */\n    MESSAGE_TIMEOUT: 'scMessageTimeout',\n    /**\n     * This error can be seen in rejection of `serverConnection.send()` method,\n     * which again indicates that server is explicitly rejected the message.\n     */\n    MESSAGE_REJECTED: 'scMessageRejected',\n    /**\n     * When the response of a message failed to send to client, this error\n     * will be emitted in `ServerConnection.Event.ERROR` event.\n     */\n    MESSAGE_NOT_RESPONDED: 'cMessageNotResponded',\n    /**\n     * Indicates an error while json parsing/stringify.\n     */\n    INVALID_JSON: 'scInvalidJson',\n    /**\n     * This error can be thrown in `serverConnection.setId()`. Connection id\n     * cannot be set after handshake.\n     */\n    HANDSHAKE_ENDED: 'scHandshakeEnded',\n    /**\n     * This error can be seen while using `serverConnection.setId()`. If there is\n     * already connection with that id, this error will be thrown.\n     */\n    ID_CONFLICT: 'scIdConflict',\n    /**\n     * This error indicates client is disconnected.\n     */\n    DISCONNECTED: 'scDisconnected',\n    /**\n     * This error is for native websocket errors.\n     */\n    WEBSOCKET_ERROR: 'scWebsocketError',\n    /**\n     * This error can be seen in rejection of `serverConnection.ping()` method.\n     */\n    PING_ERROR: 'scPingError'\n};\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nServerConnection.State = {\n    /**\n     * `awaitingHandshake` Connection is open but handshake is not completed yet.\n     */\n    AWAITING_HANDSHAKE: 'awaitingHandshake',\n    /**\n     * `connected` Connection is open and handshake resolved.\n     */\n    CONNECTED: 'connected',\n    /**\n     * `disconnected` There is no open connection.\n     */\n    DISCONNECTED: 'disconnected'\n};\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nServerConnection.Event = {\n    /**\n     * `_error`\n     */\n    ERROR: '_error',\n    /**\n     * `_close`\n     */\n    DISCONNECTED: '_disconnected'\n};\n\nmodule.exports = ServerConnection;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar filter = __webpack_require__(18);\nvar forEach = __webpack_require__(5);\nvar map = __webpack_require__(22);\nvar Room = __webpack_require__(15);\n\nvar Rooms = function () {\n    function Rooms() {\n        _classCallCheck(this, Rooms);\n\n        this.rooms = {};\n        this.root = new Room();\n    }\n\n    _createClass(Rooms, [{\n        key: 'add',\n        value: function add(roomName, connection) {\n            if (!this.rooms[roomName]) this.rooms[roomName] = new Room(roomName);\n\n            this.rooms[roomName].add(connection);\n        }\n    }, {\n        key: 'remove',\n        value: function remove(roomName, connection) {\n            if (!this.rooms[roomName]) return;\n\n            this.rooms[roomName].remove(connection);\n\n            if (!this.rooms[roomName].getConnectionsCount()) delete this.rooms[roomName];\n        }\n    }, {\n        key: 'getRoomsOf',\n        value: function getRoomsOf(connection) {\n            return map(filter(this.rooms, function (room) {\n                return room.getConnectionById(connection.id);\n            }), 'name');\n        }\n    }, {\n        key: 'getRoom',\n        value: function getRoom(room) {\n            return this.rooms[room];\n        }\n    }, {\n        key: 'removeFromAll',\n        value: function removeFromAll(connection) {\n            var _this = this;\n\n            var rooms = this.getRoomsOf(connection);\n            forEach(rooms, function (roomName) {\n                return _this.rooms[roomName].remove(connection);\n            });\n        }\n    }]);\n\n    return Rooms;\n}();\n\nmodule.exports = Rooms;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"uws\");\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"ws\");\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\"use strict\";\n'use strict';\n\nmodule.exports = {\n    INTERNAL_ERROR: { code: 4200, reason: 'Internal error' },\n    PING_FAILED: { code: 4201, reason: 'Ping failed' },\n    HANDSHAKE_FAILED: { code: 4202, reason: 'Handshake failed' },\n    HANDSHAKE_REJECTED: { code: 4203, reason: 'Handshake rejected' },\n    DISCONNECT_TIMEOUT: { code: 4204, reason: 'Disconnect timeout' },\n    DISPOSED: { code: 4205, reason: 'Client disposed' },\n    UNKNOWN_ERROR: { code: 4299, reason: 'Unknown error' }\n};\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar LineError = __webpack_require__(0);\n\nvar Deferred = function () {\n    function Deferred() {\n        var _this = this;\n\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n            _ref$handler = _ref.handler,\n            handler = _ref$handler === undefined ? function () {} : _ref$handler,\n            _ref$onExpire = _ref.onExpire,\n            onExpire = _ref$onExpire === undefined ? function () {} : _ref$onExpire,\n            _ref$timeout = _ref.timeout,\n            timeout = _ref$timeout === undefined ? 0 : _ref$timeout;\n\n        _classCallCheck(this, Deferred);\n\n        this.resolve_ = null;\n        this.reject_ = null;\n\n        this.timeout_ = null;\n        this.timeoutDuration_ = timeout;\n        this.onExpire_ = onExpire;\n        this.isFinished_ = false;\n\n        this.promise = new Promise(function (resolve, reject) {\n            _this.resolve_ = resolve;\n            _this.reject_ = reject;\n\n            try {\n                handler(_this);\n            } catch (err) {\n                _this.reject(err);\n            }\n        });\n\n        if (timeout > 0) {\n            this.timeout_ = setTimeout(this.expire.bind(this), timeout);\n        }\n    }\n\n    _createClass(Deferred, [{\n        key: 'resolve',\n        value: function resolve(data) {\n            if (this.isFinished_) return;\n\n            this.isFinished_ = true;\n            this.clearTimeout_();\n            this.resolve_(data);\n        }\n    }, {\n        key: 'reject',\n        value: function reject(err) {\n            if (this.isFinished_) return;\n\n            this.isFinished_ = true;\n            this.clearTimeout_();\n            this.reject_(err);\n        }\n    }, {\n        key: 'expire',\n        value: function expire() {\n            this.isFinished_ = true;\n            this.clearTimeout_();\n            this.onExpire_();\n            this.reject_(new LineError(Deferred.ErrorCode.EXPIRED, 'Timeout ' + this.timeoutDuration_ + ' ms exceed'));\n        }\n    }, {\n        key: 'dispose',\n        value: function dispose() {\n            this.isFinished_ = true;\n            this.clearTimeout_();\n        }\n    }, {\n        key: 'then',\n        value: function then() {\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n            }\n\n            return this.promise.then.apply(this.promise, args);\n        }\n    }, {\n        key: 'catch',\n        value: function _catch() {\n            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                args[_key2] = arguments[_key2];\n            }\n\n            return this.promise.catch.apply(this.promise, args);\n        }\n    }, {\n        key: 'clearTimeout_',\n        value: function clearTimeout_() {\n            if (this.timeout_) {\n                clearTimeout(this.timeout_);\n                this.timeout_ = null;\n            }\n        }\n    }]);\n\n    return Deferred;\n}();\n\nDeferred.ErrorCode = {\n    EXPIRED: 'dExpired'\n};\n\nmodule.exports = Deferred;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\"use strict\";\n\nvar assign = __webpack_require__(1);\n\n// http://stackoverflow.com/a/6248722\nfunction generateDummyId() {\n    var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;\n\n    return (\"0000\" + (Math.random() * Math.pow(36, length) << 0).toString(36)).slice(-length);\n}\n\nmodule.exports = { generateDummyId: generateDummyId };\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar forEach = __webpack_require__(5);\nvar clone = __webpack_require__(16);\nvar Message = __webpack_require__(2);\nvar debug = __webpack_require__(3)('line:server:room');\nvar LineError = __webpack_require__(0);\n\n/**\n * Line room class.\n *\n * @private\n * @class ServerRoom\n * @param {string} name Room name\n * @property {string} name\n */\n\nvar ServerRoom = function () {\n    function ServerRoom(name) {\n        var connections = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, ServerRoom);\n\n        this.name = name;\n        this.connections = connections;\n    }\n\n    /**\n     * Adds a connection into room.\n     * @param {ServerConnection} connection\n     */\n\n\n    _createClass(ServerRoom, [{\n        key: 'add',\n        value: function add(connection) {\n            // TODO: Check current existing connection maybe?\n            this.connections[connection.id] = connection;\n        }\n\n        /**\n         * Removes a connection from room.\n         * @param {ServerConnection} connection\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'remove',\n        value: function remove(connection) {\n            if (connection != this.connections[connection.id]) {\n                debug('[' + (this.name || 'root') + '] Did not remove \"' + connection.id + '\", connection instance is not added or different');\n                return false;\n            }\n\n            debug('[' + (this.name || 'root') + '] Removing \"' + connection.id + '\"');\n            delete this.connections[connection.id];\n            return true;\n        }\n\n        /**\n         * Gets a connection by id.\n         * @param {string} connectionId\n         * @returns {?ServerConnection}\n         */\n\n    }, {\n        key: 'getConnectionById',\n        value: function getConnectionById(connectionId) {\n            return this.connections[connectionId];\n        }\n\n        /**\n         * Gets all connections in the room. Returns a object where keys are\n         * connection id and values are ServerConnection.\n         * @returns {{string: ServerConnection}}\n         */\n\n    }, {\n        key: 'getConnections',\n        value: function getConnections() {\n            return clone(this.connections);\n        }\n\n        /**\n         * Returns the total connection count in room.\n         * @returns {number}\n         */\n\n    }, {\n        key: 'getConnectionsCount',\n        value: function getConnectionsCount() {\n            return Object.keys(this.connections).length;\n        }\n    }, {\n        key: 'broadcast_',\n        value: function broadcast_(message) {\n            var _this = this;\n\n            forEach(this.connections, function (connection) {\n                connection.sendWithoutResponse_(message).catch(function (err) {\n                    debug('[' + (_this.name || 'root') + '] Could not send \"' + message.name + '\" to \"' + connection.id + '\" while broadcasting, ignoring...');\n                });\n            });\n        }\n\n        /**\n         * Broadcast a message to all connections in the room.\n         * @param {string} name\n         * @param {any=} payload\n         */\n\n    }, {\n        key: 'broadcast',\n        value: function broadcast(name, payload) {\n            var message = new Message({ name: name, payload: payload }); // Can throw INVALID_JSON\n            this.broadcast_(message);\n        }\n    }]);\n\n    return ServerRoom;\n}();\n\nmodule.exports = ServerRoom;\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/clone\");\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/debounce\");\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/filter\");\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isFunction\");\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isString\");\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/isUndefined\");\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/map\");\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"lodash/values\");\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\nmodule.exports = require(\"uuid\");\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Connection = __webpack_require__(8);\nvar Message = __webpack_require__(2);\nvar Rooms = __webpack_require__(9);\nvar EventEmitterExtra = __webpack_require__(4);\nvar debug = __webpack_require__(3)('line:server');\nvar LineError = __webpack_require__(0);\nvar assign = __webpack_require__(1);\nvar isInteger = __webpack_require__(6);\n\nvar WebSocketServer = void 0;\ntry {\n    WebSocketServer = __webpack_require__(10).Server;\n} catch (err) {\n    WebSocketServer = __webpack_require__(11).Server;\n    debug('Could not find module uws, falling back to ws', err);\n}\n\n/**\n * Line Server Class\n *\n * @class Server\n * @extends {EventEmitterExtra}\n * @param {Object=} options Options object.\n * @param {string=} options.host The hostname where to bind the server. [Inherited from uws.](https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketserveroptions-callback)\n * @param {number=} options.port The port where to bind the server. [Inherited from uws.](https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketserveroptions-callback)\n * @param {http.Server=} options.server A pre-created Node.js HTTP server. If provided, `host` and `port`\n *      will ignored. [Inherited from uws.](https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketserveroptions-callback)\n * @param {string=} options.path Accept only connections matching this path. [Inherited from uws](https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketserveroptions-callback)\n * @param {number=} options.responseTimeout Default timeout duration (in ms) for message responses. Default: `10000` (10 seconds)\n * @param {number=} options.handshakeTimeout This is the duration how long a client can stay connected\n *      without handshake. Default `60000` (1 minute).\n * @param {number=} options.pingInterval Ping interval in ms. Default: 15 seconds.\n * @example\n * const Server = require('line-socket/server');\n * const server = new Server({\n *   port: 8080\n * });\n */\n\nvar Server = function (_EventEmitterExtra) {\n    _inherits(Server, _EventEmitterExtra);\n\n    function Server() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, Server);\n\n        var _this = _possibleConstructorReturn(this, (Server.__proto__ || Object.getPrototypeOf(Server)).call(this));\n\n        _this.options = assign({\n            responseTimeout: 10000,\n            handshakeTimeout: 60000,\n            pingInterval: 15000\n        }, options);\n\n        if (!isInteger(_this.options.responseTimeout) || _this.options.responseTimeout < 0) throw new LineError(Server.ErrorCode.INVALID_OPTIONS, '\"options.responseTimeout\" must be a positive integer or zero');\n\n        if (!isInteger(_this.options.handshakeTimeout) || _this.options.handshakeTimeout < 0) throw new LineError(Server.ErrorCode.INVALID_OPTIONS, '\"options.handshakeTimeout\" must be a positive integer or zero');\n\n        if (!isInteger(_this.options.pingInterval) || _this.options.pingInterval < 0) throw new LineError(Server.ErrorCode.INVALID_OPTIONS, '\"options.pingInterval\" must be a positive integer or zero');\n\n        _this.rooms = new Rooms();\n\n        debug('Initalizing with options: ' + JSON.stringify(_this.options));\n        return _this;\n    }\n\n    /**\n     * Starts the server.\n     *\n     * @returns {Promise}\n     * @memberOf Server\n     * @example\n     * server\n     *   .start()\n     *   .then(() => {\n     *     console.log('Server started');\n     *   })\n     *   .catch((err) => {\n     *     console.log('Server could not started', err);\n     *   });\n     */\n\n\n    _createClass(Server, [{\n        key: 'start',\n        value: function start() {\n            var _this2 = this;\n\n            if (this.server) {\n                return Promise.reject(new LineError(Server.ErrorCode.INVALID_ACTION, 'Could not start server, already started!'));\n            }\n\n            if (!this.options.port) {\n                debug('Starting without port...');\n\n                try {\n                    this.server = new WebSocketServer(this.options);\n                    this.bindEvents_();\n                    return Promise.resolve();\n                } catch (err) {\n                    return Promise.reject(new LineError(Server.ErrorCode.WEBSOCKET_ERROR, 'Could not start the server, websocket error, check payload', err));\n                }\n            }\n\n            return new Promise(function (resolve, reject) {\n                debug('Starting with port \"' + _this2.options.port + '\" ...');\n\n                _this2.server = new WebSocketServer(_this2.options, function (err) {\n                    if (err) {\n                        debug('Could not start: ' + err);\n                        return reject(new LineError(Server.ErrorCode.WEBSOCKET_ERROR, 'Could not start the server, websocket error, check payload', err));\n                    }\n\n                    _this2.bindEvents_();\n                    resolve();\n                });\n            });\n        }\n\n        /**\n         * Stops the server.\n         *\n         * @returns {Promise}\n         * @memberOf Server\n         * @example\n         * server\n         *   .stop()\n         *   .then(() => {\n         *     console.log('Server stopped');\n         *   })\n         *   .catch((err) => {\n         *     console.log('Server could not stopped', err);\n         *   });\n         */\n\n    }, {\n        key: 'stop',\n        value: function stop() {\n            var _this3 = this;\n\n            if (!this.server) {\n                debug('Could not stop server. Server is probably not started, or already stopped.');\n                return Promise.reject(new LineError(Server.ErrorCode.INVALID_ACTION, 'Could not stop server. Server is probably not started, or already stopped!'));\n            }\n\n            return new Promise(function (resolve) {\n                debug('Closing and disposing the server...');\n                _this3.server.close();\n                _this3.server = null;\n                resolve();\n            });\n        }\n\n        /**\n         * Binds websocket server events.\n         *\n         * @ignore\n         */\n\n    }, {\n        key: 'bindEvents_',\n        value: function bindEvents_() {\n            debug('Binding server events...');\n\n            this.server.on('connection', this.onConnection_.bind(this));\n            this.server.on('headers', this.onHeaders_.bind(this));\n            this.server.on('error', this.onError_.bind(this));\n        }\n\n        /**\n         * Native \"connection\" event handler.\n         *\n         * @param {WebSocket} socket\n         * @ignore\n         */\n\n    }, {\n        key: 'onConnection_',\n        value: function onConnection_(socket) {\n            debug('Native \"connection\" event recieved, creating line connection...');\n            var connection = new Connection(socket, this);\n        }\n\n        /**\n         * Native \"headers\" event handler.\n         *\n         * @param {Array} headers\n         * @ignore\n         */\n\n    }, {\n        key: 'onHeaders_',\n        value: function onHeaders_(headers) {\n            debug('Native \"headers\" event recieved, emitting line\\'s \"headers\" event... (' + headers + ')');\n            this.emit(Server.Event.HEADERS, headers);\n        }\n\n        /**\n         * Native \"error\" event handler.\n         *\n         * @param {Error} err\n         * @ignore\n         */\n\n    }, {\n        key: 'onError_',\n        value: function onError_(err) {\n            debug('Native \"error\" event recieved, emitting line\\'s \"error\" event... (' + err + ')');\n            this.emit(Server.Event.ERROR, err);\n        }\n\n        /**\n         * Returns a object where keys are connection id and values are ServerConnection.\n         *\n         * @returns {{string: ServerConnection}}\n         * @memberOf Server\n         */\n\n    }, {\n        key: 'getConnections',\n        value: function getConnections() {\n            return this.rooms.root.getConnections();\n        }\n\n        /**\n         * Gets a connection by id\n         *\n         * @param {string} id Unique connection id, which can be accessed at `connection.id`\n         * @returns {?ServerConnection}\n         * @memberOf Server\n         * @example\n         * const connection = server.getConnectionById('someId');\n         *\n         * if (connection) {\n         *   connection.send('hello', {optional: 'payload'});\n         * }\n         */\n\n    }, {\n        key: 'getConnectionById',\n        value: function getConnectionById(id) {\n            return this.rooms.root.getConnectionById(id);\n        }\n\n        /**\n         * Broadcasts a message to all the connected (& handshaked) clients.\n         *\n         * @param {string} name Message name\n         * @param {any=} payload Optional message payload.\n         * @memberOf Server\n         * @example\n         * server.broadcast('hello', {optional: 'payload'});\n         */\n\n    }, {\n        key: 'broadcast',\n        value: function broadcast(name, payload) {\n            debug('Broadcasting \"' + name + '\" message...');\n            this.rooms.root.broadcast(name, payload); // Can throw INVALID_JSON\n        }\n\n        /**\n         * Gets a room by name.\n         * @param {string} room Room name\n         * @returns {?ServerRoom}\n         */\n\n    }, {\n        key: 'getRoom',\n        value: function getRoom(room) {\n            return this.rooms.getRoom(room);\n        }\n\n        /**\n         * Gets all the rooms of a connection.\n         * @param {ServerConnection} connection\n         * @returns {Array.<string>} Array of room names.\n         */\n\n    }, {\n        key: 'getRoomsOf',\n        value: function getRoomsOf(connection) {\n            return this.rooms.getRoomsOf(connection);\n        }\n\n        /**\n         * Remove a connection from all the rooms.\n         * @param {ServerConnection} connection\n         */\n\n    }, {\n        key: 'removeFromAllRooms',\n        value: function removeFromAllRooms(connection) {\n            this.rooms.removeFromAll(connection);\n        }\n    }]);\n\n    return Server;\n}(EventEmitterExtra);\n\n// Expose internal classes\n\n\nServer.Message = Message;\nServer.Connection = Connection;\nServer.Error = LineError;\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nServer.ErrorCode = {\n    /**\n     * When constructing `new Server()`, this error could be thrown.\n     */\n    INVALID_OPTIONS: 'sInvalidOptions',\n    /**\n     * This error can be seen in rejection of `server.start()` or `server.stop()` methods.\n     */\n    INVALID_ACTION: 'sInvalidAction',\n    /**\n     * This error is for native websocket errors.\n     */\n    WEBSOCKET_ERROR: 'sWebsocketError'\n};\n\n/**\n * @static\n * @readonly\n * @enum {string}\n * @example\n * server.on('connection', (connection) => {\n *   connection.send('hello');\n *   ...\n * });\n *\n * // or better, you can use enums\n *\n * server.on(Server.Event.CONNECTION, (connection) => {\n *   connection.send('hello');\n *   ...\n * });\n *\n * // If you want to authorize your client\n * server.on('handshake', (connection, handshake) => {\n *   if (handshake.payload && handshake.payload.authToken == '...')\n *     handshake.resolve({welcome: 'bro'});\n *   else\n *     handshake.reject(new Error('Invalid auth token'));\n * });\n */\nServer.Event = {\n    /**\n     * `handshake` When a client connection is established, this event will be fired before\n     * `connection` event. Please note that, this event has nothing in common with native websocket\n     * handshaking process. If you want to authorize your clients, you must listen this event and\n     * call `handshake.resolve(...)` or `handshake.reject(...)` accordingly. If you do not consume\n     * this events, all the client connections will be accepted.\n     *\n     * ```\n     * function (connection, handshake) {}\n     * ```\n     *\n     * where `connection` is `ServerConnection` and `handshake` is a `Message` instance.\n     */\n    HANDSHAKE: 'handshake',\n    /**\n     * `connection` This event will fire on a client connects **after successful handshake**.\n     *\n     * ```\n     * function (connection) {}\n     * ```\n     *\n     * where `connection` is a `ServerConnection` instance.\n     */\n    CONNECTION: 'connection',\n    /**\n     * `'headers'` Inherited from uws, [see docs](https://github.com/websockets/ws/blob/master/doc/ws.md#event-headers)\n     */\n    HEADERS: 'headers',\n    /**\n     * `'error'` Inherited from uws, [see docs](https://github.com/websockets/ws/blob/master/doc/ws.md#event-error)\n     */\n    ERROR: 'error'\n};\n\nmodule.exports = Server;\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// server.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmory imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmory exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tObject.defineProperty(exports, name, {\n \t\t\tconfigurable: false,\n \t\t\tenumerable: true,\n \t\t\tget: getter\n \t\t});\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 25);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 4686893903eaadec0e8f","function LineError(code, message, payload) {\n    this.name = 'LineError';\n    this.message = message;\n    this.code = code;\n    this.payload = payload;\n    this.stack = (new Error()).stack;\n}\nLineError.prototype = new Error;\n\n\nmodule.exports = LineError;\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/error.js","module.exports = require(\"lodash/assign\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/assign\"\n// module id = 1\n// module chunks = 0","const isUndefined = require('lodash/isUndefined');\nconst isString = require('lodash/isString');\nconst isObject = require('lodash/isObject');\nconst isFunction = require('lodash/isFunction');\nconst values = require('lodash/values');\nconst assign = require('lodash/assign');\nconst {generateDummyId} = require('./utils');\nconst EventEmitterExtra = require('event-emitter-extra');\nconst LineError = require('./error');\n\n\n/**\n * Message class.\n *\n * @private\n * @class Message\n * @extends {EventEmitterExtra}\n */\nclass Message extends EventEmitterExtra {\n    static parse(raw) {\n        try {\n            const data = JSON.parse(raw);\n\n            // If error is error-like object, construct real error\n            if (isObject(data.e) && isString(data.e.name) && isString(data.e.message)) {\n                data.e = assign(new Error(), data.e);\n            }\n\n            return new Message({\n                name: data.n,\n                payload: data.p,\n                err: data.e,\n                id: data.i\n            });\n        } catch(err) {\n            throw new LineError(Message.ErrorCode.INVALID_JSON, `Could not parse incoming message.`);\n        }\n    }\n\n\n    constructor({name, payload, id, err}) {\n        super();\n\n        try {\n            JSON.stringify(payload);\n            JSON.stringify(err);\n        } catch (err) {\n            throw new LineError(\n                Message.ErrorCode.INVALID_JSON,\n                `Message payload or error must be json-friendly. Maybe circular json?`\n            );\n        }\n\n        this.name = name;\n        this.payload = payload;\n        this.id = id;\n        this.err = err;\n\n        this.isResponded_ = false;\n    }\n\n\n    setId(id = generateDummyId()) {\n        this.id = id;\n        return id;\n    }\n\n\n    createResponse(err, payload) {\n        return new Message({name: '_r', payload, err, id: this.id});\n    }\n\n\n    /**\n     * Resolves the message with sending a response back. If the source\n     * does not expecting a response, you don't need to call these methods.\n     *\n     * This method can throw:\n     * - `Message.ErrorCode.MISSING_ID`: Message source is not expecting a response.\n     * - `Message.ErrorCode.ALREADY_RESPONDED`: This message is already responded.\n     * - `Message.ErrorCode.INVALID_JSON`: Could not stringify payload. Probably circular json.\n     *\n     * @param {any=} payload\n     */\n    resolve(payload) {\n        if (isUndefined(this.id)) {\n            throw new LineError(Message.ErrorCode.MISSING_ID, `This message could not be resolved (no id)`);\n        }\n\n        if (this.isResponded_) {\n            throw new LineError(Message.ErrorCode.ALREADY_RESPONDED, `This message has already responded`);\n        }\n\n        try {\n            JSON.stringify(payload);\n        } catch (err_) {\n            throw new LineError(\n                Message.ErrorCode.INVALID_JSON,\n                `Message must be resolved with json-friendly payload. Maybe circular json?`\n            );\n        }\n\n        this.isResponded_ = true;\n        this.emit('resolved', payload);\n    }\n\n\n    /**\n     * Rejects the message, with sending error response back to the source.\n     *\n     * This method can throw:\n     * - `Message.ErrorCode.MISSING_ID`: Message source is not expecting a response.\n     * - `Message.ErrorCode.ALREADY_RESPONDED`: This message is already responded.\n     * - `Message.ErrorCode.INVALID_JSON`: Could not stringify payload. Probably circular json.\n     *\n     * @param {any=} err\n     */\n    reject(err) {\n        if (isUndefined(this.id)) {\n            throw new LineError(Message.ErrorCode.MISSING_ID, `This message could not be rejected (no id)`);\n        }\n\n        if (this.isResponded_) {\n            throw new LineError(Message.ErrorCode.ALREADY_RESPONDED, `This message has already responded`);\n        }\n\n\n        try {\n            JSON.stringify(err);\n        } catch (err_) {\n            throw new LineError(\n                Message.ErrorCode.INVALID_JSON,\n                `Message must be resolved with json-friendly payload. Maybe circular json?`\n            );\n        }\n\n        this.isResponded_ = true;\n        this.emit('rejected', err);\n    }\n\n\n    toString() {\n        const data = {n: this.name};\n\n        if (!isUndefined(this.payload))\n            data.p = this.payload;\n\n        if (!isUndefined(this.id))\n            data.i = this.id;\n\n        if (!isUndefined(this.err)) {\n            data.e = this.err instanceof Error ? assign({\n                name: this.err.name,\n                message: this.err.message\n            }, this.err) : this.err;\n        }\n\n        // We're sure the data is json-friendly\n        return JSON.stringify(data);\n    }\n\n\n    dispose() {\n        const events = this.eventNames();\n        events.forEach(event => this.removeAllListeners(event));\n    }\n}\n\n\n/**\n * These message names are reserved for internal usage.\n * We recommend to not use any message name starts with `_` (underscore).\n *\n * @static\n * @readonly\n * @enum {string}\n */\nMessage.Name = {\n    /**\n     * `_r`\n     */\n    RESPONSE: '_r',\n    /**\n     * `_h`\n     */\n    HANDSHAKE: '_h',\n    /**\n     * `_p`\n     */\n    PING: '_p'\n};\n\n\nMessage.ReservedNames = values(Message.Name);\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nMessage.ErrorCode = {\n    /**\n     * `mInvalidJson`\n     */\n    INVALID_JSON: 'mInvalidJson',\n    /**\n     * `mMissingId`\n     */\n    MISSING_ID: 'mMissingId',\n    /**\n     * `mAlreadyResponded`\n     */\n    ALREADY_RESPONDED: 'mAlreadyResponded',\n};\n\n\nmodule.exports = Message;\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/message.js","module.exports = require(\"debug\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"debug\"\n// module id = 3\n// module chunks = 0","module.exports = require(\"event-emitter-extra\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"event-emitter-extra\"\n// module id = 4\n// module chunks = 0","module.exports = require(\"lodash/forEach\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/forEach\"\n// module id = 5\n// module chunks = 0","module.exports = require(\"lodash/isInteger\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isInteger\"\n// module id = 6\n// module chunks = 0","module.exports = require(\"lodash/isObject\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isObject\"\n// module id = 7\n// module chunks = 0","const Message = require('../lib/message');\nconst EventEmitterExtra = require('event-emitter-extra');\nconst assign = require('lodash/assign');\nconst forEach = require('lodash/forEach');\nconst isInteger = require('lodash/isInteger');\nconst isObject = require('lodash/isObject');\nconst debounce = require('lodash/debounce');\nconst Deferred = require('../lib/deferred');\nconst uuid = require('uuid');\nconst debug = require('debug')('line:server:connection');\nconst LineError = require('../lib/error');\nconst CloseStatus = require('../lib/closestatus');\n\n\n/**\n * Server connection class. Constructor of this class is not publicly accessible.\n * When you listen `Server.Event.CONNECTION` or `Server.Event.HANDSHAKE`, an instance\n * of `ServerConnection` will be emitted.\n *\n * @class ServerConnection\n * @extends {EventEmitterExtra}\n * @private\n * @property {string} id Unique connection id\n */\nclass ServerConnection extends EventEmitterExtra {\n    constructor(socket, server) {\n        super();\n\n        this.id = uuid.v4();\n        debug(`Creating connection with id ${this.id} ...`);\n\n        this.socket = socket;\n        this.server = server;\n        this.state = ServerConnection.State.AWAITING_HANDSHAKE;\n\n        this.deferreds_ = {};\n        this.autoPing_ = debounce(() => {});\n\n        this.socket.on('message', this.onMessage_.bind(this));\n        this.socket.on('error', this.onError_.bind(this));\n        this.socket.on('close', this.onClose_.bind(this));\n\n        if (server.options.pingInterval > 0) {\n            this.autoPing_ = debounce(() => {\n                this\n                    .ping()\n                    .then(() => {\n                        debug(`Auto-ping successful`);\n\n                        if (server.options.pingInterval > 0 && this.state == ServerConnection.State.CONNECTED) {\n                            this.autoPing_();\n                        }\n                    })\n                    .catch((err) => {/* Disconnection is handled in ping */});\n            }, server.options.pingInterval);\n        }\n\n        if (server.options.handshakeTimeout > 0) {\n            this.handshakeTimeout_ = setTimeout(() => {\n                if (this.state != ServerConnection.State.AWAITING_HANDSHAKE) {\n                    return debug(`Handshake is not awaiting, ignoring handshake timeout...`);\n                }\n\n                debug(`Handshake timeout exceed, closing the connection...`);\n                this.close(CloseStatus.HANDSHAKE_FAILED.code, `Handshake not completed after ${server.options.handshakeTimeout} ms`);\n            }, server.options.handshakeTimeout);\n        }\n    }\n\n\n    /**\n     * Native \"message\" event handler.\n     *\n     * @param {string|Buffer} data\n     * @param {Object} flags\n     * @param {boolean} flags.binary Specifies if data is binary.\n     * @param {boolean} flags.Boolean Specifies if data was masked.\n     * @ignore\n     */\n    onMessage_(data, flags) {\n        debug(`Native \"message\" event recieved: ${data}`);\n        let message;\n\n        // A message is recieved, debounce our auto-ping handler if connected\n        if (this.state == ServerConnection.State.CONNECTED) {\n            this.autoPing_();\n        }\n\n        try {\n            message = Message.parse(data);\n        } catch (err) {\n            this.emit(ServerConnection.Event.ERROR, new LineError(\n                ServerConnection.ErrorCode.INVALID_JSON,\n                'Could not parse message, invalid json. Check payload for incoming data.',\n                data\n            ));\n            return;\n        }\n\n        /**\n         * Route the incoming message\n         */\n        if (message.name == Message.Name.HANDSHAKE) { // Handshake\n            this.onHandshakeMessage_(message);\n        } else if (message.name == Message.Name.PING) { // Ping\n            this.onPingMessage_(message);\n        } else if (message.name == Message.Name.RESPONSE) { // Message response\n            this.onResponseMessage_(message);\n        } else if (Message.ReservedNames.indexOf(message.name) == -1) { // If message name is not reserved\n            if (!message.id) { // Message without response (no id fields)\n                this.onMessageWithoutResponse_(message);\n            } else { // Message arrived awaiting its response\n                this.onMessageWithResponse_(message);\n            }\n        } else {\n            debug(`Could not route the message`, message);\n        }\n    }\n\n\n    /**\n     * On \"handshake\" message handler.\n     *\n     * @param {Message} message\n     * @ignore\n     */\n    onHandshakeMessage_(message) {\n        if (this.state == ServerConnection.State.CONNECTED) {\n            debug(`Handshake message recieved but, handshake is already resolved, ignoring...`);\n            return this\n                .sendWithoutResponse_(message.createResponse(new Error('Handshake is already resolved')))\n                .catch(() => { /* Ignoring */ });\n        }\n\n        debug(`Handshake message recieved: ${message}`);\n\n        /**\n         * If handshake is resolved\n         */\n        message.once('resolved', (payload) => {\n            debug(`Handshake is resolved, sending response...`);\n            this.state = ServerConnection.State.CONNECTED;\n            this.handshakeTimeout_ && clearTimeout(this.handshakeTimeout_);\n            this.autoPing_(); // Start auto-pinging\n\n            const responsePayload = {\n                payload,\n                id: this.id\n            };\n\n            this\n                .sendWithoutResponse_(message.createResponse(null, responsePayload))\n                .then(() => {\n                    debug(`Handshake resolving response is sent, emitting connection...`);\n                    this.server.rooms.root.add(this);\n                    this.server.emit('connection', this);\n                })\n                .catch((err) => {\n                    debug(`Could not send handshake response`, err);\n\n                    // TODO: Emit these errors from the server\n                    if (err instanceof LineError) {\n                        switch (err.code) {\n                            case ServerConnection.ErrorCode.DISCONNECTED:\n                                debug(`Connection is gone before handshake completed, ignoring...`);\n                                return;\n\n                            case ServerConnection.ErrorCode.WEBSOCKET_ERROR:\n                                // TODO: Try again!\n                                debug('Native websocket error', err.payload);\n                                return this.close(CloseStatus.HANDSHAKE_FAILED.code, CloseStatus.HANDSHAKE_FAILED.reason);\n\n                            default:\n                                debug('Unhandled line error', err);\n                                return this.close(CloseStatus.HANDSHAKE_FAILED.code, CloseStatus.HANDSHAKE_FAILED.reason);\n                        }\n                    }\n\n                    debug(`Unknown error`, err);\n                    return this.close(CloseStatus.HANDSHAKE_FAILED.code, CloseStatus.HANDSHAKE_FAILED.reason);\n                })\n                .then(() => {\n                    message.dispose();\n                });\n        });\n\n        /**\n         * Id handshake is rejected\n         */\n        message.once('rejected', (err) => {\n            debug(`Handshake is rejected, sending response...`);\n\n            this\n                .sendWithoutResponse_(message.createResponse(err))\n                .catch(err => debug(`Handshake rejecting response could not sent, manually calling \"close\"...`, err))\n                .then(() => this.close(CloseStatus.HANDSHAKE_REJECTED.code, CloseStatus.HANDSHAKE_REJECTED.reason, 50))\n                .then(() => {\n                    message.dispose();\n                });\n        });\n\n        /**\n         * Emit handshake event from the server\n         */\n        debug(`Emitting server's \"handshake\" event...`);\n        const handshakeListener = this.server.emit('handshake', this, message);\n\n        if (!handshakeListener) {\n            debug(`There is no handshake listener, resolving the handshake by default...`);\n            message.resolve();\n        }\n    }\n\n\n    /**\n     * On \"ping\" message handler. Reply with pong.\n     *\n     * @param {Message} message\n     * @ignore\n     */\n    onPingMessage_(message) {\n        debug('Ping received, responding with \"pong\"...');\n\n        this\n            .sendWithoutResponse_(message.createResponse(null, 'pong'))\n            .catch(err => debug('Ping response failed to send back, ignoring for now...', err));\n    }\n\n\n    /**\n     * A message is recieved, and its response is expected.\n     *\n     * @param {Message} message\n     * @ignore\n     */\n    onResponseMessage_(message) {\n        const deferred = this.deferreds_[message.id];\n        if (!deferred) return;\n\n        if (message.err) {\n            debug(`Response (rejecting) recieved: ${message}`);\n            const err = new LineError(\n                ServerConnection.ErrorCode.MESSAGE_REJECTED,\n                'Message is rejected by server, check payload.',\n                message.err\n            );\n            deferred.reject(err);\n        } else {\n            debug(`Response (resolving) recieved: ${message}`);\n            deferred.resolve(message.payload);\n        }\n\n        delete this.deferreds_[message.id];\n    }\n\n\n    /**\n     * A message is arrived without waiting its response.\n     *\n     * @param {Message} message\n     * @ignore\n     */\n    onMessageWithoutResponse_(message) {\n        debug(`Message without response: name=\"${message.name}\"`);\n        this.emit(message.name, message);\n    }\n\n\n    /**\n     * A message is arrived and the client is expecting its response.\n     *\n     * @param {Message} message\n     * @ignore\n     */\n    onMessageWithResponse_(message) {\n        debug(`Message with response: name=\"${message.name}\" id=\"${message.id}\"`);\n\n        message.once('resolved', (payload) => {\n            debug(`Message #${message.id} is resolved, sending response...`);\n            this\n                .sendWithoutResponse_(message.createResponse(null, payload))\n                .catch((err) => {\n                    this.emit(ServerConnection.Event.ERROR, new LineError(\n                        ServerConnection.ErrorCode.MESSAGE_NOT_RESPONDED,\n                        `Message (name=\"${message.name}\" id=\"${message.id}\") could not responded (resolve)`,\n                        err\n                    ));\n                })\n                .then(() => message.dispose());\n        });\n\n        message.once('rejected', (err) => {\n            debug(`Message #${message.id} is rejected, sending response...`);\n            this\n                .sendWithoutResponse_(message.createResponse(err))\n                .catch((err) => {\n                    this.emit(ServerConnection.Event.ERROR, new LineError(\n                        ServerConnection.ErrorCode.MESSAGE_NOT_RESPONDED,\n                        `Message (name=\"${message.name}\" id=\"${message.id}\") could not responded (reject)`,\n                        err\n                    ));\n                })\n                .then(() => message.dispose());\n        });\n\n        this.emit(message.name, message);\n    }\n\n\n    /**\n     * Native \"error\" event.\n     *\n     * @param {Error} err\n     * @ignore\n     */\n    onError_(err) {\n        debug(`Native \"error\" event recieved, emitting line's \"error\" event: ${err}`);\n        this.emit(ServerConnection.Event.ERROR, err);\n    }\n\n\n    /**\n     * Native \"close\" event.\n     *\n     * @param {number} code\n     * @param {string=} reason\n     * @ignore\n     */\n    onClose_(code, reason) {\n        debug(`Native \"close\" event recieved with code ${code}: ${reason}`);\n        debug(`Removing connection from all rooms, rejecting all waiting messages...`);\n\n        this.handshakeTimeout_ && clearTimeout(this.handshakeTimeout_);\n        this.autoPing_.cancel();\n        this.server.rooms.removeFromAll(this);\n        this.server.rooms.root.remove(this);\n        this.rejectAllDeferreds_(new LineError(ServerConnection.ErrorCode.DISCONNECTED, 'Socket connection closed!'));\n\n        debug(`Emitting line's \"close\" event...`);\n        this.state = ServerConnection.State.DISCONNECTED;\n        this.emit(ServerConnection.Event.DISCONNECTED, code, reason);\n    }\n\n\n    /**\n     * Changes connection's id, it's random by default. This method is helpful if you already have\n     * custom identification for your clients. You must do this before handshake resolved. If\n     * handshake is already resolved or there is conflict, this method will throw error.\n     *\n     * Throws:\n     * - `ServerConnection.ErrorCode.HANDSHAKE_ENDED`: Id could not be changed after handshake\n     * - `ServerConnection.ErrorCode.ID_CONFLICT`: There is alrady another connection with provided id.\n     *\n     * @param {string} newId New connection id\n     * @memberOf ServerConnection\n     * @example\n     * server.on(Server.Event.HANDSHAKE, (connection, handshake) => {\n     *   // Assuming client's `options.handshake.payload` is something like `{authToken: '...'}`\n     *\n     *   // Imaginary db\n     *   db.find(handshake.payload.authToken, (record) => {\n     *     if (!record) return handshake.reject(new Error('Invalid auth token'));\n     *     connection.setId(record.id);\n     *     handshake.resolve(record);\n     *   });\n     * });\n     */\n    setId(newId) {\n        if (this.state != ServerConnection.State.AWAITING_HANDSHAKE) {\n            throw new LineError(\n                ServerConnection.ErrorCode.HANDSHAKE_ENDED,\n                'Handshake already ended, you cannot change connection id anymore'\n            );\n        }\n\n        if (this.server.getConnectionById(newId)) {\n            throw new LineError(\n                ServerConnection.ErrorCode.ID_CONFLICT,\n                `Conflict! There is already connection with id ${newId}`\n            );\n        }\n\n        this.id = newId;\n    }\n\n\n    /**\n     * Joins the connection into provided room. If there is no room, it will be created automatically.\n     *\n     * @param {string} roomName\n     * @memberOf ServerConnection\n     */\n    joinRoom(roomName) {\n        this.server.rooms.add(roomName, this);\n    }\n\n\n    /**\n     * Leaves the connection from provided room.\n     *\n     * @param {string} roomName\n     * @memberOf ServerConnection\n     */\n    leaveRoom(roomName) {\n        this.server.rooms.remove(roomName, this);\n    }\n\n\n\n    /**\n     * Gets the joined room names.\n     *\n     * @returns {Array<string>}\n     * @memberOf ServerConnection\n     */\n    getRooms() {\n        return this.server.rooms.getRoomsOf(this);\n    }\n\n\n    /**\n     * Sends a message to client with awaiting its response. This method returns a promise\n     * which resolves the payload parameter will be passed into `message.resolve(...)` in client-side.\n     *\n     * If client rejects the message with `message.reject(...)`, this promise will be rejected with\n     * `ServerConnection.ErrorCode.MESSAGE_REJECTED`. You can access the original error object with `err.payload`.\n     *\n     * Rejections:\n     * - `ServerConnection.ErrorCode.INVALID_JSON`: Could not stringify the message payload. Probably circular json.\n     * - `ServerConnection.ErrorCode.MESSAGE_REJECTED`: Message is explicitly rejected by the client.\n     * - `ServerConnection.ErrorCode.MESSAGE_TIMEOUT`: Message response did not arrived, timeout exceeded.\n     * - `ServerConnection.ErrorCode.DISCONNECTED`: Client is not connected (& handshake resolved) or connection is closing\n     * - `ServerConnection.ErrorCode.WEBSOCKET_ERROR`: Native websocket error\n     *\n     * @param {string} name\n     * @param {any=} payload\n     * @param {number=} timout\n     * @returns {Promise<any>}\n     * @memberOf ServerConnection\n     * @example\n     * connection\n     *   .send('hello', {optional: 'payload'})\n     *   .then((data) => {\n     *     // Message is resolved by client\n     *   })\n     *   .catch((err) => {\n     *     // Could not send message\n     *     // or\n     *     // Client rejected the message!\n     *   });\n     */\n    send(name, payload, opt_timeout) { // This method is for external usage!\n        if (this.state != ServerConnection.State.CONNECTED) {\n            return Promise.reject(new LineError(\n                ServerConnection.ErrorCode.DISCONNECTED,\n                `Could not send message, client is not connected.`\n            ));\n        }\n\n        try {\n            const message = new Message({name, payload});\n            return this.send_(message, opt_timeout);\n        } catch (err) {\n            // `err` can only be Message.ErrorCode.INVALID_JSON\n            return Promise.reject(new LineError(\n                ServerConnection.ErrorCode.INVALID_JSON,\n                `Could not send message, \"payload\" stringify error. Probably circular json issue.`\n            ));\n        }\n    }\n\n\n    /**\n     * Sends a message to client without waiting its response. This method returns a promise\n     * that resolves with nothing if the message is successfully sent.\n     *\n     * Rejections:\n     * - `ServerConnection.ErrorCode.INVALID_JSON`: Could not stringify the message payload. Probably circular json.\n     * - `ServerConnection.ErrorCode.DISCONNECTED`: Client is not connected (& handshake resolved) or connection is closing\n     * - `ServerConnection.ErrorCode.WEBSOCKET_ERROR`: Native websocket error\n     *\n     * @param {string} name\n     * @param {any=} payload\n     * @returns {Promise}\n     * @memberOf ServerConnection\n     * @example\n     * connection\n     *   .sendWithoutResponse('hello', {optional: 'payload'})\n     *   .then(() => {\n     *     // Message sent successfully\n     *   })\n     *   .catch((err) => {\n     *     // Message could not be sent to client\n     *   })\n     */\n    sendWithoutResponse(name, payload) { // For external usage\n        if (this.state != ServerConnection.State.CONNECTED) {\n            return Promise.reject(new LineError(\n                ServerConnection.ErrorCode.DISCONNECTED,\n                `Could not send message, client is not connected.`\n            ));\n        }\n\n        try {\n            const message = new Message({name, payload}); // Can throw Message.ErrorCode.INVALID_JSON\n            return this.sendWithoutResponse_(message);\n        } catch (err) {\n            // `err` can only be Message.ErrorCode.INVALID_JSON\n            return Promise.reject(new LineError(\n                ServerConnection.ErrorCode.INVALID_JSON,\n                `Could not send message, \"payload\" stringify error. Probably circular json issue.`\n            ));\n        }\n    }\n\n\n    /**\n     * Base method for sending a message with timeout. Please favor this method internally\n     * instead of using `send` method.\n     *\n     * Rejections:\n     * - `ServerConnection.ErrorCode.MESSAGE_REJECTED`: Message is explicitly rejected by the client.\n     * - `ServerConnection.ErrorCode.MESSAGE_TIMEOUT`: Message response did not arrived, timeout exceeded.\n     * - `ServerConnection.ErrorCode.DISCONNECTED`: Client is not connected (& handshake resolved) or connection is closing\n     * - `ServerConnection.ErrorCode.WEBSOCKET_ERROR`: Native websocket error\n     *\n     * @param {Message} message\n     * @param {number=} opt_timeout\n     * @returns {Promise}\n     * @ignore\n     */\n    send_(message, opt_timeout) {\n        const timeout = isInteger(opt_timeout) && opt_timeout >= 0 ? opt_timeout : this.server.options.responseTimeout;\n        message.setId();\n\n        const deferred = this.deferreds_[message.id] = new Deferred({\n            onExpire: () => {\n                delete this.deferreds_[message.id];\n            },\n            timeout: timeout\n        });\n\n        return this\n            .sendWithoutResponse_(message)\n            .then(() => deferred)\n            .catch((err) => {\n                deferred.dispose();\n\n                // Convert expired -> timeout error\n                if (err instanceof LineError && err.code == Deferred.ErrorCode.EXPIRED) {\n                    throw new LineError(\n                        ServerConnection.ErrorCode.MESSAGE_TIMEOUT,\n                        `Message timeout! Its response did not recived after ${timeout} ms`\n                    );\n                }\n\n                throw err;\n            });\n    }\n\n\n    /**\n     * Base method for sending a message without response. Please favor this method internally\n     * instead of using `sendWithoutResponse` method.\n     *\n     * Rejections:\n     * - `ServerConnection.ErrorCode.DISCONNECTED`: Client is not connected (& handshake resolved) or connection is closing\n     * - `ServerConnection.ErrorCode.WEBSOCKET_ERROR`: Native websocket error\n     *\n     * @param {Message} message\n     * @returns {Promise}\n     * @ignore\n     */\n    sendWithoutResponse_(message) {\n        if (!this.socket || this.socket.readyState != 1) {\n            return Promise.reject(new LineError(\n                ServerConnection.ErrorCode.DISCONNECTED,\n                `Could not send message, there is no open connection.`\n            ));\n        }\n\n        return new Promise((resolve, reject) => {\n            debug(`Sending message: ${message}`);\n            const messageStr = message.toString();\n\n            this.socket.send(messageStr, (err) => {\n                if (err) {\n                    return reject(new LineError(\n                        ServerConnection.ErrorCode.WEBSOCKET_ERROR,\n                        `Could not send message, native websocket error, check payload.`,\n                        err\n                    ));\n                }\n\n                resolve();\n            });\n        });\n    }\n\n\n    /**\n     * Pings the client. If there is no respose, closes the connection.\n     *\n     * @returns {Promise}\n     * @memberOf ServerConnection\n     */\n    ping() {\n        debug(`Pinging...`);\n        return this\n            .send_(new Message({name: Message.Name.PING}))\n            .catch(err => {\n                // No matter what error is, start disconnection process\n                debug('Auto-ping failed, manually disconnecting...');\n                this.close(CloseStatus.PING_FAILED.code, CloseStatus.PING_FAILED.reason);\n                throw new LineError(\n                    ServerConnection.ErrorCode.PING_ERROR,\n                    `Ping failed, manually disconnecting...`,\n                    err\n                );\n            });\n    }\n\n\n    /**\n     * Gracefully closes the client connection.\n     *\n     * @param {number=} code\n     * @param {string=} reason\n     * @param {number=} delay\n     * @returns {Promise}\n     */\n    close(code, reason, delay) {\n        debug(`Closing the connection in ${delay || 0} ms...`);\n        return new Promise((resolve) => {\n            setTimeout(() => {\n                this.socket.close(code || 1000, reason);\n                resolve();\n            }, delay || 0);\n        });\n    }\n\n\n    /**\n     * Reject all the awaiting deferred with given error.\n     *\n     * @param {Error} err An error object to reject all awaiting deferreds.\n     * @ignore\n     */\n    rejectAllDeferreds_(err) {\n        forEach(this.deferreds_, deferred => deferred.reject(err));\n        this.deferreds_ = {};\n    }\n}\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nServerConnection.ErrorCode = {\n    /**\n     * This error can be seen in rejection of `serverConnection.send()` method.\n     */\n    MESSAGE_TIMEOUT: 'scMessageTimeout',\n    /**\n     * This error can be seen in rejection of `serverConnection.send()` method,\n     * which again indicates that server is explicitly rejected the message.\n     */\n    MESSAGE_REJECTED: 'scMessageRejected',\n    /**\n     * When the response of a message failed to send to client, this error\n     * will be emitted in `ServerConnection.Event.ERROR` event.\n     */\n    MESSAGE_NOT_RESPONDED: 'cMessageNotResponded',\n    /**\n     * Indicates an error while json parsing/stringify.\n     */\n    INVALID_JSON: 'scInvalidJson',\n    /**\n     * This error can be thrown in `serverConnection.setId()`. Connection id\n     * cannot be set after handshake.\n     */\n    HANDSHAKE_ENDED: 'scHandshakeEnded',\n    /**\n     * This error can be seen while using `serverConnection.setId()`. If there is\n     * already connection with that id, this error will be thrown.\n     */\n    ID_CONFLICT: 'scIdConflict',\n    /**\n     * This error indicates client is disconnected.\n     */\n    DISCONNECTED: 'scDisconnected',\n    /**\n     * This error is for native websocket errors.\n     */\n    WEBSOCKET_ERROR: 'scWebsocketError',\n    /**\n     * This error can be seen in rejection of `serverConnection.ping()` method.\n     */\n    PING_ERROR: 'scPingError'\n};\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nServerConnection.State = {\n    /**\n     * `awaitingHandshake` Connection is open but handshake is not completed yet.\n     */\n    AWAITING_HANDSHAKE: 'awaitingHandshake',\n    /**\n     * `connected` Connection is open and handshake resolved.\n     */\n    CONNECTED: 'connected',\n    /**\n     * `disconnected` There is no open connection.\n     */\n    DISCONNECTED: 'disconnected'\n};\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nServerConnection.Event = {\n    /**\n     * `_error`\n     */\n    ERROR: '_error',\n    /**\n     * `_close`\n     */\n    DISCONNECTED: '_disconnected'\n};\n\n\nmodule.exports = ServerConnection;\n\n\n\n// WEBPACK FOOTER //\n// ./src/server/connection.js","const filter = require('lodash/filter');\nconst forEach = require('lodash/forEach');\nconst map = require('lodash/map');\nconst Room = require('./room');\n\n\nclass Rooms {\n    constructor() {\n        this.rooms = {};\n        this.root = new Room();\n    }\n\n    add(roomName, connection) {\n        if(!this.rooms[roomName])\n            this.rooms[roomName] = new Room(roomName);\n\n        this.rooms[roomName].add(connection);\n    }\n\n    remove(roomName, connection) {\n        if(!this.rooms[roomName])\n            return;\n\n        this.rooms[roomName].remove(connection);\n\n        if (!this.rooms[roomName].getConnectionsCount())\n            delete this.rooms[roomName];\n    }\n\n    getRoomsOf(connection) {\n        return map(filter(this.rooms, room => room.getConnectionById(connection.id)), 'name');\n    }\n\n    getRoom(room) {\n        return this.rooms[room];\n    }\n\n    removeFromAll(connection) {\n        const rooms = this.getRoomsOf(connection);\n        forEach(rooms, roomName => this.rooms[roomName].remove(connection));\n    }\n}\n\n\nmodule.exports = Rooms;\n\n\n\n// WEBPACK FOOTER //\n// ./src/server/rooms.js","module.exports = require(\"uws\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"uws\"\n// module id = 10\n// module chunks = 0","module.exports = require(\"ws\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"ws\"\n// module id = 11\n// module chunks = 0","module.exports = {\n    INTERNAL_ERROR: {code: 4200, reason: 'Internal error'},\n    PING_FAILED: {code: 4201, reason: 'Ping failed'},\n    HANDSHAKE_FAILED: {code: 4202, reason: 'Handshake failed'},\n    HANDSHAKE_REJECTED: {code: 4203, reason: 'Handshake rejected'},\n    DISCONNECT_TIMEOUT: {code: 4204, reason: 'Disconnect timeout'},\n    DISPOSED: {code: 4205, reason: 'Client disposed'},\n    UNKNOWN_ERROR: {code: 4299, reason: 'Unknown error'},\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/closestatus.js","const LineError = require('./error');\n\n\nclass Deferred {\n    constructor({\n        handler = () => {},\n        onExpire = () => {},\n        timeout = 0\n    } = {}) {\n        this.resolve_ = null;\n        this.reject_ = null;\n\n        this.timeout_ = null;\n        this.timeoutDuration_ = timeout;\n        this.onExpire_ = onExpire;\n        this.isFinished_ = false;\n\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve_ = resolve;\n            this.reject_ = reject;\n\n            try {\n                handler(this);\n            } catch (err) {\n                this.reject(err);\n            }\n        });\n\n        if (timeout > 0) {\n            this.timeout_ = setTimeout(this.expire.bind(this), timeout);\n        }\n    }\n\n\n    resolve(data) {\n        if (this.isFinished_) return;\n\n        this.isFinished_ = true;\n        this.clearTimeout_();\n        this.resolve_(data);\n    }\n\n\n    reject(err) {\n        if (this.isFinished_) return;\n\n        this.isFinished_ = true;\n        this.clearTimeout_();\n        this.reject_(err);\n    }\n\n\n    expire() {\n        this.isFinished_ = true;\n        this.clearTimeout_();\n        this.onExpire_();\n        this.reject_(new LineError(Deferred.ErrorCode.EXPIRED, `Timeout ${this.timeoutDuration_} ms exceed`));\n    }\n\n\n    dispose() {\n        this.isFinished_ = true;\n        this.clearTimeout_();\n    }\n\n\n    then(...args) {\n        return this.promise.then.apply(this.promise, args);\n    }\n\n\n    catch(...args) {\n        return this.promise.catch.apply(this.promise, args);\n    }\n\n\n    clearTimeout_() {\n        if (this.timeout_) {\n            clearTimeout(this.timeout_);\n            this.timeout_ = null;\n        }\n    }\n}\n\n\nDeferred.ErrorCode = {\n    EXPIRED: 'dExpired'\n};\n\n\nmodule.exports = Deferred;\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/deferred.js","const assign = require('lodash/assign');\n\n\n// http://stackoverflow.com/a/6248722\nfunction generateDummyId(length = 4) {\n    return (\"0000\" + (Math.random()*Math.pow(36,length) << 0).toString(36)).slice(-length);\n}\n\n\nmodule.exports = {generateDummyId};\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/utils.js","const forEach = require('lodash/forEach');\nconst clone = require('lodash/clone');\nconst Message = require('../lib/message');\nconst debug = require('debug')('line:server:room');\nconst LineError = require('../lib/error');\n\n\n/**\n * Line room class.\n *\n * @private\n * @class ServerRoom\n * @param {string} name Room name\n * @property {string} name\n */\nclass ServerRoom {\n    constructor(name, connections = {}) {\n        this.name = name;\n        this.connections = connections;\n    }\n\n\n    /**\n     * Adds a connection into room.\n     * @param {ServerConnection} connection\n     */\n    add(connection) {\n        // TODO: Check current existing connection maybe?\n        this.connections[connection.id] = connection;\n    }\n\n\n    /**\n     * Removes a connection from room.\n     * @param {ServerConnection} connection\n     * @returns {boolean}\n     */\n    remove(connection) {\n        if (connection != this.connections[connection.id]) {\n            debug(`[${this.name || 'root'}] Did not remove \"${connection.id}\", connection instance is not added or different`);\n            return false;\n        }\n\n        debug(`[${this.name || 'root'}] Removing \"${connection.id}\"`);\n        delete this.connections[connection.id];\n        return true;\n    }\n\n\n    /**\n     * Gets a connection by id.\n     * @param {string} connectionId\n     * @returns {?ServerConnection}\n     */\n    getConnectionById(connectionId) {\n        return this.connections[connectionId];\n    }\n\n\n    /**\n     * Gets all connections in the room. Returns a object where keys are\n     * connection id and values are ServerConnection.\n     * @returns {{string: ServerConnection}}\n     */\n    getConnections() {\n        return clone(this.connections);\n    }\n\n\n    /**\n     * Returns the total connection count in room.\n     * @returns {number}\n     */\n    getConnectionsCount() {\n        return Object.keys(this.connections).length;\n    }\n\n\n    broadcast_(message) {\n        forEach(this.connections, connection => {\n            connection\n                .sendWithoutResponse_(message)\n                .catch((err) => {\n                    debug(`[${this.name || 'root'}] Could not send \"${message.name}\" to \"${connection.id}\" while broadcasting, ignoring...`);\n                });\n        });\n    }\n\n\n    /**\n     * Broadcast a message to all connections in the room.\n     * @param {string} name\n     * @param {any=} payload\n     */\n    broadcast(name, payload) {\n        const message = new Message({name, payload}); // Can throw INVALID_JSON\n        this.broadcast_(message);\n    }\n}\n\n\nmodule.exports = ServerRoom;\n\n\n\n// WEBPACK FOOTER //\n// ./src/server/room.js","module.exports = require(\"lodash/clone\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/clone\"\n// module id = 16\n// module chunks = 0","module.exports = require(\"lodash/debounce\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/debounce\"\n// module id = 17\n// module chunks = 0","module.exports = require(\"lodash/filter\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/filter\"\n// module id = 18\n// module chunks = 0","module.exports = require(\"lodash/isFunction\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isFunction\"\n// module id = 19\n// module chunks = 0","module.exports = require(\"lodash/isString\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isString\"\n// module id = 20\n// module chunks = 0","module.exports = require(\"lodash/isUndefined\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/isUndefined\"\n// module id = 21\n// module chunks = 0","module.exports = require(\"lodash/map\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/map\"\n// module id = 22\n// module chunks = 0","module.exports = require(\"lodash/values\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash/values\"\n// module id = 23\n// module chunks = 0","module.exports = require(\"uuid\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"uuid\"\n// module id = 24\n// module chunks = 0","const Connection = require('./connection');\nconst Message = require('../lib/message');\nconst Rooms = require('./rooms');\nconst EventEmitterExtra = require('event-emitter-extra');\nconst debug = require('debug')('line:server');\nconst LineError = require('../lib/error');\nconst assign = require('lodash/assign');\nconst isInteger = require('lodash/isInteger');\n\nlet WebSocketServer;\ntry {\n    WebSocketServer = require('uws').Server;\n} catch (err) {\n    WebSocketServer = require('ws').Server;\n    debug(`Could not find module uws, falling back to ws`, err);\n}\n\n\n/**\n * Line Server Class\n *\n * @class Server\n * @extends {EventEmitterExtra}\n * @param {Object=} options Options object.\n * @param {string=} options.host The hostname where to bind the server. [Inherited from uws.](https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketserveroptions-callback)\n * @param {number=} options.port The port where to bind the server. [Inherited from uws.](https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketserveroptions-callback)\n * @param {http.Server=} options.server A pre-created Node.js HTTP server. If provided, `host` and `port`\n *      will ignored. [Inherited from uws.](https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketserveroptions-callback)\n * @param {string=} options.path Accept only connections matching this path. [Inherited from uws](https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketserveroptions-callback)\n * @param {number=} options.responseTimeout Default timeout duration (in ms) for message responses. Default: `10000` (10 seconds)\n * @param {number=} options.handshakeTimeout This is the duration how long a client can stay connected\n *      without handshake. Default `60000` (1 minute).\n * @param {number=} options.pingInterval Ping interval in ms. Default: 15 seconds.\n * @example\n * const Server = require('line-socket/server');\n * const server = new Server({\n *   port: 8080\n * });\n */\nclass Server extends EventEmitterExtra {\n    constructor(options = {}) {\n        super();\n\n        this.options = assign({\n            responseTimeout: 10000,\n            handshakeTimeout: 60000,\n            pingInterval: 15000\n        }, options);\n\n        if (!isInteger(this.options.responseTimeout) || this.options.responseTimeout < 0)\n            throw new LineError(Server.ErrorCode.INVALID_OPTIONS, `\"options.responseTimeout\" must be a positive integer or zero`);\n\n        if (!isInteger(this.options.handshakeTimeout) || this.options.handshakeTimeout < 0)\n            throw new LineError(Server.ErrorCode.INVALID_OPTIONS, `\"options.handshakeTimeout\" must be a positive integer or zero`);\n\n        if (!isInteger(this.options.pingInterval) || this.options.pingInterval < 0)\n            throw new LineError(Server.ErrorCode.INVALID_OPTIONS, `\"options.pingInterval\" must be a positive integer or zero`);\n\n        this.rooms = new Rooms();\n\n        debug(`Initalizing with options: ${JSON.stringify(this.options)}`);\n    }\n\n    /**\n     * Starts the server.\n     *\n     * @returns {Promise}\n     * @memberOf Server\n     * @example\n     * server\n     *   .start()\n     *   .then(() => {\n     *     console.log('Server started');\n     *   })\n     *   .catch((err) => {\n     *     console.log('Server could not started', err);\n     *   });\n     */\n    start() {\n        if (this.server) {\n            return Promise.reject(new LineError(\n                Server.ErrorCode.INVALID_ACTION,\n                `Could not start server, already started!`\n            ));\n        }\n\n        if (!this.options.port) {\n            debug(`Starting without port...`);\n\n            try {\n                this.server = new WebSocketServer(this.options);\n                this.bindEvents_();\n                return Promise.resolve();\n            } catch (err) {\n                return Promise.reject(new LineError(\n                    Server.ErrorCode.WEBSOCKET_ERROR,\n                    `Could not start the server, websocket error, check payload`,\n                    err\n                ));\n            }\n        }\n\n        return new Promise((resolve, reject) => {\n            debug(`Starting with port \"${this.options.port}\" ...`);\n\n            this.server = new WebSocketServer(this.options, err => {\n                if (err) {\n                    debug(`Could not start: ${err}`);\n                    return reject(new LineError(\n                        Server.ErrorCode.WEBSOCKET_ERROR,\n                        `Could not start the server, websocket error, check payload`,\n                        err\n                    ));\n                }\n\n                this.bindEvents_();\n                resolve();\n            });\n        })\n    }\n\n\n    /**\n     * Stops the server.\n     *\n     * @returns {Promise}\n     * @memberOf Server\n     * @example\n     * server\n     *   .stop()\n     *   .then(() => {\n     *     console.log('Server stopped');\n     *   })\n     *   .catch((err) => {\n     *     console.log('Server could not stopped', err);\n     *   });\n     */\n    stop() {\n        if (!this.server) {\n            debug(`Could not stop server. Server is probably not started, or already stopped.`);\n            return Promise.reject(new LineError(\n                Server.ErrorCode.INVALID_ACTION,\n                `Could not stop server. Server is probably not started, or already stopped!`\n            ));\n        }\n\n        return new Promise(resolve => {\n            debug(`Closing and disposing the server...`);\n            this.server.close();\n            this.server = null;\n            resolve();\n        });\n    }\n\n\n    /**\n     * Binds websocket server events.\n     *\n     * @ignore\n     */\n    bindEvents_() {\n        debug(`Binding server events...`);\n\n        this.server.on('connection', this.onConnection_.bind(this));\n        this.server.on('headers', this.onHeaders_.bind(this));\n        this.server.on('error', this.onError_.bind(this));\n    }\n\n\n    /**\n     * Native \"connection\" event handler.\n     *\n     * @param {WebSocket} socket\n     * @ignore\n     */\n    onConnection_(socket) {\n        debug(`Native \"connection\" event recieved, creating line connection...`);\n        const connection = new Connection(socket, this);\n    }\n\n\n    /**\n     * Native \"headers\" event handler.\n     *\n     * @param {Array} headers\n     * @ignore\n     */\n    onHeaders_(headers) {\n        debug(`Native \"headers\" event recieved, emitting line's \"headers\" event... (${headers})`);\n        this.emit(Server.Event.HEADERS, headers);\n    }\n\n\n    /**\n     * Native \"error\" event handler.\n     *\n     * @param {Error} err\n     * @ignore\n     */\n    onError_(err) {\n        debug(`Native \"error\" event recieved, emitting line's \"error\" event... (${err})`);\n        this.emit(Server.Event.ERROR, err);\n    }\n\n\n    /**\n     * Returns a object where keys are connection id and values are ServerConnection.\n     *\n     * @returns {{string: ServerConnection}}\n     * @memberOf Server\n     */\n    getConnections() {\n        return this.rooms.root.getConnections();\n    }\n\n\n    /**\n     * Gets a connection by id\n     *\n     * @param {string} id Unique connection id, which can be accessed at `connection.id`\n     * @returns {?ServerConnection}\n     * @memberOf Server\n     * @example\n     * const connection = server.getConnectionById('someId');\n     *\n     * if (connection) {\n     *   connection.send('hello', {optional: 'payload'});\n     * }\n     */\n    getConnectionById(id) {\n        return this.rooms.root.getConnectionById(id);\n    }\n\n\n    /**\n     * Broadcasts a message to all the connected (& handshaked) clients.\n     *\n     * @param {string} name Message name\n     * @param {any=} payload Optional message payload.\n     * @memberOf Server\n     * @example\n     * server.broadcast('hello', {optional: 'payload'});\n     */\n    broadcast(name, payload) {\n        debug(`Broadcasting \"${name}\" message...`);\n        this.rooms.root.broadcast(name, payload); // Can throw INVALID_JSON\n    }\n\n\n    /**\n     * Gets a room by name.\n     * @param {string} room Room name\n     * @returns {?ServerRoom}\n     */\n    getRoom(room) {\n        return this.rooms.getRoom(room);\n    }\n\n    /**\n     * Gets all the rooms of a connection.\n     * @param {ServerConnection} connection\n     * @returns {Array.<string>} Array of room names.\n     */\n    getRoomsOf(connection) {\n        return this.rooms.getRoomsOf(connection);\n    }\n\n\n    /**\n     * Remove a connection from all the rooms.\n     * @param {ServerConnection} connection\n     */\n    removeFromAllRooms(connection) {\n        this.rooms.removeFromAll(connection);\n    }\n}\n\n\n// Expose internal classes\nServer.Message = Message;\nServer.Connection = Connection;\nServer.Error = LineError;\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n */\nServer.ErrorCode = {\n    /**\n     * When constructing `new Server()`, this error could be thrown.\n     */\n    INVALID_OPTIONS: 'sInvalidOptions',\n    /**\n     * This error can be seen in rejection of `server.start()` or `server.stop()` methods.\n     */\n    INVALID_ACTION: 'sInvalidAction',\n    /**\n     * This error is for native websocket errors.\n     */\n    WEBSOCKET_ERROR: 'sWebsocketError'\n};\n\n\n/**\n * @static\n * @readonly\n * @enum {string}\n * @example\n * server.on('connection', (connection) => {\n *   connection.send('hello');\n *   ...\n * });\n *\n * // or better, you can use enums\n *\n * server.on(Server.Event.CONNECTION, (connection) => {\n *   connection.send('hello');\n *   ...\n * });\n *\n * // If you want to authorize your client\n * server.on('handshake', (connection, handshake) => {\n *   if (handshake.payload && handshake.payload.authToken == '...')\n *     handshake.resolve({welcome: 'bro'});\n *   else\n *     handshake.reject(new Error('Invalid auth token'));\n * });\n */\nServer.Event = {\n    /**\n     * `handshake` When a client connection is established, this event will be fired before\n     * `connection` event. Please note that, this event has nothing in common with native websocket\n     * handshaking process. If you want to authorize your clients, you must listen this event and\n     * call `handshake.resolve(...)` or `handshake.reject(...)` accordingly. If you do not consume\n     * this events, all the client connections will be accepted.\n     *\n     * ```\n     * function (connection, handshake) {}\n     * ```\n     *\n     * where `connection` is `ServerConnection` and `handshake` is a `Message` instance.\n     */\n    HANDSHAKE: 'handshake',\n    /**\n     * `connection` This event will fire on a client connects **after successful handshake**.\n     *\n     * ```\n     * function (connection) {}\n     * ```\n     *\n     * where `connection` is a `ServerConnection` instance.\n     */\n    CONNECTION: 'connection',\n    /**\n     * `'headers'` Inherited from uws, [see docs](https://github.com/websockets/ws/blob/master/doc/ws.md#event-headers)\n     */\n    HEADERS: 'headers',\n    /**\n     * `'error'` Inherited from uws, [see docs](https://github.com/websockets/ws/blob/master/doc/ws.md#event-error)\n     */\n    ERROR: 'error'\n};\n\n\nmodule.exports = Server;\n\n\n\n// WEBPACK FOOTER //\n// ./src/server/server.js"],"sourceRoot":""}